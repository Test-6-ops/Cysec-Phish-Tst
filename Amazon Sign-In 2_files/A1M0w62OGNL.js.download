////////////////////////////////////////////
;(function (packageFunction) {
  /* istanbul ignore next */
  var p = window.AmazonUIPageJS || window.P;
  /* istanbul ignore next */
  var attribute = p._namespace || p.attributeErrors;
  /* istanbul ignore next */
  var namespacedP = attribute ? attribute("ACICAssets", "") : p;

  /* istanbul ignore next */
  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET ACICAssets - 1.0
/////////////////////////
// BEGIN FILE js/acic.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@amzn/katal-logger/dist/helper/metrics-aggregator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/helper/metrics-aggregator.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsAggregator = void 0;
var MetricsAggregator = /** @class */ (function () {
    function MetricsAggregator(filterFunction) {
        var _this = this;
        this.filterFunction = filterFunction;
        this.aggregatedMetrics = {};
        window.addEventListener('katal.metrics.publish', function (event) {
            _this.aggregateMetric(event);
        });
    }
    MetricsAggregator.prototype.aggregateMetric = function (event) {
        var _a = event.detail, metric = _a.metric, context = _a.context;
        var serviceName = context.serviceName, methodName = context.methodName;
        if (this.filterFunction && !this.filterFunction(metric, context)) {
            return;
        }
        this.aggregatedMetrics[serviceName] =
            this.aggregatedMetrics[serviceName] || {};
        this.aggregatedMetrics[serviceName][methodName] =
            this.aggregatedMetrics[serviceName][methodName] || {};
        this.aggregatedMetrics[serviceName][methodName][metric.name] =
            this.aggregatedMetrics[serviceName][methodName][metric.name] || [];
        this.aggregatedMetrics[serviceName][methodName][metric.name].push(metric.value);
    };
    return MetricsAggregator;
}());
exports.MetricsAggregator = MetricsAggregator;
//# sourceMappingURL=metrics-aggregator.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Level = void 0;
var promise_polyfill_1 = __importDefault(__webpack_require__(/*! promise-polyfill */ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/index.js"));
var stacktrace_js_1 = __importDefault(__webpack_require__(/*! stacktrace-js */ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-js/stacktrace.js"));
var katal_metrics_1 = __webpack_require__(/*! ./metrics/katal-metrics */ "./node_modules/@amzn/katal-logger/dist/metrics/katal-metrics.js");
var metrics_aggregator_1 = __webpack_require__(/*! ./helper/metrics-aggregator */ "./node_modules/@amzn/katal-logger/dist/helper/metrics-aggregator.js");
var Level;
(function (Level) {
    Level["DEBUG"] = "debug";
    Level["INFO"] = "info";
    Level["WARN"] = "warn";
    Level["ERROR"] = "error";
    Level["FATAL"] = "fatal";
})(Level = exports.Level || (exports.Level = {}));
var LOG_LEVELS = [
    Level.DEBUG,
    Level.INFO,
    Level.WARN,
    Level.ERROR,
    Level.FATAL,
];
var DEFAULT_MAX_LOG_LINE_SIZE = 10000; // 10 kilobytes default
var DEFAULT_BATCH_TIMEOUT_DURATION = 5000;
var DEFAULT_MAX_LOGS_PER_BATCH = 25;
var CONFIG_DEFAULTS = {
    logThreshold: Level.DEBUG,
    maxLogLineSize: DEFAULT_MAX_LOG_LINE_SIZE,
    batchTimeoutDuration: DEFAULT_BATCH_TIMEOUT_DURATION,
    decodeStackTrace: false,
    recordMetrics: true,
    context: {},
    headers: {},
    logToConsole: false,
    maxLogsPerBatch: DEFAULT_MAX_LOGS_PER_BATCH,
    useXMLHttpRequest: false,
};
// obtained from https://developer.mozilla.org/en-US/docs/Web/API/Event
var EVENT_PROPERTIES = [
    'bubbles',
    'cancelBubble',
    'cancelable',
    'composed',
    'currentTarget',
    'deepPath',
    'defaultPrevented',
    'eventPhase',
    'explicitOriginalTarget',
    'originalTarget',
    'returnValue',
    'srcElement',
    'target',
    'timeStamp',
    'type',
    'isTrusted',
];
var ERROR_EVENT_PROPERTIES = __spreadArrays(EVENT_PROPERTIES, ['message']);
var KatalLogger = /** @class */ (function () {
    /**
     * Construct a KatalLogger
     *
     * @param config
     */
    function KatalLogger(config) {
        var _this = this;
        this.resourceTimingLogged = false;
        this.sendLogsToBackend = function () {
            var logsToSend = _this.logLineQueue;
            if (logsToSend.length === 0) {
                return;
            }
            _this.logLineQueue = [];
            _this.currentLogBatchSize = 0;
            var logs = {
                logs: logsToSend,
            };
            _this.sendLogToBackend(_this.toJSON(logs));
            _this.queueTimerId = undefined;
        };
        var configWithDefaults = __assign(__assign({}, CONFIG_DEFAULTS), config);
        this.url = configWithDefaults.url;
        this.logThreshold = configWithDefaults.logThreshold;
        this.maxLogLineSize = configWithDefaults.maxLogLineSize;
        this.context = configWithDefaults.context;
        this.logToConsole = configWithDefaults.logToConsole;
        this.headers = configWithDefaults.headers;
        this.recordMetrics = configWithDefaults.recordMetrics;
        this.batchTimeoutDuration = configWithDefaults.batchTimeoutDuration;
        this.decodeStackTrace = configWithDefaults.decodeStackTrace;
        this.maxLogsPerBatch = configWithDefaults.maxLogsPerBatch;
        // Some teams are setting maxLogsPerBatch as 0 for unit test cases which is making maxLogBatchSize as 0
        // and due to which this check `this.maxLogBatchSize < this.maxLogLineSize` is failing
        // and throwing an error during build time.
        // https://code.amazon.com/search?term=%22maxLogsPerBatch%3A+0%22
        this.maxLogBatchSize =
            config.maxLogBatchSize ||
                this.maxLogLineSize * (this.maxLogsPerBatch || 1);
        this.currentLogBatchSize = 0;
        this.xhrWithCredentials = configWithDefaults.xhrWithCredentials;
        this.useXMLHttpRequest = configWithDefaults.useXMLHttpRequest;
        this.logLineQueue = [];
        this.unregisterFns = [];
        this.unloaded = false;
        this.logThresholdIndex = Math.max(LOG_LEVELS.indexOf(Level.DEBUG), LOG_LEVELS.indexOf(this.logThreshold));
        if (this.maxLogBatchSize < this.maxLogLineSize) {
            throw new Error("maxLogBatchSize(" + this.maxLogBatchSize + ") must be greater than maxLogLineSize(" + this.maxLogLineSize + ")");
        }
        if (configWithDefaults.sendToBackendOverride &&
            typeof configWithDefaults.sendToBackendOverride === 'function') {
            this.sendLogToBackend = configWithDefaults.sendToBackendOverride;
        }
        if (this.recordMetrics) {
            this.metricsPublisher = katal_metrics_1.createMetricsPublisher('KatalLogger:Loaded');
            this.metricsPublisher.publishCounterMonitor('KatalLogger:construct', 1);
        }
        this.registerUnloadAction(function () {
            _this.unloaded = true;
            _this.sendLogsToBackend();
        });
        /**
         * Set this.unloaded to false to continue queueing the logs
         */
        this.registerBackToPageAction(function () {
            _this.unloaded = false;
        });
    }
    /**
     * Cover all of the unload cases:
     * https://www.igvita.com/2015/11/20/dont-lose-user-and-app-state-use-page-visibility/
     */
    KatalLogger.prototype.registerUnloadAction = function (callback) {
        this.registerEvent('pagehide', callback);
        this.registerEvent('beforeunload', callback);
        this.registerEvent('visibilitychange', function () {
            if (document.visibilityState === 'hidden') {
                callback();
            }
        });
    };
    /**
     * Check if the user comes back to the page
     * https://t.corp.amazon.com/D69927460
     */
    KatalLogger.prototype.registerBackToPageAction = function (callback) {
        this.registerEvent('pageshow', callback);
        this.registerEvent('visibilitychange', function () {
            if (document.visibilityState === 'visible') {
                callback();
            }
        });
    };
    /**
     * Log a copy of Katal Metrics emitted on this page
     * @param filterFunction: an optional function to filter metrics before publishing
     */
    KatalLogger.prototype.addMetricsListener = function (filterFunction) {
        var _this = this;
        var aggregator = new metrics_aggregator_1.MetricsAggregator(filterFunction);
        var unloadedAlready = false;
        this.registerUnloadAction(function () {
            if (unloadedAlready)
                return;
            unloadedAlready = true;
            _this.info('Katal Metrics', aggregator.aggregatedMetrics);
        });
    };
    /**
     * Adds a formatted version of Performance API logs.
     * Uses https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries
     * to determine resource and paint timings.
     */
    KatalLogger.prototype.addPerformanceListener = function () {
        var _this = this;
        this.registerUnloadAction(function () {
            _this.logResourceTiming();
        });
    };
    KatalLogger.prototype.logResourceTiming = function () {
        var _a, _b;
        if (this.resourceTimingLogged) {
            return;
        }
        this.resourceTimingLogged = true;
        var resource = window.performance
            .getEntriesByType('resource')
            .reduce(function (acc, resourceTiming) {
            var _a;
            var _b = resourceTiming, name = _b.name, initiatorType = _b.initiatorType, duration = _b.duration;
            var resource = name.split('/').pop();
            acc[initiatorType] = (_a = acc[initiatorType]) !== null && _a !== void 0 ? _a : {};
            acc[initiatorType][resource] = Math.round(duration);
            return acc;
        }, {});
        var paint = window.performance
            .getEntriesByType('paint')
            .reduce(function (acc, _a) {
            var name = _a.name, startTime = _a.startTime;
            acc[name] = Math.round(startTime);
            return acc;
        }, {});
        var navigation = Object.entries((_b = (_a = window.performance.getEntriesByType('navigation')[0]) === null || _a === void 0 ? void 0 : _a.toJSON()) !== null && _b !== void 0 ? _b : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            acc[key] = typeof value === 'number' ? Math.round(value) : value;
            return acc;
        }, {});
        this.info("Performance Timing", { resource: resource, paint: paint, navigation: navigation });
    };
    /**
     * Adds an event listener for errors. Will log the error if the filter callback returns true
     *
     * @param filterCallback function that takes an error object and returns whether it should be logged
     */
    KatalLogger.prototype.addErrorListener = function (filterCallback) {
        var _this = this;
        ['error', 'unhandledrejection'].map(function (listener) {
            _this.registerEvent(listener, 
            /* istanbul ignore next - this.eventListener tested seperately */
            function (e) {
                return _this.eventListener(e, filterCallback);
            }, true);
        });
    };
    /**
     * Removes the registered error event listeners
     * Normal applications need not call this.
     * This is required for multitenant SPAs to avoid memory leaks.
     */
    KatalLogger.prototype.removeErrorListener = function () {
        this.unregisterFns.forEach(function (fn) { return fn(); });
    };
    KatalLogger.prototype.registerEvent = function (event, cb, capture) {
        window.addEventListener(event, cb, capture);
        this.unregisterFns.push(function () {
            window.removeEventListener(event, cb, capture);
        });
    };
    KatalLogger.prototype.eventListener = function (e, filterCallback) {
        var errorMessage;
        var error;
        // e is an ErrorEvent
        if (e.error) {
            errorMessage = e.error.message;
            error = e.error;
        }
        // e is PromiseRejectionEvent
        else if (e.reason) {
            if (isError(e.reason)) {
                errorMessage = e.reason.message;
                error = e.reason;
            }
            else {
                errorMessage = e.reason;
            }
        }
        else if (isError(e)) {
            errorMessage = e.message;
            error = e;
        }
        else {
            errorMessage = "An unknown error occurred: " + this.toStringObject(e);
            // Capture a stack trace
            error = new Error('Unknown error');
        }
        if (errorMessage !== 'KatalLogger error' &&
            (!filterCallback || filterCallback(error))) {
            try {
                return this.error(errorMessage, error);
            }
            catch (_) {
                // Prevent infinite loops by swallowing errors that occur while logging errors
            }
        }
    };
    KatalLogger.prototype.createJsonStringifyReplacer = function () {
        var cache = new Map();
        return function (key, value) {
            if (typeof value === 'object' && value != null) {
                if (cache.has(value)) {
                    return "reference-loop, also referenced from '" + cache.get(value) + "'";
                }
                cache.set(value, key);
            }
            return value;
        };
    };
    /**
     * Event objects are hard to serialize (see https://stackoverflow.com/questions/11547672/how-to-stringify-event-object) so we need a helper method
     */
    KatalLogger.prototype.toStringObject = function (object) {
        var constructorName = object.constructor.name;
        if (object instanceof Event) {
            var objectProperties = EVENT_PROPERTIES;
            var eventObject = {};
            /** if error event, we need to capture the error message */
            if (object instanceof ErrorEvent) {
                objectProperties = ERROR_EVENT_PROPERTIES;
            }
            for (var _i = 0, objectProperties_1 = objectProperties; _i < objectProperties_1.length; _i++) {
                var prop = objectProperties_1[_i];
                /** ignore serializing and logging the entire window log
                 */
                if (object[prop] !== window) {
                    eventObject[prop] = object[prop];
                }
            }
            object = eventObject;
        }
        return constructorName + ':' + this.toJSON(object);
    };
    /**
     * JSON.stringify can throw but we really don't want to error when logging error
     * so use our own error-safe serialization
     */
    KatalLogger.prototype.toJSON = function (data) {
        var stringified;
        try {
            stringified = JSON.stringify(data, this.createJsonStringifyReplacer());
        }
        catch (error) {
            stringified = "{ \"KatalLogger\": \"Failed to serialize!\", \"data\": \"" + data + "\", \"error\": \"" + error + "\" }";
        }
        return stringified;
    };
    KatalLogger.prototype.debug = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.DEBUG, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.info = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.INFO, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.warn = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.WARN, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.error = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.ERROR, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.fatal = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.FATAL, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.extractArgs = function (level, message, error, context) {
        var errorInfo = isError(error)
            ? {
                errorMessage: error.message,
                errorName: error.name,
                errorStackTrace: '',
            }
            : undefined;
        var logPayload = {
            level: level,
            message: message,
            error: errorInfo,
            context: __assign(__assign(__assign({}, this.context), (errorInfo ? context : error)), { logTime: Date.now() }),
        };
        if (logPayload.error) {
            return this.getStackTraceFromError(error).then(function (trace) {
                logPayload.error.errorStackTrace = trace;
                return logPayload;
            });
        }
        return promise_polyfill_1.default.resolve(logPayload);
    };
    KatalLogger.prototype.getStackTraceFromError = function (error) {
        if (!this.decodeStackTrace) {
            return promise_polyfill_1.default.resolve(String(error.stack));
        }
        return promise_polyfill_1.default.resolve(stacktrace_js_1.default.fromError(error)
            .then(function (stackframes) {
            return stackframes.map(function (sf) { return sf.toString(); }).join('\n');
        })
            .catch(function (err) {
            // we failed to decode it, just output raw
            return String(error.stack) +
                '\n\nFailed to decode stacktrace:\n' +
                String(err);
        }));
    };
    KatalLogger.prototype.sendRequest = function (payload) {
        this.queueLogLine(payload);
        if (this.logToConsole) {
            this.sendLogToConsole(payload);
        }
    };
    KatalLogger.prototype.sendLogToConsole = function (data) {
        var level = data.level;
        if (!LOG_LEVELS.includes(data.level) || data.level === Level.FATAL) {
            level = Level.ERROR;
        }
        console[level](data);
    };
    KatalLogger.prototype.queueLogLine = function (payload) {
        if (this.payloadIsValid(payload)) {
            var payloadSize = this.getPayloadSize(payload);
            if (this.currentLogBatchSize + payloadSize > this.maxLogBatchSize) {
                this.sendLogsToBackend();
            }
            this.appendToQueue(payload);
            this.currentLogBatchSize += payloadSize;
            if (this.unloaded || this.logLineQueue.length >= this.maxLogsPerBatch) {
                this.sendLogsToBackend();
            }
            else if (!this.queueTimerId) {
                this.queueTimerId = window.setTimeout(this.sendLogsToBackend, this.batchTimeoutDuration);
            }
        }
    };
    KatalLogger.prototype.appendToQueue = function (payload) {
        this.logLineQueue.push(payload);
    };
    KatalLogger.prototype.doCallBeacon = function () {
        return ((navigator === null || navigator === void 0 ? void 0 : navigator.sendBeacon) &&
            !(Object.keys(this.headers).length || this.useXMLHttpRequest));
    };
    KatalLogger.prototype.sendLogToBackend = function (dataString) {
        if (this.url) {
            if (this.doCallBeacon()) {
                navigator.sendBeacon(this.url, dataString);
            }
            else {
                var xhr_1 = new XMLHttpRequest();
                // xhr request is set to async.
                // In case this needs to be changed to sync, it should be noted that xhr.withCredentials with sync request is not supported since Firefox 11.
                // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#browser_compatibility
                xhr_1.open('POST', this.url, true);
                if (this.xhrWithCredentials) {
                    xhr_1.withCredentials = this.xhrWithCredentials;
                }
                Object.entries(this.headers).forEach(function (_a) {
                    var headerName = _a[0], headerValue = _a[1];
                    xhr_1.setRequestHeader(headerName, headerValue);
                });
                xhr_1.send(dataString);
            }
        }
    };
    KatalLogger.prototype.payloadIsValid = function (data) {
        var a = LOG_LEVELS.indexOf(data.level);
        var b = this.logThresholdIndex;
        var passesLogLevelCheck = a >= b;
        if (passesLogLevelCheck) {
            var payloadSize = this.getPayloadSize(data);
            if (payloadSize <= this.maxLogLineSize) {
                return true;
            }
        }
        return false;
    };
    KatalLogger.prototype.getPayloadSize = function (data) {
        var dataString = this.toJSON(data);
        return dataString.length;
    };
    return KatalLogger;
}());
exports.default = KatalLogger;
function isError(object) {
    /* istanbul ignore next - in node (unit tests) there is no error.constructor. In ie, there is no error.stack */
    return ((object === null || object === void 0 ? void 0 : object.name) && object.message && (object.stack || !!object.constructor));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/dist/metrics/katal-metrics.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/metrics/katal-metrics.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* istanbul ignore file */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMetricsPublisher = void 0;
var metrics_publisher_singleton_1 = __webpack_require__(/*! ./metrics-publisher-singleton */ "./node_modules/@amzn/katal-logger/dist/metrics/metrics-publisher-singleton.js");
exports.createMetricsPublisher = function (methodName) {
    return metrics_publisher_singleton_1.MetricsPublisherSingleton.getInstance().newChildActionPublisherForMethod(methodName);
};
//# sourceMappingURL=katal-metrics.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/dist/metrics/metrics-publisher-singleton.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/metrics/metrics-publisher-singleton.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsPublisherSingleton = void 0;
var KatalMetrics = __importStar(__webpack_require__(/*! @amzn/katal-metrics */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js"));
var katal_metrics_driver_sushi_1 = __importDefault(__webpack_require__(/*! @amzn/katal-metrics-driver-sushi */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js"));
var MetricsPublisherSingleton = /** @class */ (function () {
    /* istanbul ignore next - Private constructor to prevent initializing the singleton */
    function MetricsPublisherSingleton() {
    }
    MetricsPublisherSingleton.getInstance = function () {
        if (!MetricsPublisherSingleton.instance) {
            /* istanbul ignore next - This is invoked by the metrics driver */
            var metricsErrorHandler = function (err) {
                console.error(err);
            };
            var metricsDriver = this.getMetricsDriver(metricsErrorHandler);
            var metricsContext = this.getMetricsContext();
            MetricsPublisherSingleton.instance = new KatalMetrics.Publisher(metricsDriver, metricsErrorHandler, metricsContext);
        }
        return MetricsPublisherSingleton.instance;
    };
    MetricsPublisherSingleton.getMetricsContext = function () {
        var urlMatch = /([^?]+)/.exec(window.location.href);
        var urlMetric = new KatalMetrics.Metric.String('url', 
        /* istanbul ignore next - This is invoked by the metrics context */
        urlMatch ? urlMatch[1] : window.location.href);
        urlMetric.truncate = true;
        return new KatalMetrics.Context.Builder()
            .withSite('KatalLoggerInternalMetrics')
            .withServiceName('KatalLogger')
            .addRelatedMetrics(urlMetric)
            .build();
    };
    MetricsPublisherSingleton.getMetricsDriver = function (metricsErrorHandler) {
        return new katal_metrics_driver_sushi_1.default.Builder()
            .withDomainRealm('prod', 'USAmazon')
            .withErrorHandler(metricsErrorHandler)
            .build();
    };
    return MetricsPublisherSingleton;
}());
exports.MetricsPublisherSingleton = MetricsPublisherSingleton;
//# sourceMappingURL=metrics-publisher-singleton.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KatalMetricsDriverSushi = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectSpread */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricsDriver2 = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/metricObject/KatalMetricType */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

var _katalSushiClient = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-sushi-client */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-sushi-client/dist/SushiClient.js"));

var _temp;

var KAT_STANDALONE_NEXUS_PRODUCER_ID = 'katal';
var KAT_STANDALONE_DEFAULT_SOURCE_GROUPS = {
  test: 'com.amazon.eel.katal.metrics.core.nexus.gamma',
  prod: 'com.amazon.eel.katal.metrics.core.nexus'
};

var KatalMetricsDriverSushi =
/*#__PURE__*/
function (_KatalMetricsDriver) {
  (0, _inherits2.default)(KatalMetricsDriverSushi, _KatalMetricsDriver);

  function KatalMetricsDriverSushi(options) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricsDriverSushi);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricsDriverSushi).call(this));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sushi", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "producerId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sourceGroupId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "errorHandler", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "combinedErrorHandler", function (err) {
      if (_this.errorHandler) {
        try {
          _this.errorHandler(err); // Return to avoid falling through to default error handler


          return;
        } catch (nextErr) {
          console.error("Error handling error publishing metrics:");
          console.error(nextErr); // Fall through
        }
      }

      _this.defaultErrorHandler(err);
    });
    var domain = options.domain,
        realm = options.realm,
        errorHandler = options.errorHandler,
        sushiClient = options.sushiClient,
        _options$sushiProduce = options.sushiProducer,
        producerId = _options$sushiProduce === void 0 ? KAT_STANDALONE_NEXUS_PRODUCER_ID : _options$sushiProduce,
        sushiClientOptions = options.sushiClientOptions,
        sushiClientTransportOverride = options.sushiClientTransportOverride; // custom source group always overrides defaults

    var sourceGroupId = options.sourceGroupId || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS[domain] || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS['test'];
    _this.sushi = sushiClient || _this.buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride);
    _this.errorHandler = errorHandler;
    _this.producerId = producerId;
    _this.sourceGroupId = sourceGroupId;
    return _this;
  }

  (0, _createClass2.default)(KatalMetricsDriverSushi, [{
    key: "beforeUnload",

    /**
     * Register a callback to be called right before the page unloads. This
     * allows for any final metrics, such as page visit duration, to be sent
     * before the user navigates away from the page or closes the tab.
     * NOTE: This is an experimental API and may change in the future.
     * @param cb The callback to call.
     */
    value: function beforeUnload(cb) {
      this.sushi.onSushiUnload(cb);
    }
    /**
     * Default error handler if the user-supplied error handler fails or is unset.  Should never be called unless
     * user-provided error handler misbehaves.
     *
     * @param err Unhandled error object
     */

  }, {
    key: "defaultErrorHandler",
    value: function defaultErrorHandler(err) {
      console.error("Error publishing metrics:");
      console.error(err);
    }
    /**
     * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
     * an exception, calls the default error handler as a fallback, which will just log the error to the console.
     *
     * @param err Error object to handle
     */

  }, {
    key: "withErrorHandling",

    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    value: function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
  }, {
    key: "buildSushiClient",
    value: function buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride) {
      if (!domain || !realm) {
        throw new Error('KatalMetricsDriverSushi requires a domain and realm to build a sushi client.');
      }

      return new _katalSushiClient.default(KatalMetricsDriverSushi.getRealmName(realm), sourceGroupId, this.combinedErrorHandler, sushiClientOptions, sushiClientTransportOverride);
    }
  }, {
    key: "publish",
    // TODO: errorHandler in this method is deprecated and is not referenced.
    // Tech debt: https://issues.amazon.com/issues/KAT-875
    value: function publish(metricObject, errorHandler, context) {
      var _this2 = this;

      // Support for new 2-argument form of publish, which does not pass the unused errorHandler object (KAT-875)
      var metricsContext = arguments.length < 3 ? arguments[1] : arguments[2];
      this.withErrorHandling(function () {
        // TODO: This logic is now moved into KatalMetricsPublisher, once everybody has that update we can remove this.
        // Tech debt: https://issues.amazon.com/issues/KAT-876
        if (_KatalMetricType.default.List === metricObject.type) {
          metricObject.metricList.forEach(function (metric) {
            _this2.publish(metric, metricsContext);
          });
          return;
        }

        var nexusSchema = _this2.mapObjectTypeToNexusSchema(metricObject.type);

        var fields = (0, _objectSpread2.default)({}, metricsContext.context, {
          metricKey: metricObject.name,
          value: metricObject.value
        });

        if (metricObject.isMonitor) {
          fields.isMonitor = true;
        } // Reset the event count back to 0, otherwise Sushi will stop publishing after 1K items (https://issues.amazon.com/issues/KAT-1534)


        _this2.sushi.reset();

        _this2.sushi.event(fields, _this2.producerId, nexusSchema, {
          "ssd": 1
        });
      });
    }
  }, {
    key: "mapObjectTypeToNexusSchema",
    value: function mapObjectTypeToNexusSchema(objectType) {
      switch (objectType) {
        case _KatalMetricType.default.String:
          return 'katal.client.metrics.String.2';

        case _KatalMetricType.default.Counter:
          return 'katal.client.metrics.Counter.3';

        case _KatalMetricType.default.Timer:
          return 'katal.client.metrics.Timer.2';

        default:
          throw new Error("Unknown type ".concat(objectType, " when publishing metric object."));
      }
    }
  }], [{
    key: "getRealmName",
    value: function getRealmName(realm) {
      switch (realm) {
        case 'NAAmazon':
        case 'USAmazon':
          return _katalSushiClient.default.REGIONS.NA;

        case 'EUAmazon':
          return _katalSushiClient.default.REGIONS.EU;

        case 'FEAmazon':
        case 'JPAmazon':
          return _katalSushiClient.default.REGIONS.FE;

        case 'CNAmazon':
          return _katalSushiClient.default.REGIONS.CN;

        default:
          // Let the SushiClient decide if this is bogus or not.
          return realm;
      }
    }
  }]);
  return KatalMetricsDriverSushi;
}(_KatalMetricsDriver2.default);

exports.KatalMetricsDriverSushi = KatalMetricsDriverSushi;
(0, _defineProperty2.default)(KatalMetricsDriverSushi, "Builder", (_temp =
/*#__PURE__*/
function () {
  function _temp() {
    (0, _classCallCheck2.default)(this, _temp);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(_temp, [{
    key: "withSushiClient",
    value: function withSushiClient(sushiClient) {
      this.context.sushiClient = sushiClient;
      return this;
    }
  }, {
    key: "withDomainRealm",
    value: function withDomainRealm(domain, realm) {
      this.context.domain = domain;
      this.context.realm = realm;
      return this;
    }
  }, {
    key: "withCustomProducer",
    value: function withCustomProducer(sushiProducerId) {
      this.context.sushiProducer = sushiProducerId;
      return this;
    }
  }, {
    key: "withCustomSourceGroup",
    value: function withCustomSourceGroup(sourceGroupId) {
      this.context.sourceGroupId = sourceGroupId;
      return this;
    }
  }, {
    key: "withErrorHandler",
    value: function withErrorHandler(errorHandler) {
      this.context.errorHandler = errorHandler;
      return this;
    }
  }, {
    key: "withSushiClientOptions",
    value: function withSushiClientOptions(sushiClientOptions) {
      this.context.sushiClientOptions = sushiClientOptions;
      return this;
    }
  }, {
    key: "withSushiClientTransportOverride",
    value: function withSushiClientTransportOverride(sushiClientTransportOverride) {
      this.context.sushiClientTransportOverride = sushiClientTransportOverride;
      return this;
    }
  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsDriverSushi(this.context);
    }
  }]);
  return _temp;
}(), _temp));

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! ./nodejsShims */ 0);

var _KatalMetricsDriverSushi = __webpack_require__(/*! ./KatalMetricsDriverSushi */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js");

/* istanbul ignore file */
var _default = _KatalMetricsDriverSushi.KatalMetricsDriverSushi;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectSpread */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ./helper/ValidateSimpleString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ./helper/FirstMap */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

var _temp;

var REQUIRED_FIELDS = ['site', 'serviceName', 'methodName'];

var KatalMetricsContext =
/*#__PURE__*/
function () {
  /**
   * Create a new metrics context with the given fields.
   *
   * @param contextFields Context fields value (default empty)
   */
  function KatalMetricsContext() {
    var contextFields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, KatalMetricsContext);
    // Copy fields so this is immutable
    this.context = (0, _objectSpread2.default)({}, contextFields);
  }
  /**
   * Return a new KatalMetricsContext which is a copy of this context, with values added or overridden from
   * the given context.
   *
   * If the given context is null or empty, this method may return the original object as an optimization.
   *
   * @param thatContext Context to merge values from
   * @return New context with default values from this context, and values overridden or added by the given context.
   */


  (0, _createClass2.default)(KatalMetricsContext, [{
    key: "merge",
    value: function merge(thatContext) {
      if (!thatContext) return this; // Check for a common error

      if (thatContext instanceof KatalMetricsContext.Builder) {
        throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
      }

      var context = thatContext instanceof KatalMetricsContext ? thatContext.context : thatContext;
      var newContext = (0, _objectSpread2.default)({}, this.context, context, {
        relatedMetrics: (0, _mergeLists.mergeLists)(this.context.relatedMetrics, context.relatedMetrics),
        relatedMetricsSingleAction: (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, context.relatedMetricsSingleAction)
      });
      return new KatalMetricsContext(newContext);
    }
    /**
     * Return a new context which is a copy of this context with relatedMetricsSingleAction removed.
     *
     * This is intended to be called when creating a new child publisher.
     *
     * @return Copy of this context, with relatedMetricsSingleAction removed
     */

  }, {
    key: "withoutRelatedMetricsSingleAction",
    value: function withoutRelatedMetricsSingleAction() {
      return new KatalMetricsContext((0, _objectSpread2.default)({}, this.context, {
        relatedMetricsSingleAction: undefined
      }));
    }
    /**
     * Get a context suitable for publication to the driver.
     *
     * This method strips out any private fields, and leaves only fields from the schema that the driver should publish.
     *
     * @return Context suitable for driver publication
     */

  }, {
    key: "driverContext",
    value: function driverContext() {
      // Don't publish relatedMetrics to the driver
      var newContextFields = (0, _objectSpread2.default)({}, this.context);
      delete newContextFields["relatedMetrics"];
      delete newContextFields["relatedMetricsSingleAction"];
      delete newContextFields["requestId"];

      if (this.context.requestId) {
        newContextFields.actionId = (0, _embedRequestId.embedRequestId)(newContextFields.actionId, this.context.requestId);
      }

      return new KatalMetricsContext(newContextFields);
    }
    /**
     * Get a simple JavaScript object with a copy of the fields for this context.
     *
     * @return Simple Javascript object with a copy of the fields for this context
     */

  }, {
    key: "getFields",
    value: function getFields() {
      // Copy fields so this remains immutable
      return (0, _objectSpread2.default)({}, this.context);
    }
    /**
     * Check for a validation error on this context.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns Errors found with this context
     */

  }, {
    key: "validationError",
    value: function validationError() {
      var _this = this;

      var err; // Fields site, serviceName, methodName, and metricKey are required.

      err = (0, _FirstMap.default)(REQUIRED_FIELDS, function (field) {
        if (_this.context[field] == undefined) {
          return new Error("Field ".concat(field, " is required, but it is ").concat(_this.context[field]));
        }
      });
      if (err) return err;
      return (0, _FirstMap.default)(Object.keys(this.context), function (field) {
        return _this.validateField(field);
      });
    }
    /**
     * Validate an individual context field.
     *
     * @param field Name of field to validate
     * @returns Error found with this field, or undefined
     */

  }, {
    key: "validateField",
    value: function validateField(field) {
      var val = this.context[field];
      var nameForError = "field ".concat(field);

      switch (field) {
        // Strings which could be used as partition keys ("site" and "serviceName") cannot contain slashes, in
        // addition to the other restictions below.
        case 'site':
        case 'serviceName':
          if (val.indexOf('/') > -1) return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It cannot contain a slash."));
        // Else fall through
        // Strings for fields site, serviceName, methodName, metricKey must match be valid PMET field names:
        // maximum length of 256, only letters, numbers, and the dot, colon, at-sign, underscore, forward-slash,
        // and slash characters (in short the regex ^[A-Za-z0-9.:@_/-]+$).

        case 'methodName':
        case 'actionId':
          return (0, _ValidateSimpleString.default)(val, nameForError);
      } // No error found, implicitly return undefined

    }
    /**
     * Builder class for KatalMetricsContext
     */

  }]);
  return KatalMetricsContext;
}();

exports.default = KatalMetricsContext;
(0, _defineProperty2.default)(KatalMetricsContext, "Builder", (_temp =
/*#__PURE__*/
function () {
  function _temp() {
    (0, _classCallCheck2.default)(this, _temp);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(_temp, [{
    key: "withSite",
    value: function withSite(site) {
      this.context.site = site;
      return this;
    }
  }, {
    key: "withServiceName",
    value: function withServiceName(serviceName) {
      this.context.serviceName = serviceName;
      return this;
    }
  }, {
    key: "withMethodName",
    value: function withMethodName(methodName) {
      this.context.methodName = methodName;
      return this;
    }
  }, {
    key: "withActionId",
    value: function withActionId(actionId) {
      this.context.actionId = actionId;
      return this;
    }
  }, {
    key: "withRequestId",
    value: function withRequestId(requestId) {
      this.context.requestId = requestId;
      return this;
    }
    /**
     * Replace any related metrics with the given list (see addRelatedMetrics to add instead of replace).
     *
     * Related metrics are metrics that are published whenever a new action is started.  They are used to relate the
     * action back to the context where it is happening, for example a request ID or a user identity.
     *
     * @param relatedMetrics Related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetrics",
    value: function withRelatedMetrics() {
      for (var _len = arguments.length, relatedMetrics = new Array(_len), _key = 0; _key < _len; _key++) {
        relatedMetrics[_key] = arguments[_key];
      }

      this.context.relatedMetrics = relatedMetrics;
      return this;
    }
    /**
     * Add additional related metrics to this builder.  See withRelatedMetrics for more information.
     *
     * @param relatedMetrics Additional related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetrics",
    value: function addRelatedMetrics() {
      for (var _len2 = arguments.length, relatedMetrics = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        relatedMetrics[_key2] = arguments[_key2];
      }

      this.context.relatedMetrics = (0, _mergeLists.mergeLists)(this.context.relatedMetrics, relatedMetrics);
      return this;
    }
    /**
     * Replace single-action related metrics with the given list (see addRelatedMetricsSingleAction to add instead of replace,
     * and withRelatedMetrics for more information about related metrics).
     *
     * Single-action related metrics are published when a new child metric publisher is created, but not included as
     * related metrics for the new child metric publisher, so are not published again if the child metric publisher
     * creates grandchild published metrics.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetricsSingleAction",
    value: function withRelatedMetricsSingleAction() {
      for (var _len3 = arguments.length, metrics = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        metrics[_key3] = arguments[_key3];
      }

      this.context.relatedMetricsSingleAction = metrics;
      return this;
    }
    /**
     * Add additional single-action related metrics to this builder.  See addRelatedMetricsSingleAction for more information.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetricsSingleAction",
    value: function addRelatedMetricsSingleAction() {
      for (var _len4 = arguments.length, metrics = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        metrics[_key4] = arguments[_key4];
      }

      this.context.relatedMetricsSingleAction = (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, metrics);
      return this;
    }
    /**
     * Take the fields set in this builder and use them to create a new KatalMetricsContext.
     *
     * @return KatalMetricsContext object built with the parameters given to this builder
     */

  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsContext(this.context);
    }
  }]);
  return _temp;
}(), _temp));

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _v = _interopRequireDefault(__webpack_require__(/*! uuid/v4 */ "./node_modules/@amzn/katal-logger/node_modules/uuid/v4.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _KatalMetricObject = _interopRequireDefault(__webpack_require__(/*! ./metricObject/KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var KatalMetrics = _interopRequireWildcard(__webpack_require__(/*! . */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./metricObject/KatalMetricString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _metricsExtension = __webpack_require__(/*! ./helper/metricsExtension */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

var INITIALIZATION_METHOD_NAME = 'Initialization';

/**
 * Default error handler if the user-supplied error handler fails or is unset.
 * Should never be called unless user-provided error handler misbehaves.
 */
var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  console.error("Error publishing metrics:");
  console.error(err);
};

var PARENT_ACTION_ID_NAME = 'parentActionId';

var getContextFields = function getContextFields(context) {
  if (context.context) {
    return context.context;
  } else {
    return context;
  }
};
/**
 * Class used for publishing metrics to Katal.  Contains a driver and a context.
 *
 * This class knows how to publish metrics, and how to create new publishers with a modified context.
 */


var KatalMetricsPublisher =
/*#__PURE__*/
function () {
  /**
   * Create a new metrics publisher with the given driver and context
   *
   * @param driver Subclass of KatalMetricsDriver used to publish the metrics
   * @param errorHandler Handler for errors that occur while using this publisher
   * @param context Context for this metrics publisher; contains data to be included with every
   *     metric published using this publisher object.  Default is an empty context.
   */
  function KatalMetricsPublisher(driver) {
    var _this = this;

    var errorHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ERROR_HANDLER;
    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _KatalMetricsContext.default();
    (0, _classCallCheck2.default)(this, KatalMetricsPublisher);
    (0, _defineProperty2.default)(this, "combinedErrorHandler", function (err) {
      try {
        _this.errorHandler(err);
      } catch (nextErr) {
        console.error("Error handling error publishing metrics:");
        console.error(nextErr);
        DEFAULT_ERROR_HANDLER(err);
      }
    });

    // Check for a common error
    if (context instanceof _KatalMetricsContext.default.Builder) {
      throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
    }

    this.driver = driver;
    this.errorHandler = errorHandler;
    this.context = !(context instanceof _KatalMetricsContext.default) ? new _KatalMetricsContext.default(context) : context;
  }
  /**
   * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
   * an exception, calls the default error handler as a fallback, which will just log the error to the console.
   *
   * @param err Error object to handle
   */


  (0, _createClass2.default)(KatalMetricsPublisher, [{
    key: "withErrorHandling",

    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    value: function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
    /**
     * Helper method to return all the related metrics of base publisher and additionalContext.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @return Return all related metrics from base publisher and additionalContext.
     */

  }, {
    key: "getAdditionalRelatedMetrics",
    value: function getAdditionalRelatedMetrics(additionalContext) {
      var newContext = additionalContext instanceof _KatalMetricsContext.default ? additionalContext.context : additionalContext;
      var baseRelatedMetrics = this.getBaseRelatedMetrics();
      return (0, _mergeLists.mergeLists)(baseRelatedMetrics, newContext.relatedMetrics);
    }
    /**
     * Helper method to return all the related metrics of base publisher.
     *
     * @return Return all related metrics from the base publisher.
     */

  }, {
    key: "getBaseRelatedMetrics",
    value: function getBaseRelatedMetrics() {
      return (0, _mergeLists.mergeLists)(this.context.context.relatedMetrics, this.context.context.relatedMetricsSingleAction);
    }
    /**
     * Publish the given metric object.
     *
     * This method is guaranteed never to throw an exception.  If the metric object or context are invalid,
     * or any other exception is thrown while publishing, the publisher's error handler is called.  If the
     * publisher's error handler is unset or fails, the default error handler is called (see defaultErrorHandler).
     *
     * @param katalMetricObject Metric object to publish
     */

  }, {
    key: "publish",
    value: function publish(katalMetricObject) {
      var _this2 = this;

      this.withErrorHandling(function () {
        if (!katalMetricObject) {
          throw new Error("Cannot publish undefined/null metric object");
        }

        if (_KatalMetricObject.default.Types.List === katalMetricObject.type) {
          katalMetricObject.metricList.forEach(function (metric) {
            _this2.publish(metric);
          });
        } else {
          var driverContext = _this2.context.driverContext();

          var contextError = driverContext.validationError();
          if (contextError) throw contextError;
          var objectError = katalMetricObject.validationError();
          if (objectError) throw objectError;
          (0, _metricsExtension.dispatchMetricEvent)(katalMetricObject, driverContext);

          _this2.driver.publish(katalMetricObject, _this2.combinedErrorHandler, driverContext);
        }
      });
    }
    /**
     * Create a new publisher which is identical to this publisher, but with the given context fields merged into
     * the new publisher's context.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildPublisher",
    value: function newChildPublisher(additionalContext) {
      return new KatalMetricsPublisher(this.driver, this.errorHandler, this.context.merge(additionalContext));
    }
    /**
     * Begin a new action, and return a new publisher for metrics related to that action.
     *
     * Beginning a new action involves the following steps:
     *   1. Generate a new actionId for the action, randomly in the browser
     *   2. If there are any related metrics in the context, publish them
     *   3. Create and return a new publisher with this object's context, merged with any additional context given,
     *      merged with the actionId generated above.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisher",
    value: function newChildActionPublisher(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var newContext = this.context.withoutRelatedMetricsSingleAction().merge({
        actionId: actionId
      }).merge(additionalContext);
      var newPublisher = new KatalMetricsPublisher(this.driver, this.errorHandler, newContext);
      var allRelatedMetrics = additionalContext && !(additionalContext instanceof _KatalMetricsContext.default.Builder) ? this.getAdditionalRelatedMetrics(additionalContext) : this.getBaseRelatedMetrics();

      if (allRelatedMetrics) {
        allRelatedMetrics.forEach(function (metric) {
          newPublisher.publish(metric);
        });
      }

      return newPublisher;
    }
    /**
     * Begin a new chained child action, and return a new publisher for metrics related to that action.
     *
     * A chained action is handled the same way as in newChildActionPublisher, but additionally,
     * the returned publisher has a relatedMetricNoInherit named "parentActionId", with the newly
     * generated actionId as its value.
     *
     * The effect of this is that any further chained child actions can be connected back to this
     * action through the parentActionId, and so on recursively.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChained",
    value: function newChildActionPublisherChained(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var parentActionId = (0, _embedRequestId.embedRequestId)(actionId, this.context.context.requestId);
      var relatedMetricsSingleAction = [new _KatalMetricString.default(PARENT_ACTION_ID_NAME, parentActionId)];
      var newContext = new _KatalMetricsContext.default({
        actionId: actionId,
        relatedMetricsSingleAction: relatedMetricsSingleAction
      }).merge(additionalContext);
      return this.newChildActionPublisher(newContext);
    }
    /**
     * Helper method to create a new chained child action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherChained.
     *
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChainedForMethod",
    value: function newChildActionPublisherChainedForMethod(methodName, additionalContext) {
      return this.newChildActionPublisherChained(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherForMethod.
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForMethod",
    value: function newChildActionPublisherForMethod(methodName, additionalContext) {
      return this.newChildActionPublisher(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action for application initialization.  It will always have a methodName
     * of "Initialization"; otherwise this method is identical to newChildActionPublisherForMethod.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForInitialization",
    value: function newChildActionPublisherForInitialization(additionalContext) {
      return this.newChildActionPublisherForMethod(INITIALIZATION_METHOD_NAME, additionalContext);
    }
    /**
     * Helper method to publish a string with the given name and value.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishString",
    value: function publishString(name, value) {
      this.publish(new KatalMetrics.Metric.String(name, value));
    }
    /**
     * Helper method to publish a string with the given name and value, truncated to the maximum size allowed by the
     * schema.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishStringTruncate",
    value: function publishStringTruncate(name, value) {
      var object = new KatalMetrics.Metric.String(name, value);
      object.truncate = true;
      this.publish(object);
    }
    /**
     * Helper method to publish a counter with the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounter",
    value: function publishCounter(name, value) {
      this.publish(new KatalMetrics.Metric.Counter(name, value));
    }
    /**
     * Helper method to publish a timer with the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimer",
    value: function publishTimer(name, value) {
      this.publish(new KatalMetrics.Metric.Timer(name, value));
    }
    /**
     * Helper method to publish a counter with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounterMonitor",
    value: function publishCounterMonitor(name, value) {
      this.publish(new KatalMetrics.Metric.Counter(name, value).withMonitor());
    }
    /**
     * Helper method to publish a timer with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimerMonitor",
    value: function publishTimerMonitor(name, value) {
      this.publish(new KatalMetrics.Metric.Timer(name, value).withMonitor());
    }
    /**
     * Private helper method to extract an actionId from a context if one is provided, and otherwise generate a new one.
     *
     * @returns Action ID string
     */

  }, {
    key: "_generateActionid",
    value: function _generateActionid(context) {
      if (context) {
        var fields = getContextFields(context);

        if (fields.actionId) {
          return fields.actionId;
        }
      }

      return (0, _v.default)();
    }
  }]);
  return KatalMetricsPublisher;
}();

exports.default = KatalMetricsPublisher;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ERROR_HANDLER = void 0;

var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  throw err;
};

exports.DEFAULT_ERROR_HANDLER = DEFAULT_ERROR_HANDLER;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Abstract base class for a Katal metrics driver.
 */
var KatalMetricsDriver =
/*#__PURE__*/
function () {
  function KatalMetricsDriver() {
    (0, _classCallCheck2.default)(this, KatalMetricsDriver);
  }

  (0, _createClass2.default)(KatalMetricsDriver, [{
    key: "publish",

    /**
     * Publish the given metric object with the given error handler and context.
     *
     * @param metricObject Metric object to publish.  Contains metricKey, isMonitor, type, and value.
     * @param errorHandler Callback function for handling any asynchronous errors that occur in the driver
     *     (the driver should just throw an exception for a synchronous error).
     * @param context Context for publishing this metric.  Contains all other fields to be published.
     */
    value: function publish(metricObject, errorHandler, context) {
      throw new Error('KatalMetricsDriver is an abstract class, please choose a driver and use that instead');
    }
  }]);
  return KatalMetricsDriver;
}();

exports.default = KatalMetricsDriver;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = firstMap;

/**
 * Returns the first non-undefined value that results from running each value
 * in the given array through the mapper function.
 * @param array An array of values.
 * @param mapper A mapper function that should return a value or undefined.
 * @returns The first non-undefined value from the mapper function.
 */
function firstMap(array, mapper) {
  var toReturn = undefined;
  array.some(function (val) {
    toReturn = mapper(val);
    return toReturn != null;
  });
  return toReturn;
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var objectValues = Object.values ? Object.values : function (object) {
  return Object.keys(object).map(function (key) {
    return object[key];
  });
};
var _default = objectValues;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleInt;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

/**
 * Number.isInteger is not in IE11, and letting Babel polyfill it added too much weight.
 * Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 */
var isInteger = function isInteger(val) {
  return isFinite(val) && Math.floor(val) === val;
};
/**
 * Check if the given value is valid to be published to KatalMetrics as an integer (Counter or Timer),
 * and return either undefined (no error), or an Error object describing the problem.
 *
 * @param val Value to check
 * @param nameForError Name to use when constructing the error message, if necessary
 * @returns Error, or undefined if no error
 */


function validateSimpleInt(val, nameForError) {
  if (typeof val !== 'number') {
    return new Error("Expected ".concat(nameForError, " to have type 'number', but it was type '").concat((0, _typeof2.default)(val), "'"));
  }

  if (val < 0) {
    return new Error("Expected ".concat(nameForError, " to be positive, but it was ").concat(val));
  } // This will also catch NaN and Infinity


  if (!isInteger(val)) {
    return new Error("Expected ".concat(nameForError, " to be an integer, but it was ").concat(val));
  } // Couldn't find anything wrong, implicitly return undefined

}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleString;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

var SIMPLE_STRING_PAT = /^[A-Za-z0-9.:@_/-]+$/;
var SIMPLE_STRING_MAX_LEN = 127;
/**
 * Check if the given value is valid to be published to KatalMetrics as a field value,
 * such as site, serviceName, methodName, or actionId (note this is not used to check values for string metrics).
 * It returns either undefined (no error), or an Error object describing the problem.
 *
 * To be published, it must be a non-empty string, less than 256 characters, containing only ASCII
 * letters, numbers, or these characters: .:@_/- (those are the PMET field value requirements).
 *
 * @param val String value to check
 * @param nameForError Name to use in the error message, if one is generated
 * @returns Error, or undefined if no error
 */

function validateSimpleString(val, nameForError) {
  if (typeof val !== "string") {
    return new Error("Expected ".concat(nameForError, " to be a string, but it was a ").concat((0, _typeof2.default)(val)));
  }

  if (val.length > SIMPLE_STRING_MAX_LEN) {
    return new Error("Expected ".concat(nameForError, " to be less than ").concat(SIMPLE_STRING_MAX_LEN, " characters, but it was ").concat(val.length, " characters"));
  }

  if (val.length < 1) {
    return new Error("Expected ".concat(nameForError, " to be non-blank"));
  }

  if (!SIMPLE_STRING_PAT.test(val)) {
    return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It can only contain letters, numbers, and these symbols: .:@_/-"));
  } // Couldn't find anything wrong, implicitly return undefined

}

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.embedRequestId = embedRequestId;

// until we can add a requestId field to the andes schema we will embed it in the actionId
function embedRequestId(actionId, requestId) {
  if (requestId) {
    return [requestId, actionId].join("::");
  }

  return actionId;
}

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLists = mergeLists;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/toConsumableArray.js"));

// Helper method to merge two lists which could be undefined
// Returns merged lists if either is defined, otherwise returns undefined
function mergeLists(list1, list2) {
  if (list1 || list2) {
    return [].concat((0, _toConsumableArray2.default)(list1 || []), (0, _toConsumableArray2.default)(list2 || []));
  } else {
    return undefined;
  }
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchMetricEvent = dispatchMetricEvent;

/**
 * Publish to external parties that are 
 * listening for katal.metrics.publish Custom Events
 */
function dispatchMetricEvent(metric, context) {
  if (typeof window === 'undefined') {
    return;
  }

  dispatchCustomEvent(metric, context); // for legacy purposes, also publish to __KATAL_METRICS_EXTENSION__

  publishToMetricsExtension(metric, context);
}

function dispatchCustomEvent(metric, context) {
  if (typeof CustomEvent !== "function") {
    return;
  }

  var event = new CustomEvent('katal.metrics.publish', {
    detail: {
      metric: metric,
      context: context.getFields()
    }
  });
  window.dispatchEvent(event);
}
/**
 * @Deprecated
 * Publish to https://code.amazon.com/packages/KatalMetricsExtension
 * The extension injects a global __KATAL_METRICS_EXTENSION__ object with a
 * `publish` method.
 */


function publishToMetricsExtension(metric, context) {
  var extension = window.__KATAL_METRICS_EXTENSION__;

  if (extension) {
    extension.publish(metric, context.getFields());
  }
}

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Publisher", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsPublisher.default;
  }
});
Object.defineProperty(exports, "Context", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsContext.default;
  }
});
Object.defineProperty(exports, "MetricsDriver", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsDriver.default;
  }
});
Object.defineProperty(exports, "ErrorHandler", {
  enumerable: true,
  get: function get() {
    return _ErrorHandler.ErrorHandler;
  }
});
exports.Metric = void 0;

var Metric = _interopRequireWildcard(__webpack_require__(/*! ./metricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/index.js"));

exports.Metric = Metric;

var _KatalMetricsPublisher = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsPublisher */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _KatalMetricsDriver = _interopRequireDefault(__webpack_require__(/*! ./driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _ErrorHandler = __webpack_require__(/*! ./driver/ErrorHandler */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js");

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

/**
 * Counter type.
 *
 * Can be used to count the number of times an event happened on a page, or as a simple 1/0 counter to track
 * success and failure.
 */
var KatalMetricCounter =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricCounter, _KatalMetricObject);

  /**
   * Create a new counter with the given name and value.
   *
   * @param name Counter name
   * @param value Counter value
   */
  function KatalMetricCounter(name) {
    var _this;

    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck2.default)(this, KatalMetricCounter);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricCounter).call(this, name));
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this counter
   *
   * @return Counter value
   */


  (0, _createClass2.default)(KatalMetricCounter, [{
    key: "add",

    /**
     * Add a number to this counter.
     *
     * Can also be negative to subtract.
     *
     * @param addValue Amount to add to this counter
     */
    value: function add(addValue) {
      this.value += addValue;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricCounter.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Counter metrics object '".concat(this.name, "'"));
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set a new value for this counter
     *
     * @param value New value for this counter
     */
    ,
    set: function set(value) {
      // Math.round will also coerce from a string if necessary, and return NaN if invalid
      this._value = Math.round(value);
    }
    /**
     * Gets the type for this counter.
     *
     * @return Always returns "Counter".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Counter;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }]);
  return KatalMetricCounter;
}(_KatalMetricObject2.default);

exports.default = KatalMetricCounter;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

/**
 * Standardized metric for instrumenting HTTP requests.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name you provide prefixed with "HTTPRequest.".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * It has additional properties which will be emitted if set; see url, statusCode, and statusText.
 *
 * For example, if you gave the name "Search", these metrics will be created:
 *   HTTPRequest.Search.Latency - Latency for this request
 *   HTTPRequest.Search.Failure - Failure for this request (1 for failure, 0 for success)
 */
var KatalMetricHttpRequest =
/*#__PURE__*/
function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricHttpRequest, _KatalMetricTimedAtte);

  /** The prefix for this metric. */

  /** The suffix for URL metrics of this class. */

  /** The suffix for HTTP response code metrics of this class. */

  /** The suffix for HTTP response text metrics of this class. */

  /**
   * Create a new HTTP Request timed attempt metric incorporating the given name.
   *
   * The name you give will be used to create a KatalMetricTimedAttempt with the provided name prefixed with "HTTPRequest.".
   *
   * @param name Name of this metric; resulting metrics will prefix this name with "HTTPRequest."
   */
  function KatalMetricHttpRequest(name) {
    (0, _classCallCheck2.default)(this, KatalMetricHttpRequest);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricHttpRequest).call(this, "".concat(KatalMetricHttpRequest.HTTP_REQUEST_PREFIX, ".").concat(name)));
  }
  /**
   * Set the url for this metric.
   *
   * A string metric will be added to the list of objects that will be published for this metric.  Its name will
   * be this metrics name suffixed with '.URL', and its value will be the URL value given here.
   *
   * @param value URL for this metric
   */


  (0, _createClass2.default)(KatalMetricHttpRequest, [{
    key: "url",
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX, _KatalMetricString.default, value);
    }
    /**
     * Get the URL for this metric, if defined.
     *
     * @return The URL for this metric, or undefined
     */
    ,
    get: function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Get the URL metric object associated with this metric, if defined.
     *
     * @return Associated URL metric object, or undefined
     */

  }, {
    key: "urlMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Set the HTTP response status code for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusCode', and its value will be the status code value given here.
     *
     * @param value HTTP response status code for this metric
     */

  }, {
    key: "statusCode",
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX, _KatalMetricString.default, value);
    }
    /**
     * Get the HTTP response status code for this metric, if defined.
     *
     * @return Associated HTTP response status code metric object, or undefined
     */
    ,
    get: function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Get the HTTP response status code metric object associated with this metric, if defined.
     *
     * @return HTTP response status code metric object, or undefined
     */

  }, {
    key: "statusCodeMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Set the HTTP response status text for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusText', and its value will be the status text value given here.
     *
     * @param statusText HTTP response status text for this metric, or undefined to remove
     */

  }, {
    key: "statusText",
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX, _KatalMetricString.default, value);
    }
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */
    ,
    get: function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */

  }, {
    key: "statusTextMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
  }]);
  return KatalMetricHttpRequest;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricHttpRequest;
(0, _defineProperty2.default)(KatalMetricHttpRequest, "HTTP_REQUEST_PREFIX", 'HTTPRequest');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "URL_SUFFIX", 'URL');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_CODE_SUFFIX", 'StatusCode');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_TEXT_SUFFIX", 'StatusText');

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

/**
 * Standardized metric for instrumenting application initialization.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name "Initialization".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * By default, these metrics will be created:
 *   Initialization.Latency - Latency for application initialization
 *   Initialization.Failure - Failure for this application initialization (1 for failure, 0 for success)
 */
var KatalMetricInitialization =
/*#__PURE__*/
function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricInitialization, _KatalMetricTimedAtte);

  /** The name for this metric. */

  /**
   * Create a new timed attempt metric named "Initialization", for recording latency and failure information about
   * your application's initialization.
   */
  function KatalMetricInitialization() {
    (0, _classCallCheck2.default)(this, KatalMetricInitialization);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricInitialization).call(this, KatalMetricInitialization.INITIALIZE_METRIC_NAME));
  }

  return KatalMetricInitialization;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricInitialization;
(0, _defineProperty2.default)(KatalMetricInitialization, "INITIALIZE_METRIC_NAME", 'Initialization');

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObjectList */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js"));

var _ObjectValuesPonyfill = _interopRequireDefault(__webpack_require__(/*! ../helper/ObjectValuesPonyfill */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js"));

/**
 * Metric object list that tracks metrics by name, and generates metrics prefixed with the name of this object.
 */
var KatalMetricNamedObjectList =
/*#__PURE__*/
function (_KatalMetricObjectLis) {
  (0, _inherits2.default)(KatalMetricNamedObjectList, _KatalMetricObjectLis);

  /**
   * Create a new named object list.
   *
   * The name given here will be used to prefix all metrics.
   *
   * @param name Name of this metric
   */
  function KatalMetricNamedObjectList(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricNamedObjectList);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricNamedObjectList).call(this, name));
    _this.namedMetrics = {};
    return _this;
  }

  (0, _createClass2.default)(KatalMetricNamedObjectList, [{
    key: "setNamedMetric",

    /**
     * Replace the metric with the given name with a new metric generated by the given function.
     *
     * If the newly created metric supports monitoring, its isMonitor flag will be set to the value of the
     * isMonitor flag for this containing object.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     */
    value: function setNamedMetric(subName, metricCreator) {
      var fullName = this.getNameForSubMetric(subName);
      var metric = metricCreator(fullName);

      if (metric.canMonitor) {
        metric.isMonitor = this.isMonitor;
      }

      this.namedMetrics[subName] = metric;
    }
    /**
     * If the given value is undefined or null, delete the metric with the give name; otherwise if the given named
     * metric already exists update its value; otherwise create a new metric of the given type and set its value.
     *
     * This specialized helper method is designed to deal with the common case of a value setter in a more complex
     * metric.  Outside of subclasses, other methods will probably prove more useful.
     *
     * If the value is null the metric will also be deleted.
     *
     * @param subName Name of metric to create or delete
     * @param newValueClass Class of new metric to create
     * @param newValue New value for this metric (or undefined to delete the metric)
     */

  }, {
    key: "setOrDeleteNamedMetricValue",
    value: function setOrDeleteNamedMetricValue(subName, newValueClass, newValue) {
      if (newValue == undefined) {
        this.deleteNamedMetric(subName);
      } else {
        var metric = this.getOrCreateNamedMetric(subName, function (name) {
          return new newValueClass(name, newValue);
        });
        metric.value = newValue;
      }
    }
    /**
     * Get the sub-metric with the given name if it exists, otherwise use the given function to create a new metric and
     * store and return that.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     * @return Metric object which was retrieved or created
     */

  }, {
    key: "getOrCreateNamedMetric",
    value: function getOrCreateNamedMetric(subName, metricCreator) {
      if (!this.namedMetrics[subName]) {
        this.setNamedMetric(subName, metricCreator);
      }

      return this.namedMetrics[subName];
    }
    /**
     * Return the given named sub-metric, if it exists.
     *
     * @param {string} subName Name of this sub-metric
     * @return {KatalMetricObject | undefined} Metric object with this name if it exists, otherwise undefined
     */

  }, {
    key: "getNamedMetric",
    value: function getNamedMetric(subName) {
      return this.namedMetrics[subName];
    }
    /**
     * Delete the given named sub-metric.
     *
     * @param subName Name of this sub-metric
     */

  }, {
    key: "deleteNamedMetric",
    value: function deleteNamedMetric(subName) {
      delete this.namedMetrics[subName];
    }
    /**
     * Get the value for the given metric, or undefined if the metric does not exist.
     *
     * @param subName Name of this sub-metric
     * @return Value for the given metric, or undefined if the metric does not exist
     */

  }, {
    key: "getNamedMetricValue",
    value: function getNamedMetricValue(subName) {
      var metric = this.getNamedMetric(subName);
      if (!metric) return undefined;
      return metric.value;
    }
    /**
     * Generate a name for the given sub-metric.
     *
     * @param subName Name of this sub-metric
     * @return Full name for this sub-metric
     */

  }, {
    key: "getNameForSubMetric",
    value: function getNameForSubMetric(subName) {
      return "".concat(this.name, ".").concat(subName);
    }
  }, {
    key: "metricList",
    get: function get() {
      return (0, _ObjectValuesPonyfill.default)(this.namedMetrics);
    }
  }]);
  return KatalMetricNamedObjectList;
}(_KatalMetricObjectList.default);

exports.default = KatalMetricNamedObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricType */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

/**
 * Abstract base class for a single metric in Katal.
 *
 * A single metric contains the name (metricKey), value, type, and the isMonitor flag; everything else is in the
 * KatalMetricsContext it is published to.
 */
var KatalMetricObject =
/*#__PURE__*/
function () {
  /**
   * Metric types.
   */

  /**
   * Create a new KatalMetricObject with the given name.
   *
   * @param name Name for this metric; published as metricKey field
   */
  function KatalMetricObject(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObject);
    this._name = name;
    this._isMonitor = false;
  }
  /**
   * Get the name for this metric.
   *
   * Note that the name is immutable, and this cannot be set.
   *
   * @returns Name for this metric
   */


  (0, _createClass2.default)(KatalMetricObject, [{
    key: "withMonitor",

    /**
     * Set the isMonitor flag for this metric, and returns this object for continued use.
     *
     * This flag determines if the metric can be used for dashboards and alarms (i.e. if it will be published to PMET)
     * @param isMonitor New value for the isMonitor flag; defaults to true
     * @returns This object
     */
    value: function withMonitor() {
      var isMonitor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.isMonitor = isMonitor;
      return this;
    }
    /**
     * Set the isMonitor flag for this metric.
     *
     * The value is forced to a boolean based on its truthiness.
     *
     * @param isMonitor New value for the isMonitor flag
     */

  }, {
    key: "validationError",

    /**
     * Check for a validation error on this object.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns {Error | undefined} Error found with this object, or undefined if no error is found
     */
    value: function validationError() {
      if (this.isMonitor !== undefined && typeof this.isMonitor !== 'boolean') {
        return new Error("Field isMonitor should be a boolean, but it was a ".concat((0, _typeof2.default)(this.isMonitor)));
      }

      return (0, _ValidateSimpleString.default)(this.name, 'field name');
    }
  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
    /**
     * Alias for name.
     *
     * @returns Name for this metric
     */

  }, {
    key: "metricKey",
    get: function get() {
      return this._name;
    }
  }, {
    key: "isMonitor",
    set: function set(isMonitor) {
      this._isMonitor = !!isMonitor;
    }
    /**
     * Get the isMonitor flag for this metric.
     *
     * @returns isMonitor flag for this metric.
     */
    ,
    get: function get() {
      return this._isMonitor;
    }
    /**
     * Check if this metric can be meaningfully monitored.
     *
     * Subclasses must override this.
     *
     * @return Whether this metric can be meaningfully monitored
     */

  }, {
    key: "canMonitor",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement canMonitor');
    }
    /**
     * Get the type of this metric.
     *
     * @return Type of this metric (one of: String, Counter, Timer, List)
     */

  }, {
    key: "type",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement type getter');
    }
  }]);
  return KatalMetricObject;
}();

exports.default = KatalMetricObject;
(0, _defineProperty2.default)(KatalMetricObject, "Types", _KatalMetricType.default);

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ../helper/FirstMap */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

/**
 * Abstract metric that contains a list of other metrics; when it is published, the list of metrics is retrieved, and all
 * are published.
 */
var KatalMetricObjectList =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricObjectList, _KatalMetricObject);

  /**
   * Create a new KatalMetricObjectList.
   *
   * @param name Name for this metric.  Not really used, but present for consistency with other metrics.
   */
  function KatalMetricObjectList(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObjectList);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricObjectList).call(this, name));
  }
  /**
   * Get the list of for this object
   *
   * @returns Array of metrics for this object
   */


  (0, _createClass2.default)(KatalMetricObjectList, [{
    key: "validationError",

    /**
     * If any of the contained metrics are invalid, return the first validation error encountered; otherwise return
     * undefined.
     *
     * Note that this isn't called by the publisher; it validates each sub-metric on its own.
     *
     * @returns Error found with submetric, if any; else undefined
     */
    value: function validationError() {
      // Doesn't make sense to check superclass error here, since it is the contained metrics that matter.
      return (0, _FirstMap.default)(this.metricList, function (metric) {
        return metric.validationError();
      });
    }
  }, {
    key: "metricList",
    get: function get() {
      throw new Error('Subclass of KatalMetricObjectList must implement metricList getter');
    }
  }, {
    key: "isMonitor",
    set: function set(isMonitor) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", isMonitor, this, true);
      this.metricList.forEach(function (metric) {
        if (metric.canMonitor) {
          metric.isMonitor = isMonitor;
        }
      });
    } // This just delegates to the superclass, but if we override the setter without overriding the getter
    // getting the property will always return undefined.
    ,
    get: function get() {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", this);
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.List;
    }
  }]);
  return KatalMetricObjectList;
}(_KatalMetricObject2.default);

exports.default = KatalMetricObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

/**
 * String type.
 *
 * Can be used to store arbitrary strings of data.
 */
var KatalMetricString =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricString, _KatalMetricObject);

  /**
   * Create a string with the given name and value.
   *
   * @param name String name
   * @param value String value
   */
  function KatalMetricString(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricString);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricString).call(this, name));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "truncate", false);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this string metric.
   *
   * @return Value for this metric
   */


  (0, _createClass2.default)(KatalMetricString, [{
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricString.prototype), "validationError", this).call(this);
      if (superError) return superError;

      if (typeof this.value !== 'string') {
        return new Error("Expected field value in String metrics object '".concat(this.name, "' to be type string, but it was ").concat((0, _typeof2.default)(this.value)));
      }

      if (this.value.length > KatalMetricString.MAX_SIZE) {
        if (this.truncate) {
          this.value = this.value.substring(0, KatalMetricString.MAX_SIZE);
        } else {
          return new Error("Expected field value in String metrics object '".concat(this.name, "' to be ").concat(KatalMetricString.MAX_SIZE, " characters or less, but it was ").concat(this.value.length, " characters."));
        }
      } // Didn't find anything wrong, implicitly return undefined

    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this string metric.
     *
     * The new value should be a string, but number and boolean types will be automatically converted to strings.
     * For other types, including undefined and null, the value will be accepted, but will fail validation when publishing.
     *
     * @param value New value for this metric
     */
    ,
    set: function set(value) {
      if (typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
      }

      this._value = value;
    }
    /**
     * Truncation flag for this string metric.
     *
     * If set, the value here will be automatically truncated to the maximum size allowed by the current schema.
     * Otherwise, sending a value larger than allowed will result in a failure.
     *
     * @param value True to automatically truncate metrics, otherwise false
     */

  }, {
    key: "type",

    /**
     * Gets the type for this metric.
     *
     * @return Always returns "String".
     */
    get: function get() {
      return _KatalMetricObject2.default.Types.String;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return false;
    }
  }]);
  return KatalMetricString;
}(_KatalMetricObject2.default);

exports.default = KatalMetricString;
(0, _defineProperty2.default)(KatalMetricString, "MAX_SIZE", 256);

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricNamedObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricNamedObjectList */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

/**
 * Metric that pairs a timer and a failure counter to record the time and status of an attempt to do something.
 */
var KatalMetricTimedAttempt =
/*#__PURE__*/
function (_KatalMetricNamedObje) {
  (0, _inherits2.default)(KatalMetricTimedAttempt, _KatalMetricNamedObje);

  /** The sub-metric name for latency. */

  /** The sub-metric name for failure count. */

  /**
   * Create a new timed attempt with the given name
   *
   * This will create two inner metrics, a KatalMetricCounter that has the given name with ".Failure" appended,
   * and a KatalMetricTimerStopwatch that has the given name with ".Latency" appended.
   *
   * @param name Name of this attempt
   */
  function KatalMetricTimedAttempt(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimedAttempt);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricTimedAttempt).call(this, name));

    _this.setNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX, function (name) {
      return new _KatalMetricTimerStopwatch.default(name);
    });

    _this.setNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX, function (name) {
      return new _KatalMetricCounter.default(name, 1);
    });

    return _this;
  }
  /**
   * Set the failure counter metric based on the given failure status.
   *
   * If failure is true the counter will have a value of 1; if it is false the counter will have a value of 0.
   *
   * @param failure Whether this is a failure or not; default true
   */


  (0, _createClass2.default)(KatalMetricTimedAttempt, [{
    key: "setFailure",
    value: function setFailure() {
      var failure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var failureCount = failure ? 1 : 0;
      var metric = this.failureMetric;
      metric.value = failureCount;
    }
    /**
     * Set the failure status to false.
     */

  }, {
    key: "setSuccess",
    value: function setSuccess() {
      this.setFailure(false);
    }
    /**
     * Set the latency metric to the given value, in milliseconds.
     *
     * Note you don't normally have to set this, the underlying metric is a KatalMetricTimerStopwatch that will start
     * and stop automatically.
     *
     * @param latencyMs Latency in milliseconds
     */

  }, {
    key: "setLatency",
    value: function setLatency(latencyMs) {
      var metric = this.latencyMetric;
      metric.value = latencyMs;
    }
    /**
     * Get the timer stopwatch metric for this attempt.
     *
     * @return Timer stopwatch metric for this attempt
     */

  }, {
    key: "latencyMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX);
    }
    /**
     * Get the failure counter metric for this attempt.
     *
     * @return Failure counter metric for this event
     */

  }, {
    key: "failureMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX);
    }
  }]);
  return KatalMetricTimedAttempt;
}(_KatalMetricNamedObjectList.default);

exports.default = KatalMetricTimedAttempt;
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "LATENCY_SUFFIX", 'Latency');
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "FAILURE_SUFFIX", 'Failure');

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

/**
 * Timer type.
 *
 * Can be used to record a time.  This class requires explicit value; see KatalMetricTimerStopwatch for automatic
 * timing.
 */
var KatalMetricTimer =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricTimer, _KatalMetricObject);

  /**
   * Create a new timer metric.
   *
   * @param name Name for the metric
   * @param value Timer value in milliseconds
   */
  function KatalMetricTimer(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricTimer).call(this, name));
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this timer
   *
   * @return Timer value in milliseconds
   */


  (0, _createClass2.default)(KatalMetricTimer, [{
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimer.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Timer metrics object '".concat(this.name, "'"));
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this timer
     *
     * @param value New timer value in milliseconds
     */
    ,
    set: function set(value) {
      if (value == undefined) {
        this._value = value;
        return;
      } // Math.round will also coerce from a string if necessary, and return NaN if invalid


      this._value = Math.round(value);
    }
    /**
     * Get the type for this timer.
     *
     * @return Always returns "Timer".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Timer;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }]);
  return KatalMetricTimer;
}(_KatalMetricObject2.default);

exports.default = KatalMetricTimer;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricTimer2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

/**
 * Subclass of KatalMetricTimer that can be started and stopped, and will record the elapsed time between starting and
 * stopping.  By default it will start when the object is created, and stopped when the value is retrieved with
 * the getter "value".
 */
var KatalMetricTimerStopwatch =
/*#__PURE__*/
function (_KatalMetricTimer) {
  (0, _inherits2.default)(KatalMetricTimerStopwatch, _KatalMetricTimer);

  /**
   * Create a new timer with the given name and starting time.  If no starting time is given, the current time is used.
   *
   * @param name Name for this timer
   * @param startTime Millisecond epoch time for the start time; defaults to now
   */
  function KatalMetricTimerStopwatch(name, startTime) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimerStopwatch);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch).call(this, name, undefined));

    _this.start(startTime);

    _this._value = undefined;
    return _this;
  }
  /**
   * Re-start timer with the given start time, or the current time if none is given.
   *
   * @param startTime When the timer was started, in epoch milliseconds; defaults to now
   */


  (0, _createClass2.default)(KatalMetricTimerStopwatch, [{
    key: "start",
    value: function start(startTime) {
      this._startTime = startTime || this.now();
    }
    /**
     * Stop the timer and record the elapsed time.
     *
     * @param stopTime When the timer was stopped, in epoch milliseconds; defaults to now
     */

  }, {
    key: "stop",
    value: function stop(stopTime) {
      return this._stopTime = stopTime || this.now();
    }
    /**
     * Check if the timer has been stopped.
     *
     * @returns Whether the timer has been stopped yet
     */

  }, {
    key: "now",
    value: function now() {
      return performance.now();
    }
  }, {
    key: "isStopped",
    get: function get() {
      return this._stopTime !== undefined;
    }
    /**
     * Get the elapsed time between when the timer was started and stopped; if the timer has not yet been stopped,
     * stop it first.
     *
     * @returns Elapsed time between when timer was started and stopped
     */

  }, {
    key: "value",
    get: function get() {
      if ((0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this) === undefined) {
        if (!this.isStopped) {
          this.stop();
        } // Rely on super.value setter to round


        (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this.stopTime - this.startTime, this, true);
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this);
    }
    /**
     * Get when this timer was started.
     *
     * @return Start time, in epoch milliseconds
     */
    ,

    /**
     * Set the value for this metric.  Note this will override the stopwatch behavior and just use the given value.
     *
     * @param value Value for this metric
     */
    set: function set(value) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", value, this, true);
    }
  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    }
    /**
     * Get when this timer was stopped (or undefined if it is still running)
     *
     * @return Stop time, in epoch millseconds, or undefined if the stopwatch is still running
     */

  }, {
    key: "stopTime",
    get: function get() {
      return this._stopTime;
    }
  }]);
  return KatalMetricTimerStopwatch;
}(_KatalMetricTimer2.default);

exports.default = KatalMetricTimerStopwatch;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Metric types.
 */
var KatalMetricType;

(function (KatalMetricType) {
  KatalMetricType["String"] = "String";
  KatalMetricType["Counter"] = "Counter";
  KatalMetricType["Timer"] = "Timer";
  KatalMetricType["List"] = "List";
})(KatalMetricType || (KatalMetricType = {}));

;
var _default = KatalMetricType;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Object", {
  enumerable: true,
  get: function get() {
    return _KatalMetricObject.default;
  }
});
Object.defineProperty(exports, "String", {
  enumerable: true,
  get: function get() {
    return _KatalMetricString.default;
  }
});
Object.defineProperty(exports, "Counter", {
  enumerable: true,
  get: function get() {
    return _KatalMetricCounter.default;
  }
});
Object.defineProperty(exports, "Timer", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimer.default;
  }
});
Object.defineProperty(exports, "TimerStopwatch", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimerStopwatch.default;
  }
});
Object.defineProperty(exports, "TimedAttempt", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimedAttempt.default;
  }
});
Object.defineProperty(exports, "Initialization", {
  enumerable: true,
  get: function get() {
    return _KatalMetricInitialization.default;
  }
});
Object.defineProperty(exports, "HttpRequest", {
  enumerable: true,
  get: function get() {
    return _KatalMetricHttpRequest.default;
  }
});

var _KatalMetricObject = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

var _KatalMetricTimer = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricInitialization = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricInitialization */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js"));

var _KatalMetricHttpRequest = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricHttpRequest */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js"));

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-sushi-client/dist/SushiClient.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-sushi-client/dist/SushiClient.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This class encapsulates two IIFEs that the Sushi library contains. A fake CSM and Window object are created and provided
 * to the functions so that they actually execute in a controlled environment away from any CSM code that might be executing
 * at the platform level within the page.
 *
 * The basic run order is the following:
 * 1. Build the mock CSM object, then build a mock Window object that references the CSM object as ue_csm
 * 2. Run the transportation-clients.js Script from SushiJavascriptClient providing the mocks. It will modify globals on the mock objects.
 * 3. Run the sushi-client.js script from SushiJavaScriptClient providing the mocks. It will create an instance of the sushi client and inject it into the CSM globals in the mocks.
 * 4. whenever event() is called, refer to the encapsulated csm object to add the event to the queue.
 */
var SushiClient =
/*#__PURE__*/
function () {
  (0, _createClass2.default)(SushiClient, null, [{
    key: "createSushiUrl",
    value: function createSushiUrl(region, sourceGroup) {
      if (!sourceGroup) {
        throw new Error("Sushi Driver was not provided with a source group.");
      }

      var domain;

      switch (region) {
        case SushiClient.REGIONS.NA:
          domain = "unagi-na";
          break;

        case SushiClient.REGIONS.EU:
          domain = "unagi-eu";
          break;

        case SushiClient.REGIONS.FE:
          domain = "unagi-fe";
          break;

        case SushiClient.REGIONS.CN:
          domain = "unagi-cn";
          break;

        default:
          throw new Error("Unrecognized region '".concat(region, "' provided to SushiClient."));
      }

      return "https://".concat(domain, ".amazon.com/1/events/").concat(sourceGroup);
    }
  }, {
    key: "createCsmUserContext",
    value: function createCsmUserContext(sushiUrl) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _objectSpread({
        hiPriFlushInterval: 1000,
        lowPriFlushInterval: 10000,
        requestId: "1",
        errorChannel: "jserr",
        sessionStorageWrapper: undefined,
        errorHandlerFunction: console.log,
        sushiUrl: sushiUrl
      }, options);
    }
    /**
     * Create a Sushi Client for a region and source group
     *
     * @param region Region in SushiClient.REGIONS
     * @param sourceGroup Sushi Eel source group
     * @param errorHandler Error handler function
     * @param options Additional CSM context overrides
     * @param clientOverride An optional transportation client for overriding the default clients (navigator.sendBeacon and XDomainRequest or XMLHttpRequest)
     */

  }, {
    key: "REGIONS",
    get: function get() {
      return {
        NA: "NA",
        EU: "EU",
        FE: "FE",
        CN: "CN"
      };
    }
  }]);

  function SushiClient() {
    var region = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SushiClient.REGIONS.NA;
    var sourceGroup = arguments.length > 1 ? arguments[1] : undefined;
    var errorHandler = arguments.length > 2 ? arguments[2] : undefined;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var clientOverride = arguments.length > 4 ? arguments[4] : undefined;
    (0, _classCallCheck2.default)(this, SushiClient);
    var sushiUrl = SushiClient.createSushiUrl(region, sourceGroup);
    var csmUserContext = SushiClient.createCsmUserContext(sushiUrl, options);
    this.ue_csm = this.setupMockCSMObject(csmUserContext);
    this.encapsulatedWindow = this.setupMockWindow(this.ue_csm);
    this.transportationClientCode(this.ue_csm, window);

    if (clientOverride) {
      this.ue_csm.ue._sBcn = {
        isSupported: true,
        send: function send(endpoint, payload) {
          clientOverride(endpoint, payload);
          return true;
        }
      };
    }

    this.clientCode(this.ue_csm, this.encapsulatedWindow);
    this.errorHandler = errorHandler;
  }

  (0, _createClass2.default)(SushiClient, [{
    key: "event",
    value: function event(data, producerId, schemaId, options) {
      var debug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      if (debug) {
        console.log("SushiClient wrapper publishing the following:", {
          data: data,
          producerId: producerId,
          schemaId: schemaId,
          options: options
        });
      }

      return this.ue_csm.ue.event(data, producerId, schemaId, options);
    }
    /**
     * If you plan to emit 1000 or more events per instantiated client,
     * call reset after calling event to allow the CSM client to continue sending events.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.ue_csm.ue.event.reset();
    }
    /**
     * Register a callback that will be called just before each time metrics are
     * flushed to the network.
     * @param callback A function that sushi will call before flushes.
     */

  }, {
    key: "onSushiFlush",
    value: function onSushiFlush(callback) {
      this.ue_csm.ue.onSushiFlush(callback);
    }
    /**
     * Register a callback that will be called just before the page unloads.
     * This can be used to send any final metrics to sushi, such as page visit
     * duration or batched counters.
     * @param callback A function that sushi will call before unload.
     */

  }, {
    key: "onSushiUnload",
    value: function onSushiUnload(callback) {
      this.ue_csm.ue.onSushiUnload(callback);
    }
  }, {
    key: "setupMockCSMObject",
    value: function setupMockCSMObject(csmUserContext) {
      var _this = this;

      var execStub = function execStub(callback, attribution) {
        return callback;
      };

      var eventStub = function eventStub(log, producer, eventType) {
        console.warn("SushiClient CSM stub called in unsupported manner: event()");
      };

      var errorHandler = function errorHandler(logEvent, channel) {
        if (_this.errorHandler) {
          _this.errorHandler(logEvent);
        } else {
          console.log("An error has occurred in SushiClient channel " + channel, logEvent);
        }
      };

      var attachHandler = function attachHandler(evt, handler, container) {
        //TODO might be able to just use window.ue.attach?
        container = container || window; //ok to use real window global here.

        if (window.EventTarget && window.EventTarget.prototype && window.EventTarget.prototype.addEventListener) {
          window.EventTarget.prototype.addEventListener.call(container, evt, handler, !!window.ue_clf);
        } else if (container.addEventListener) {
          container.addEventListener(evt, handler, !!window.ue_clf);
        } else if (container.attachEvent) {
          container.attachEvent("on" + evt, handler);
        }
      };

      return {
        ue_hpsi: csmUserContext.hiPriFlushInterval,
        ue_lpsi: csmUserContext.lowPriFlushInterval,
        ue: {
          ssw: csmUserContext.sessionStorageWrapper,
          log: errorHandler,
          exec: execStub,
          event: eventStub,
          attach: attachHandler
        },
        ueLogError: csmUserContext.errorHandlerFunction,
        ue_surl: csmUserContext.sushiUrl,
        ue_id: csmUserContext.requestId,
        ue_err_chan: csmUserContext.errorChannel
      };
    }
  }, {
    key: "setupMockWindow",
    value: function setupMockWindow(ue_csm) {
      //apparently cannot ref the setTimeout function directly in some browsers so we have to wrap it.
      var timeoutWrapper = function timeoutWrapper(fn, timeout) {
        return window.setTimeout(fn, timeout);
      };

      return {
        ue_csm: ue_csm,
        ueLogError: ue_csm.ueLogError,
        ue: ue_csm.ue,
        setTimeout: timeoutWrapper
      };
    }
    /**
     * Code within function pulled directly from
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/sushi-client.js
     */

  }, {
    key: "clientCode",
    value: function clientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, k) {
        function A() {
          for (var a = 0; a < arguments.length; a++) {
            var c = arguments[a];

            try {
              var h;

              if (c.isSupported) {
                var b = t.buildPayload(l, e);
                h = c.send(J, b);
              } else throw dummyException;

              return h;
            } catch (d) {}
          }

          B({
            m: "All supported clients failed",
            attribution: "CSMSushiClient_TRANSPORTATION_FAIL",
            f: "sushi-client.js",
            logLevel: "ERROR"
          }, k.ue_err_chan || "jserr");
        }

        function m() {
          if (e.length) {
            for (var a = 0; a < n.length; a++) {
              n[a]();
            }

            A(d._sBcn || {}, d._ajx || {});
            e = [];
            f = {};
            l = {};
            u = v = q = w = 0;
          }
        }

        function K() {
          var a = new Date(),
              c = function c(a) {
            return 10 > a ? "0" + a : a;
          };

          return Date.prototype.toISOString ? a.toISOString() : a.getUTCFullYear() + "-" + c(a.getUTCMonth() + 1) + "-" + c(a.getUTCDate()) + "T" + c(a.getUTCHours()) + ":" + c(a.getUTCMinutes()) + ":" + c(a.getUTCSeconds()) + "." + String((a.getUTCMilliseconds() / 1E3).toFixed(3)).slice(2, 5) + "Z";
        }

        function x(a) {
          try {
            return JSON.stringify(a);
          } catch (c) {}

          return null;
        }

        function C(a, c, h, g) {
          var p = !1;
          g = g || {};
          r++;
          r == D && B({
            m: "Max number of Sushi Logs exceeded",
            f: "sushi-client.js",
            logLevel: "ERROR",
            attribution: "CSMSushiClient_MAX_CALLS"
          }, k.ue_err_chan || "jserr");
          var f;
          if (f = !(r >= D)) (f = a && -1 < a.constructor.toString().indexOf("Object") && c && -1 < c.constructor.toString().indexOf("String") && h && -1 < h.constructor.toString().indexOf("String")) || L++;
          f && (d.count && d.count("Event:" + h, 1), a.producerId = a.producerId || c, a.schemaId = a.schemaId || h, a.timestamp = K(), c = Date.now ? Date.now() : +new Date(), h = Math.random().toString().substring(2, 12), a.messageId = b.ue_id + "-" + c + "-" + h, g && !g.ssd && (a.sessionId = a.sessionId || b.ue_sid, a.requestId = a.requestId || b.ue_id, a.obfuscatedMarketplaceId = a.obfuscatedMarketplaceId || b.ue_mid), (c = x(a)) ? (c = c.length, (e.length == M || q + c > N) && m(), q += c, a = {
            data: t.compressEvent(a)
          }, e.push(a), (g || {}).n ? 0 === E ? m() : u || (u = k.setTimeout(m, E)) : v || (v = k.setTimeout(m, O)), p = !0) : p = !1);
          !p && b.ue_int && console.error("Invalid JS Nexus API call");
          return p;
        }

        function F() {
          if (!G) {
            for (var a = 0; a < y.length; a++) {
              y[a]();
            }

            for (a = 0; a < n.length; a++) {
              n[a]();
            }

            e.length && (b.ue_sbuimp && b.ue && b.ue.ssw && (a = x({
              dct: l,
              evt: e
            }), b.ue.ssw("eeldata", a), b.ue.ssw("eelsts", "unk")), A(d._sBcn || {}));
            G = !0;
          }
        }

        function H(a) {
          y.push(a);
        }

        function I(a) {
          n.push(a);
        }

        var D = 1E3,
            M = 499,
            N = 524288,
            s = function s() {},
            d = b.ue || {},
            B = d.log || s,
            P = b.uex || s;

        (b.uet || s)("bb", "ue_sushi_v1", {
          wb: 1
        });

        var J = b.ue_surl || "https://unagi-na.amazon.com/1/events/com.amazon.csm.nexusclient.gamma",
            Q = ["messageId", "timestamp"],
            z = "#",
            e = [],
            f = {},
            l = {},
            q = 0,
            w = 0,
            L = 0,
            r = 0,
            y = [],
            n = [],
            G = !1,
            u,
            v,
            E = void 0 === b.ue_hpsi ? 1E3 : b.ue_hpsi,
            O = void 0 === b.ue_lpsi ? 1E4 : b.ue_lpsi,
            t = function () {
          function a(a) {
            f[a] = z + w++;
            l[f[a]] = a;
            return f[a];
          }

          function c(b) {
            if (!(b instanceof Function)) {
              if (b instanceof Array) {
                for (var g = [], d = b.length, e = 0; e < d; e++) {
                  g[e] = c(b[e]);
                }

                return g;
              }

              if (b instanceof Object) {
                g = {};

                for (d in b) {
                  b.hasOwnProperty(d) && (g[f[d] ? f[d] : a(d)] = -1 === Q.indexOf(d) ? c(b[d]) : b[d]);
                }

                return g;
              }

              return "string" === typeof b && (b.length > (z + w).length || b.charAt(0) === z) ? f[b] ? f[b] : a(b) : b;
            }
          }

          return {
            compressEvent: c,
            buildPayload: function buildPayload() {
              return x({
                cs: {
                  dct: l
                },
                events: e
              });
            }
          };
        }();

        (function () {
          if (d.event && d.event.isStub) {
            if (b.ue_sbuimp && b.ue && b.ue.ssw) {
              var a = b.ue.ssw("eelsts").val;

              if (a && "unk" === a && (a = b.ue.ssw("eeldata").val)) {
                var c;

                a: {
                  try {
                    c = JSON.parse(a);
                    break a;
                  } catch (f) {}

                  c = null;
                }

                c && c.evt instanceof Array && c.dct instanceof Object && (e = c.evt, l = c.dct, e && l && (m(), b.ue.ssw("eeldata", "{}"), b.ue.ssw("eelsts", "scs")));
              }
            }

            d.event.replay(function (a) {
              a[3] = a[3] || {};
              a[3].n = 1;
              C.apply(this, a);
            });
            d.onSushiUnload.replay(function (a) {
              H(a[0]);
            });
            d.onSushiFlush.replay(function (a) {
              I(a[0]);
            });
          }
        })();

        d.attach("beforeunload", F);
        d.attach("pagehide", F);
        d._cmps = t;
        d.event = C;

        d.event.reset = function () {
          r = 0;
        };

        d.onSushiUnload = H;
        d.onSushiFlush = I;

        try {
          k.P && k.P.register && k.P.register("sushi-client", s);
        } catch (R) {
          b.ueLogError(R, {
            logLevel: "WARN"
          });
        }

        P("ld", "ue_sushi_v1", {
          wb: 1
        });
      }, "Nxs-JS-Client")(ue_csm, window);
    }
    /**
     * The code in this function is pulled directly from:
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/transportation-clients.js
     */

  }, {
    key: "transportationClientCode",
    value: function transportationClientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, c) {
        var e = function e() {},
            f = function () {
          return {
            send: function send(b, d) {
              if (d && b) {
                var a;
                if (c.XDomainRequest) a = new XDomainRequest(), a.onerror = e, a.ontimeout = e, a.onprogress = e, a.onload = e, a.timeout = 0;else if (c.XMLHttpRequest) {
                  if (a = new XMLHttpRequest(), !("withCredentials" in a)) throw "";
                } else a = void 0;
                if (!a) throw "";
                a.open("POST", b, !0);
                a.setRequestHeader && a.setRequestHeader("Content-type", "text/plain");
                a.send(d);
              }
            },
            isSupported: !0
          };
        }(),
            g = function () {
          return {
            send: function send(c, d) {
              if (c && d) if (navigator.sendBeacon(c, d)) b.ue_sbuimp && b.ue && b.ue.ssw && b.ue.ssw("eelsts", "scs");else throw "";
            },
            isSupported: !!navigator.sendBeacon && !(c.cordova && c.cordova.platformId && "ios" == c.cordova.platformId)
          };
        }();

        b.ue._ajx = f;
        b.ue._sBcn = g;
      }, "Transportation-clients")(ue_csm, window);
    }
  }]);
  return SushiClient;
}();

exports.default = SushiClient;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js")["default"];

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? Object(arguments[i]) : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js")["default"];

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js");

var defineProperty = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js");

function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set(target, property, value, receiver) {
      var base = superPropBase(target, property);
      var desc;

      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.set) {
          desc.set.call(receiver, value);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }

      desc = Object.getOwnPropertyDescriptor(receiver, property);

      if (desc) {
        if (!desc.writable) {
          return false;
        }

        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else {
        defineProperty(receiver, property, value);
      }

      return true;
    };
  }

  return set(target, property, value, receiver);
}

function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);

  if (!s && isStrict) {
    throw new Error('failed to set property');
  }

  return value;
}

module.exports = _set;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/error-stack-parser/error-stack-parser.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/error-stack-parser/error-stack-parser.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(\),.*$)/g, '');
                }
                var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '(');

                // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
                // case it has spaces in it, as the string is split on \s+ later on
                var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);

                // remove the parenthesized location from the line, if it was matched
                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;

                var tokens = sanitizedLine.split(/\s+/).slice(1);
                // if a location was matched, pass it to extractLocation() otherwise pop the last token
                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                    .replace(/<anonymous function(: (\w+))?>/, '$2')
                    .replace(/\([^)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/finally.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/finally.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        // @ts-ignore
        return constructor.reject(reason);
      });
    }
  );
}

/* harmony default export */ __webpack_exports__["default"] = (finallyConstructor);


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/index.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony import */ var _finally__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./finally */ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/finally.js");


// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = _finally__WEBPACK_IMPORTED_MODULE_0__["default"];

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }

    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }

    for (var i = 0, len = arr.length; i < len; i++) {
      Promise.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  // @ts-ignore
  (typeof setImmediate === 'function' &&
    function(fn) {
      // @ts-ignore
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/* harmony default export */ __webpack_exports__["default"] = (Promise);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");
var has = Object.prototype.hasOwnProperty;

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = util.toSetString(aStr);
  var isDuplicate = has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    this._set[sStr] = idx;
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  var sStr = util.toSetString(aStr);
  return has.call(this._set, sStr);
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  var sStr = util.toSetString(aStr);
  if (has.call(this._set, sStr)) {
    return this._set[sStr];
  }
  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/binary-search.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/binary-search.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/mapping-list.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/mapping-list.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/quick-sort.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/quick-sort.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-consumer.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-consumer.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");
var binarySearch = __webpack_require__(/*! ./binary-search */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/binary-search.js");
var ArraySet = __webpack_require__(/*! ./array-set */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js").ArraySet;
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js");
var quickSort = __webpack_require__(/*! ./quick-sort */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/quick-sort.js").quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");
var ArraySet = __webpack_require__(/*! ./array-set */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js").ArraySet;
var MappingList = __webpack_require__(/*! ./mapping-list */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/mapping-list.js").MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-node.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-node.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are removed from this array, by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var shiftNextLine = function() {
      var lineContents = remainingLines.shift();
      // The last line of a file might not have a newline.
      var newLine = remainingLines.shift() || "";
      return lineContents + newLine;
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[0];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[0];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLines.length > 0) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/source-map.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/source-map.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stack-generator/stack-generator.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stack-generator/stack-generator.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function(StackFrame) {
    return {
        backtrace: function StackGenerator$$backtrace(opts) {
            var stack = [];
            var maxStackSize = 10;

            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {
                maxStackSize = opts.maxStackSize;
            }

            var curr = arguments.callee;
            while (curr && stack.length < maxStackSize && curr['arguments']) {
                // Allow V8 optimizations
                var args = new Array(curr['arguments'].length);
                for (var i = 0; i < args.length; ++i) {
                    args[i] = curr['arguments'][i];
                }
                if (/function(?:\s+([\w$]+))+\s*\(/.test(curr.toString())) {
                    stack.push(new StackFrame({functionName: RegExp.$1 || undefined, args: args}));
                } else {
                    stack.push(new StackFrame({args: args}));
                }

                try {
                    curr = curr.caller;
                } catch (e) {
                    break;
                }
            }
            return stack;
        }
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];
    var objectProps = ['evalOrigin'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);

    function StackFrame(obj) {
        if (!obj) return;
        for (var i = 0; i < props.length; i++) {
            if (obj[props[i]] !== undefined) {
                this['set' + _capitalize(props[i])](obj[props[i]]);
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-gps/stacktrace-gps.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stacktrace-gps/stacktrace-gps.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! source-map */ "./node_modules/@amzn/katal-logger/node_modules/source-map/source-map.js"), __webpack_require__(/*! stackframe */ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function(SourceMap, StackFrame) {
    'use strict';

    /**
     * Make a X-Domain request to url and callback.
     *
     * @param {String} url
     * @returns {Promise} with response text if fulfilled
     */
    function _xdr(url) {
        return new Promise(function(resolve, reject) {
            var req = new XMLHttpRequest();
            req.open('get', url);
            req.onerror = reject;
            req.onreadystatechange = function onreadystatechange() {
                if (req.readyState === 4) {
                    if ((req.status >= 200 && req.status < 300) ||
                        (url.substr(0, 7) === 'file://' && req.responseText)) {
                        resolve(req.responseText);
                    } else {
                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));
                    }
                }
            };
            req.send();
        });

    }

    /**
     * Convert a Base64-encoded string into its original representation.
     * Used for inline sourcemaps.
     *
     * @param {String} b64str Base-64 encoded string
     * @returns {String} original representation of the base64-encoded string.
     */
    function _atob(b64str) {
        if (typeof window !== 'undefined' && window.atob) {
            return window.atob(b64str);
        } else {
            throw new Error('You must supply a polyfill for window.atob in this environment');
        }
    }

    function _parseJson(string) {
        if (typeof JSON !== 'undefined' && JSON.parse) {
            return JSON.parse(string);
        } else {
            throw new Error('You must supply a polyfill for JSON.parse in this environment');
        }
    }

    function _findFunctionName(source, lineNumber/*, columnNumber*/) {
        var syntaxes = [
            // {name} = function ({args}) TODO args capture
            /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/,
            // function {name}({args}) m[1]=name m[2]=args
            /function\s+([^('"`]*?)\s*\(([^)]*)\)/,
            // {name} = eval()
            /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/,
            // fn_name() {
            /\b(?!(?:if|for|switch|while|with|catch)\b)(?:(?:static)\s+)?(\S+)\s*\(.*?\)\s*\{/,
            // {name} = () => {
            /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*\(.*?\)\s*=>/
        ];
        var lines = source.split('\n');

        // Walk backwards in the source lines until we find the line which matches one of the patterns above
        var code = '';
        var maxLines = Math.min(lineNumber, 20);
        for (var i = 0; i < maxLines; ++i) {
            // lineNo is 1-based, source[] is 0-based
            var line = lines[lineNumber - i - 1];
            var commentPos = line.indexOf('//');
            if (commentPos >= 0) {
                line = line.substr(0, commentPos);
            }

            if (line) {
                code = line + code;
                var len = syntaxes.length;
                for (var index = 0; index < len; index++) {
                    var m = syntaxes[index].exec(code);
                    if (m && m[1]) {
                        return m[1];
                    }
                }
            }
        }
        return undefined;
    }

    function _ensureSupportedEnvironment() {
        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {
            throw new Error('Unable to consume source maps in older browsers');
        }
    }

    function _ensureStackFrameIsLegit(stackframe) {
        if (typeof stackframe !== 'object') {
            throw new TypeError('Given StackFrame is not an object');
        } else if (typeof stackframe.fileName !== 'string') {
            throw new TypeError('Given file name is not a String');
        } else if (typeof stackframe.lineNumber !== 'number' ||
            stackframe.lineNumber % 1 !== 0 ||
            stackframe.lineNumber < 1) {
            throw new TypeError('Given line number must be a positive integer');
        } else if (typeof stackframe.columnNumber !== 'number' ||
            stackframe.columnNumber % 1 !== 0 ||
            stackframe.columnNumber < 0) {
            throw new TypeError('Given column number must be a non-negative integer');
        }
        return true;
    }

    function _findSourceMappingURL(source) {
        var sourceMappingUrlRegExp = /\/\/[#@] ?sourceMappingURL=([^\s'"]+)\s*$/mg;
        var lastSourceMappingUrl;
        var matchSourceMappingUrl;
        // eslint-disable-next-line no-cond-assign
        while (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(source)) {
            lastSourceMappingUrl = matchSourceMappingUrl[1];
        }
        if (lastSourceMappingUrl) {
            return lastSourceMappingUrl;
        } else {
            throw new Error('sourceMappingURL not found');
        }
    }

    function _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache) {
        return new Promise(function(resolve, reject) {
            var loc = sourceMapConsumer.originalPositionFor({
                line: stackframe.lineNumber,
                column: stackframe.columnNumber
            });

            if (loc.source) {
                // cache mapped sources
                var mappedSource = sourceMapConsumer.sourceContentFor(loc.source);
                if (mappedSource) {
                    sourceCache[loc.source] = mappedSource;
                }

                resolve(
                    // given stackframe and source location, update stackframe
                    new StackFrame({
                        functionName: loc.name || stackframe.functionName,
                        args: stackframe.args,
                        fileName: loc.source,
                        lineNumber: loc.line,
                        columnNumber: loc.column
                    }));
            } else {
                reject(new Error('Could not get original source for given stackframe and source map'));
            }
        });
    }

    /**
     * @constructor
     * @param {Object} opts
     *      opts.sourceCache = {url: "Source String"} => preload source cache
     *      opts.sourceMapConsumerCache = {/path/file.js.map: SourceMapConsumer}
     *      opts.offline = True to prevent network requests.
     *              Best effort without sources or source maps.
     *      opts.ajax = Promise returning function to make X-Domain requests
     */
    return function StackTraceGPS(opts) {
        if (!(this instanceof StackTraceGPS)) {
            return new StackTraceGPS(opts);
        }
        opts = opts || {};

        this.sourceCache = opts.sourceCache || {};
        this.sourceMapConsumerCache = opts.sourceMapConsumerCache || {};

        this.ajax = opts.ajax || _xdr;

        this._atob = opts.atob || _atob;

        this._get = function _get(location) {
            return new Promise(function(resolve, reject) {
                var isDataUrl = location.substr(0, 5) === 'data:';
                if (this.sourceCache[location]) {
                    resolve(this.sourceCache[location]);
                } else if (opts.offline && !isDataUrl) {
                    reject(new Error('Cannot make network requests in offline mode'));
                } else {
                    if (isDataUrl) {
                        // data URLs can have parameters.
                        // see http://tools.ietf.org/html/rfc2397
                        var supportedEncodingRegexp =
                            /^data:application\/json;([\w=:"-]+;)*base64,/;
                        var match = location.match(supportedEncodingRegexp);
                        if (match) {
                            var sourceMapStart = match[0].length;
                            var encodedSource = location.substr(sourceMapStart);
                            var source = this._atob(encodedSource);
                            this.sourceCache[location] = source;
                            resolve(source);
                        } else {
                            reject(new Error('The encoding of the inline sourcemap is not supported'));
                        }
                    } else {
                        var xhrPromise = this.ajax(location, {method: 'get'});
                        // Cache the Promise to prevent duplicate in-flight requests
                        this.sourceCache[location] = xhrPromise;
                        xhrPromise.then(resolve, reject);
                    }
                }
            }.bind(this));
        };

        /**
         * Creating SourceMapConsumers is expensive, so this wraps the creation of a
         * SourceMapConsumer in a per-instance cache.
         *
         * @param {String} sourceMappingURL = URL to fetch source map from
         * @param {String} defaultSourceRoot = Default source root for source map if undefined
         * @returns {Promise} that resolves a SourceMapConsumer
         */
        this._getSourceMapConsumer = function _getSourceMapConsumer(sourceMappingURL, defaultSourceRoot) {
            return new Promise(function(resolve) {
                if (this.sourceMapConsumerCache[sourceMappingURL]) {
                    resolve(this.sourceMapConsumerCache[sourceMappingURL]);
                } else {
                    var sourceMapConsumerPromise = new Promise(function(resolve, reject) {
                        return this._get(sourceMappingURL).then(function(sourceMapSource) {
                            if (typeof sourceMapSource === 'string') {
                                sourceMapSource = _parseJson(sourceMapSource.replace(/^\)\]\}'/, ''));
                            }
                            if (typeof sourceMapSource.sourceRoot === 'undefined') {
                                sourceMapSource.sourceRoot = defaultSourceRoot;
                            }

                            resolve(new SourceMap.SourceMapConsumer(sourceMapSource));
                        }, reject);
                    }.bind(this));
                    this.sourceMapConsumerCache[sourceMappingURL] = sourceMapConsumerPromise;
                    resolve(sourceMapConsumerPromise);
                }
            }.bind(this));
        };

        /**
         * Given a StackFrame, enhance function name and use source maps for a
         * better StackFrame.
         *
         * @param {StackFrame} stackframe object
         * @returns {Promise} that resolves with with source-mapped StackFrame
         */
        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {
            return new Promise(function(resolve, reject) {
                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {
                    function resolveMappedStackFrame() {
                        resolve(mappedStackFrame);
                    }

                    this.findFunctionName(mappedStackFrame)
                        .then(resolve, resolveMappedStackFrame)
                        // eslint-disable-next-line no-unexpected-multiline
                        ['catch'](resolveMappedStackFrame);
                }.bind(this), reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, guess function name from location information.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureStackFrameIsLegit(stackframe);
                this._get(stackframe.fileName).then(function getSourceCallback(source) {
                    var lineNumber = stackframe.lineNumber;
                    var columnNumber = stackframe.columnNumber;
                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);
                    // Only replace functionName if we found something
                    if (guessedFunctionName) {
                        resolve(new StackFrame({
                            functionName: guessedFunctionName,
                            args: stackframe.args,
                            fileName: stackframe.fileName,
                            lineNumber: lineNumber,
                            columnNumber: columnNumber
                        }));
                    } else {
                        resolve(stackframe);
                    }
                }, reject)['catch'](reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureSupportedEnvironment();
                _ensureStackFrameIsLegit(stackframe);

                var sourceCache = this.sourceCache;
                var fileName = stackframe.fileName;
                this._get(fileName).then(function(source) {
                    var sourceMappingURL = _findSourceMappingURL(source);
                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';
                    var defaultSourceRoot = fileName.substring(0, fileName.lastIndexOf('/') + 1);

                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\/\/|^\/\//i).test(sourceMappingURL)) {
                        sourceMappingURL = defaultSourceRoot + sourceMappingURL;
                    }

                    return this._getSourceMapConsumer(sourceMappingURL, defaultSourceRoot)
                        .then(function(sourceMapConsumer) {
                            return _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache)
                                .then(resolve)['catch'](function() {
                                    resolve(stackframe);
                                });
                        });
                }.bind(this), reject)['catch'](reject);
            }.bind(this));
        };
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-js/stacktrace.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stacktrace-js/stacktrace.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! error-stack-parser */ "./node_modules/@amzn/katal-logger/node_modules/error-stack-parser/error-stack-parser.js"), __webpack_require__(/*! stack-generator */ "./node_modules/@amzn/katal-logger/node_modules/stack-generator/stack-generator.js"), __webpack_require__(/*! stacktrace-gps */ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-gps/stacktrace-gps.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {
    var _options = {
        filter: function(stackframe) {
            // Filter out stackframes for this library by default
            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&
                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;
        },
        sourceCache: {}
    };

    var _generateError = function StackTrace$$GenerateError() {
        try {
            // Error must be thrown to get stack in IE
            throw new Error();
        } catch (err) {
            return err;
        }
    };

    /**
     * Merge 2 given Objects. If a conflict occurs the second object wins.
     * Does not do deep merges.
     *
     * @param {Object} first base object
     * @param {Object} second overrides
     * @returns {Object} merged first and second
     * @private
     */
    function _merge(first, second) {
        var target = {};

        [first, second].forEach(function(obj) {
            for (var prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    target[prop] = obj[prop];
                }
            }
            return target;
        });

        return target;
    }

    function _isShapedLikeParsableError(err) {
        return err.stack || err['opera#sourceloc'];
    }

    function _filtered(stackframes, filter) {
        if (typeof filter === 'function') {
            return stackframes.filter(filter);
        }
        return stackframes;
    }

    return {
        /**
         * Get a backtrace from invocation point.
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        get: function StackTrace$$get(opts) {
            var err = _generateError();
            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);
        },

        /**
         * Get a backtrace from invocation point.
         * IMPORTANT: Does not handle source maps or guess function names!
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        getSync: function StackTrace$$getSync(opts) {
            opts = _merge(_options, opts);
            var err = _generateError();
            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);
            return _filtered(stack, opts.filter);
        },

        /**
         * Given an error object, parse it.
         *
         * @param {Error} error object
         * @param {Object} opts
         * @returns {Promise} for Array[StackFrame}
         */
        fromError: function StackTrace$$fromError(error, opts) {
            opts = _merge(_options, opts);
            var gps = new StackTraceGPS(opts);
            return new Promise(function(resolve) {
                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);
                resolve(Promise.all(stackframes.map(function(sf) {
                    return new Promise(function(resolve) {
                        function resolveOriginal() {
                            resolve(sf);
                        }

                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);
                    });
                })));
            }.bind(this));
        },

        /**
         * Use StackGenerator to generate a backtrace.
         *
         * @param {Object} opts
         * @returns {Promise} of Array[StackFrame]
         */
        generateArtificially: function StackTrace$$generateArtificially(opts) {
            opts = _merge(_options, opts);
            var stackFrames = StackGenerator.backtrace(opts);
            if (typeof opts.filter === 'function') {
                stackFrames = stackFrames.filter(opts.filter);
            }
            return Promise.resolve(stackFrames);
        },

        /**
         * Given a function, wrap it such that invocations trigger a callback that
         * is called with a stack trace.
         *
         * @param {Function} fn to be instrumented
         * @param {Function} callback function to call with a stack trace on invocation
         * @param {Function} errback optional function to call with error if unable to get stack trace.
         * @param {Object} thisArg optional context object (e.g. window)
         */
        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                // Already instrumented, return given Function
                return fn;
            }

            var instrumented = function StackTrace$$instrumented() {
                try {
                    this.get().then(callback, errback)['catch'](errback);
                    return fn.apply(thisArg || this, arguments);
                } catch (e) {
                    if (_isShapedLikeParsableError(e)) {
                        this.fromError(e).then(callback, errback)['catch'](errback);
                    }
                    throw e;
                }
            }.bind(this);
            instrumented.__stacktraceOriginalFn = fn;

            return instrumented;
        },

        /**
         * Given a function that has been instrumented,
         * revert the function to it's original (non-instrumented) state.
         *
         * @param {Function} fn to de-instrument
         */
        deinstrument: function StackTrace$$deinstrument(fn) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot de-instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                return fn.__stacktraceOriginalFn;
            } else {
                // Function not instrumented, return original
                return fn;
            }
        },

        /**
         * Given an error message and Array of StackFrames, serialize and POST to given URL.
         *
         * @param {Array} stackframes
         * @param {String} url
         * @param {String} errorMsg
         * @param {Object} requestOptions
         */
        report: function StackTrace$$report(stackframes, url, errorMsg, requestOptions) {
            return new Promise(function(resolve, reject) {
                var req = new XMLHttpRequest();
                req.onerror = reject;
                req.onreadystatechange = function onreadystatechange() {
                    if (req.readyState === 4) {
                        if (req.status >= 200 && req.status < 400) {
                            resolve(req.responseText);
                        } else {
                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));
                        }
                    }
                };
                req.open('post', url);

                // Set request headers
                req.setRequestHeader('Content-Type', 'application/json');
                if (requestOptions && typeof requestOptions.headers === 'object') {
                    var headers = requestOptions.headers;
                    for (var header in headers) {
                        if (Object.prototype.hasOwnProperty.call(headers, header)) {
                            req.setRequestHeader(header, headers[header]);
                        }
                    }
                }

                var reportPayload = {stack: stackframes};
                if (errorMsg !== undefined && errorMsg !== null) {
                    reportPayload.message = errorMsg;
                }

                req.send(JSON.stringify(reportPayload));
            });
        }
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/bytesToUuid.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/uuid/lib/bytesToUuid.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/rng-browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/uuid/lib/rng-browser.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/uuid/v4.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/uuid/v4.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KatalMetricsDriverSushi = void 0;

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricsDriver2 = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/metricObject/KatalMetricType */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

var _katalSushiClient = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-sushi-client */ "./node_modules/@amzn/katal-sushi-client/dist/SushiClient.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var KAT_STANDALONE_NEXUS_PRODUCER_ID = 'katal';
var KAT_STANDALONE_DEFAULT_SOURCE_GROUPS = {
  test: 'com.amazon.eel.katal.metrics.core.nexus.gamma',
  prod: 'com.amazon.eel.katal.metrics.core.nexus'
};

var KatalMetricsDriverSushiBuilder = /*#__PURE__*/function () {
  function KatalMetricsDriverSushiBuilder() {
    (0, _classCallCheck2.default)(this, KatalMetricsDriverSushiBuilder);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(KatalMetricsDriverSushiBuilder, [{
    key: "withSushiClient",
    value: function withSushiClient(sushiClient) {
      console.log('withSushi client...');
      this.context.sushiClient = sushiClient;
      return this;
    }
  }, {
    key: "withDomainRealm",
    value: function withDomainRealm(domain, realm) {
      this.context.domain = domain;
      this.context.realm = realm;
      return this;
    }
  }, {
    key: "withCustomProducer",
    value: function withCustomProducer(sushiProducerId) {
      this.context.sushiProducer = sushiProducerId;
      return this;
    }
  }, {
    key: "withCustomSourceGroup",
    value: function withCustomSourceGroup(sourceGroupId) {
      this.context.sourceGroupId = sourceGroupId;
      return this;
    }
  }, {
    key: "withErrorHandler",
    value: function withErrorHandler(errorHandler) {
      this.context.errorHandler = errorHandler;
      return this;
    }
  }, {
    key: "withSushiClientOptions",
    value: function withSushiClientOptions(sushiClientOptions) {
      this.context.sushiClientOptions = sushiClientOptions;
      return this;
    }
  }, {
    key: "withSushiClientTransportOverride",
    value: function withSushiClientTransportOverride(sushiClientTransportOverride) {
      this.context.sushiClientTransportOverride = sushiClientTransportOverride;
      return this;
    }
  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsDriverSushi(this.context);
    }
  }]);
  return KatalMetricsDriverSushiBuilder;
}();

var KatalMetricsDriverSushi = /*#__PURE__*/function (_KatalMetricsDriver) {
  (0, _inherits2.default)(KatalMetricsDriverSushi, _KatalMetricsDriver);

  var _super = _createSuper(KatalMetricsDriverSushi);

  function KatalMetricsDriverSushi(options) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricsDriverSushi);
    _this = _super.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sushi", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "producerId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sourceGroupId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "errorHandler", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "combinedErrorHandler", function (err) {
      if (_this.errorHandler) {
        try {
          _this.errorHandler(err); // Return to avoid falling through to default error handler


          return;
        } catch (nextErr) {
          console.error("Error handling error publishing metrics:");
          console.error(nextErr); // Fall through
        }
      }

      _this.defaultErrorHandler(err);
    });
    var domain = options.domain,
        realm = options.realm,
        errorHandler = options.errorHandler,
        sushiClient = options.sushiClient,
        _options$sushiProduce = options.sushiProducer,
        producerId = _options$sushiProduce === void 0 ? KAT_STANDALONE_NEXUS_PRODUCER_ID : _options$sushiProduce,
        sushiClientOptions = options.sushiClientOptions,
        sushiClientTransportOverride = options.sushiClientTransportOverride; // custom source group always overrides defaults

    var sourceGroupId = options.sourceGroupId || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS[domain] || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS['test'];
    _this.sushi = sushiClient || _this.buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride);
    _this.errorHandler = errorHandler;
    _this.producerId = producerId;
    _this.sourceGroupId = sourceGroupId;
    return _this;
  }

  (0, _createClass2.default)(KatalMetricsDriverSushi, [{
    key: "beforeUnload",
    value:
    /**
     * Register a callback to be called right before the page unloads. This
     * allows for any final metrics, such as page visit duration, to be sent
     * before the user navigates away from the page or closes the tab.
     * NOTE: This is an experimental API and may change in the future.
     * @param cb The callback to call.
     */
    function beforeUnload(cb) {
      this.sushi.onSushiUnload(cb);
    }
    /**
     * Default error handler if the user-supplied error handler fails or is unset.  Should never be called unless
     * user-provided error handler misbehaves.
     *
     * @param err Unhandled error object
     */

  }, {
    key: "defaultErrorHandler",
    value: function defaultErrorHandler(err) {
      console.error("Error publishing metrics:");
      console.error(err);
    }
    /**
     * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
     * an exception, calls the default error handler as a fallback, which will just log the error to the console.
     *
     * @param err Error object to handle
     */

  }, {
    key: "withErrorHandling",
    value:
    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
  }, {
    key: "buildSushiClient",
    value: function buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride) {
      if (!domain || !realm) {
        throw new Error('KatalMetricsDriverSushi requires a domain and realm to build a sushi client.');
      }

      return new _katalSushiClient.default(KatalMetricsDriverSushi.getRealmName(realm), sourceGroupId, this.combinedErrorHandler, sushiClientOptions, sushiClientTransportOverride);
    }
  }, {
    key: "publish",
    value: // TODO: errorHandler in this method is deprecated and is not referenced.
    // Tech debt: https://issues.amazon.com/issues/KAT-875
    function publish(metricObject, errorHandler, context) {
      var _this2 = this;

      // Support for new 2-argument form of publish, which does not pass the unused errorHandler object (KAT-875)
      var metricsContext = arguments.length < 3 ? arguments[1] : arguments[2];
      this.withErrorHandling(function () {
        // TODO: This logic is now moved into KatalMetricsPublisher, once everybody has that update we can remove this.
        // Tech debt: https://issues.amazon.com/issues/KAT-876
        if (_KatalMetricType.default.List === metricObject.type) {
          metricObject.metricList.forEach(function (metric) {
            _this2.publish(metric, metricsContext);
          });
          return;
        }

        var nexusSchema = _this2.mapObjectTypeToNexusSchema(metricObject.type);

        var fields = _objectSpread(_objectSpread({}, metricsContext.context), {}, {
          metricKey: metricObject.name,
          value: metricObject.value
        });

        if (metricObject.isMonitor) {
          fields.isMonitor = true;
        } // Deleting cloudWatchDimensions field if exists as it applies only for KatalMonitoringAWSDriver.


        if (fields.cloudWatchDimensions) {
          delete fields.cloudWatchDimensions;
        } // Reset the event count back to 0, otherwise Sushi will stop publishing after 1K items (https://issues.amazon.com/issues/KAT-1534)


        _this2.sushi.reset();

        _this2.sushi.event(fields, _this2.producerId, nexusSchema, {
          "ssd": 1
        });
      });
    }
  }, {
    key: "mapObjectTypeToNexusSchema",
    value: function mapObjectTypeToNexusSchema(objectType) {
      switch (objectType) {
        case _KatalMetricType.default.String:
          return 'katal.client.metrics.String.2';

        case _KatalMetricType.default.Counter:
          return 'katal.client.metrics.Counter.3';

        case _KatalMetricType.default.Timer:
          return 'katal.client.metrics.Timer.2';

        default:
          throw new Error("Unknown type ".concat(objectType, " when publishing metric object."));
      }
    }
  }], [{
    key: "getRealmName",
    value: function getRealmName(realm) {
      switch (realm) {
        case 'NAAmazon':
        case 'USAmazon':
          return _katalSushiClient.default.REGIONS.NA;

        case 'EUAmazon':
          return _katalSushiClient.default.REGIONS.EU;

        case 'FEAmazon':
        case 'JPAmazon':
          return _katalSushiClient.default.REGIONS.FE;

        case 'CNAmazon':
          return _katalSushiClient.default.REGIONS.CN;

        default:
          // Let the SushiClient decide if this is bogus or not.
          return realm;
      }
    }
  }]);
  return KatalMetricsDriverSushi;
}(_KatalMetricsDriver2.default);

exports.KatalMetricsDriverSushi = KatalMetricsDriverSushi;
(0, _defineProperty2.default)(KatalMetricsDriverSushi, "Builder", KatalMetricsDriverSushiBuilder);

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! ./nodejsShims */ 1);

var _KatalMetricsDriverSushi = __webpack_require__(/*! ./KatalMetricsDriverSushi */ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js");

/* istanbul ignore file */
var _default = _KatalMetricsDriverSushi.KatalMetricsDriverSushi;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ./helper/ValidateSimpleString */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _validateCloudWatchDimensions = _interopRequireDefault(__webpack_require__(/*! ./helper/validateCloudWatchDimensions */ "./node_modules/@amzn/katal-metrics/lib/helper/validateCloudWatchDimensions.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ./helper/FirstMap */ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var REQUIRED_FIELDS = ['site', 'serviceName', 'methodName'];

var KatalMetricsContext = /*#__PURE__*/function () {
  /**
   * Create a new metrics context with the given fields.
   *
   * @param contextFields Context fields value (default empty)
   */
  function KatalMetricsContext() {
    var contextFields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, KatalMetricsContext);
    // Copy fields so this is immutable
    this.context = _objectSpread({}, contextFields);
  }
  /**
   * Return a new KatalMetricsContext which is a copy of this context, with values added or overridden from
   * the given context.
   *
   * If the given context is null or empty, this method may return the original object as an optimization.
   *
   * @param thatContext Context to merge values from
   * @return New context with default values from this context, and values overridden or added by the given context.
   */


  (0, _createClass2.default)(KatalMetricsContext, [{
    key: "merge",
    value: function merge(thatContext) {
      if (!thatContext) return this; // Check for a common error

      if (thatContext instanceof KatalMetricsContext.Builder) {
        throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
      }

      var context = thatContext instanceof KatalMetricsContext ? thatContext.context : thatContext;

      var newContext = _objectSpread(_objectSpread(_objectSpread({}, this.context), context), {}, {
        relatedMetrics: (0, _mergeLists.mergeLists)(this.context.relatedMetrics, context.relatedMetrics),
        relatedMetricsSingleAction: (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, context.relatedMetricsSingleAction),
        // Combines the dimensions from base publisher with any child publisher.
        cloudWatchDimensions: (0, _mergeLists.mergeLists)(this.context.cloudWatchDimensions, context.cloudWatchDimensions)
      });

      return new KatalMetricsContext(newContext);
    }
    /**
     * Return a new context which is a copy of this context with relatedMetricsSingleAction removed.
     *
     * This is intended to be called when creating a new child publisher.
     *
     * @return Copy of this context, with relatedMetricsSingleAction removed
     */

  }, {
    key: "withoutRelatedMetricsSingleAction",
    value: function withoutRelatedMetricsSingleAction() {
      return new KatalMetricsContext(_objectSpread(_objectSpread({}, this.context), {}, {
        relatedMetricsSingleAction: undefined
      }));
    }
    /**
     * Get a context suitable for publication to the driver.
     *
     * This method strips out any private fields, and leaves only fields from the schema that the driver should publish.
     *
     * @return Context suitable for driver publication
     */

  }, {
    key: "driverContext",
    value: function driverContext() {
      // Don't publish relatedMetrics to the driver
      var newContextFields = _objectSpread({}, this.context);

      delete newContextFields["relatedMetrics"];
      delete newContextFields["relatedMetricsSingleAction"];
      delete newContextFields["requestId"];

      if (this.context.requestId) {
        newContextFields.actionId = (0, _embedRequestId.embedRequestId)(newContextFields.actionId, this.context.requestId);
      }

      return new KatalMetricsContext(newContextFields);
    }
    /**
     * Get a simple JavaScript object with a copy of the fields for this context.
     *
     * @return Simple Javascript object with a copy of the fields for this context
     */

  }, {
    key: "getFields",
    value: function getFields() {
      // Copy fields so this remains immutable
      return _objectSpread({}, this.context);
    }
    /**
     * Check for a validation error on this context.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns Errors found with this context
     */

  }, {
    key: "validationError",
    value: function validationError() {
      var _this = this;

      var err; // Fields site, serviceName, methodName, and metricKey are required.

      err = (0, _FirstMap.default)(REQUIRED_FIELDS, function (field) {
        if (_this.context[field] == undefined) {
          return new Error("Field ".concat(field, " is required, but it is ").concat(_this.context[field]));
        }
      });
      if (err) return err;
      return (0, _FirstMap.default)(Object.keys(this.context), function (field) {
        return _this.validateField(field);
      });
    }
    /**
     * Validate an individual context field.
     *
     * @param field Name of field to validate
     * @returns Error found with this field, or undefined
     */

  }, {
    key: "validateField",
    value: function validateField(field) {
      var val = this.context[field];
      var nameForError = "field ".concat(field);

      switch (field) {
        // Strings which could be used as partition keys ("site" and "serviceName") cannot contain slashes, in
        // addition to the other restictions below.
        case 'site':
        case 'serviceName':
          if (val.indexOf('/') > -1) return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It cannot contain a slash."));
        // Else fall through
        // Strings for fields site, serviceName, methodName, metricKey must match be valid PMET field names:
        // maximum length of 256, only letters, numbers, and the dot, colon, at-sign, underscore, forward-slash,
        // and slash characters (in short the regex ^[A-Za-z0-9.:@_/-]+$).

        case 'methodName':
        case 'actionId':
          return (0, _ValidateSimpleString.default)(val, nameForError);

        case 'cloudWatchDimensions':
          return (0, _validateCloudWatchDimensions.default)(val || []);
      } // No error found, implicitly return undefined

    }
    /**
     * Builder class for KatalMetricsContext
     */

  }]);
  return KatalMetricsContext;
}();

exports.default = KatalMetricsContext;
(0, _defineProperty2.default)(KatalMetricsContext, "Builder", /*#__PURE__*/function () {
  function _class2() {
    (0, _classCallCheck2.default)(this, _class2);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(_class2, [{
    key: "withSite",
    value: function withSite(site) {
      this.context.site = site;
      return this;
    }
  }, {
    key: "withServiceName",
    value: function withServiceName(serviceName) {
      this.context.serviceName = serviceName;
      return this;
    }
  }, {
    key: "withMethodName",
    value: function withMethodName(methodName) {
      this.context.methodName = methodName;
      return this;
    }
  }, {
    key: "withActionId",
    value: function withActionId(actionId) {
      this.context.actionId = actionId;
      return this;
    }
  }, {
    key: "withRequestId",
    value: function withRequestId(requestId) {
      this.context.requestId = requestId;
      return this;
    }
  }, {
    key: "withCloudWatchDimensions",
    value: function withCloudWatchDimensions(dimensions) {
      this.context.cloudWatchDimensions = dimensions;
      return this;
    }
    /**
     * Replace any related metrics with the given list (see addRelatedMetrics to add instead of replace).
     *
     * Related metrics are metrics that are published whenever a new action is started.  They are used to relate the
     * action back to the context where it is happening, for example a request ID or a user identity.
     *
     * @param relatedMetrics Related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetrics",
    value: function withRelatedMetrics() {
      for (var _len = arguments.length, relatedMetrics = new Array(_len), _key = 0; _key < _len; _key++) {
        relatedMetrics[_key] = arguments[_key];
      }

      this.context.relatedMetrics = relatedMetrics;
      return this;
    }
    /**
     * Add additional related metrics to this builder.  See withRelatedMetrics for more information.
     *
     * @param relatedMetrics Additional related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetrics",
    value: function addRelatedMetrics() {
      for (var _len2 = arguments.length, relatedMetrics = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        relatedMetrics[_key2] = arguments[_key2];
      }

      this.context.relatedMetrics = (0, _mergeLists.mergeLists)(this.context.relatedMetrics, relatedMetrics);
      return this;
    }
    /**
     * Replace single-action related metrics with the given list (see addRelatedMetricsSingleAction to add instead of replace,
     * and withRelatedMetrics for more information about related metrics).
     *
     * Single-action related metrics are published when a new child metric publisher is created, but not included as
     * related metrics for the new child metric publisher, so are not published again if the child metric publisher
     * creates grandchild published metrics.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetricsSingleAction",
    value: function withRelatedMetricsSingleAction() {
      for (var _len3 = arguments.length, metrics = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        metrics[_key3] = arguments[_key3];
      }

      this.context.relatedMetricsSingleAction = metrics;
      return this;
    }
    /**
     * Add additional single-action related metrics to this builder.  See addRelatedMetricsSingleAction for more information.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetricsSingleAction",
    value: function addRelatedMetricsSingleAction() {
      for (var _len4 = arguments.length, metrics = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        metrics[_key4] = arguments[_key4];
      }

      this.context.relatedMetricsSingleAction = (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, metrics);
      return this;
    }
    /**
     * Take the fields set in this builder and use them to create a new KatalMetricsContext.
     *
     * @return KatalMetricsContext object built with the parameters given to this builder
     */

  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsContext(this.context);
    }
  }]);
  return _class2;
}());

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _v = _interopRequireDefault(__webpack_require__(/*! uuid/v4 */ "./node_modules/uuid/v4.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _metricObject = __webpack_require__(/*! ./metricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/index.js");

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _metricsExtension = __webpack_require__(/*! ./helper/metricsExtension */ "./node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

var INITIALIZATION_METHOD_NAME = 'Initialization';

/**
 * Default error handler if the user-supplied error handler fails or is unset.
 * Should never be called unless user-provided error handler misbehaves.
 */
var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  console.error("Error publishing metrics:");
  console.error(err);
};

var PARENT_ACTION_ID_NAME = 'parentActionId';

var getContextFields = function getContextFields(context) {
  if (context.context) {
    return context.context;
  } else {
    return context;
  }
};
/**
 * Class used for publishing metrics to Katal.  Contains a driver and a context.
 *
 * This class knows how to publish metrics, and how to create new publishers with a modified context.
 */


var KatalMetricsPublisher = /*#__PURE__*/function () {
  /**
   * Create a new metrics publisher with the given driver and context
   *
   * @param driver Subclass of KatalMetricsDriver used to publish the metrics
   * @param errorHandler Handler for errors that occur while using this publisher
   * @param context Context for this metrics publisher; contains data to be included with every
   *     metric published using this publisher object.  Default is an empty context.
   */
  function KatalMetricsPublisher(driver) {
    var _this = this;

    var errorHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ERROR_HANDLER;
    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _KatalMetricsContext.default();
    (0, _classCallCheck2.default)(this, KatalMetricsPublisher);
    (0, _defineProperty2.default)(this, "combinedErrorHandler", function (err) {
      try {
        _this.errorHandler(err);
      } catch (nextErr) {
        console.error("Error handling error publishing metrics:");
        console.error(nextErr);
        DEFAULT_ERROR_HANDLER(err);
      }
    });

    // Check for a common error
    if (context instanceof _KatalMetricsContext.default.Builder) {
      throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
    }

    this.driver = driver;
    this.errorHandler = errorHandler;
    this.context = !(context instanceof _KatalMetricsContext.default) ? new _KatalMetricsContext.default(context) : context;
  }
  /**
   * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
   * an exception, calls the default error handler as a fallback, which will just log the error to the console.
   *
   * @param err Error object to handle
   */


  (0, _createClass2.default)(KatalMetricsPublisher, [{
    key: "withErrorHandling",
    value:
    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
    /**
     * Helper method to return all the related metrics of base publisher and additionalContext.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @return Return all related metrics from base publisher and additionalContext.
     */

  }, {
    key: "getAdditionalRelatedMetrics",
    value: function getAdditionalRelatedMetrics(additionalContext) {
      var newContext = additionalContext instanceof _KatalMetricsContext.default ? additionalContext.context : additionalContext;
      var baseRelatedMetrics = this.getBaseRelatedMetrics();
      return (0, _mergeLists.mergeLists)(baseRelatedMetrics, newContext.relatedMetrics);
    }
    /**
     * Helper method to return all the related metrics of base publisher.
     *
     * @return Return all related metrics from the base publisher.
     */

  }, {
    key: "getBaseRelatedMetrics",
    value: function getBaseRelatedMetrics() {
      return (0, _mergeLists.mergeLists)(this.context.context.relatedMetrics, this.context.context.relatedMetricsSingleAction);
    }
    /**
     * Publish the given metric object.
     *
     * This method is guaranteed never to throw an exception.  If the metric object or context are invalid,
     * or any other exception is thrown while publishing, the publisher's error handler is called.  If the
     * publisher's error handler is unset or fails, the default error handler is called (see defaultErrorHandler).
     *
     * @param katalMetricObject Metric object to publish
     */

  }, {
    key: "publish",
    value: function publish(katalMetricObject) {
      var _this2 = this;

      this.withErrorHandling(function () {
        if (!katalMetricObject) {
          throw new Error("Cannot publish undefined/null metric object");
        }

        if (_metricObject.Object.Types.List === katalMetricObject.type) {
          katalMetricObject.metricList.forEach(function (metric) {
            _this2.publish(metric);
          });
        } else {
          var driverContext = _this2.context.driverContext();

          var contextError = driverContext.validationError();
          if (contextError) throw contextError;
          var objectError = katalMetricObject.validationError();
          if (objectError) throw objectError;
          (0, _metricsExtension.dispatchMetricEvent)(katalMetricObject, driverContext);

          _this2.driver.publish(katalMetricObject, driverContext);
        }
      });
    }
    /**
     * Create a new publisher which is identical to this publisher, but with the given context fields merged into
     * the new publisher's context.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildPublisher",
    value: function newChildPublisher(additionalContext) {
      return new KatalMetricsPublisher(this.driver, this.errorHandler, this.context.merge(additionalContext));
    }
    /**
     * Begin a new action, and return a new publisher for metrics related to that action.
     *
     * Beginning a new action involves the following steps:
     *   1. Generate a new actionId for the action, randomly in the browser
     *   2. If there are any related metrics in the context, publish them
     *   3. Create and return a new publisher with this object's context, merged with any additional context given,
     *      merged with the actionId generated above.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisher",
    value: function newChildActionPublisher(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var newContext = this.context.withoutRelatedMetricsSingleAction().merge({
        actionId: actionId
      }).merge(additionalContext);
      var newPublisher = new KatalMetricsPublisher(this.driver, this.errorHandler, newContext);
      var allRelatedMetrics = additionalContext && !(additionalContext instanceof _KatalMetricsContext.default.Builder) ? this.getAdditionalRelatedMetrics(additionalContext) : this.getBaseRelatedMetrics();

      if (allRelatedMetrics) {
        allRelatedMetrics.forEach(function (metric) {
          newPublisher.publish(metric);
        });
      }

      return newPublisher;
    }
    /**
     * Begin a new chained child action, and return a new publisher for metrics related to that action.
     *
     * A chained action is handled the same way as in newChildActionPublisher, but additionally,
     * the returned publisher has a relatedMetricNoInherit named "parentActionId", with the newly
     * generated actionId as its value.
     *
     * The effect of this is that any further chained child actions can be connected back to this
     * action through the parentActionId, and so on recursively.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChained",
    value: function newChildActionPublisherChained(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var parentActionId = (0, _embedRequestId.embedRequestId)(actionId, this.context.context.requestId);
      var relatedMetricsSingleAction = [new _metricObject.String(PARENT_ACTION_ID_NAME, parentActionId)];
      var newContext = new _KatalMetricsContext.default({
        actionId: actionId,
        relatedMetricsSingleAction: relatedMetricsSingleAction
      }).merge(additionalContext);
      return this.newChildActionPublisher(newContext);
    }
    /**
     * Helper method to create a new chained child action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherChained.
     *
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChainedForMethod",
    value: function newChildActionPublisherChainedForMethod(methodName, additionalContext) {
      return this.newChildActionPublisherChained(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherForMethod.
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForMethod",
    value: function newChildActionPublisherForMethod(methodName, additionalContext) {
      return this.newChildActionPublisher(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action for application initialization.  It will always have a methodName
     * of "Initialization"; otherwise this method is identical to newChildActionPublisherForMethod.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForInitialization",
    value: function newChildActionPublisherForInitialization(additionalContext) {
      return this.newChildActionPublisherForMethod(INITIALIZATION_METHOD_NAME, additionalContext);
    }
    /**
     * Helper method to publish a string with the given name and value.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishString",
    value: function publishString(name, value) {
      this.publish(new _metricObject.String(name, value));
    }
    /**
     * Helper method to publish a string with the given name and value, truncated to the maximum size allowed by the
     * schema.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishStringTruncate",
    value: function publishStringTruncate(name, value) {
      var object = new _metricObject.String(name, value);
      object.truncate = true;
      this.publish(object);
    }
    /**
     * Helper method to publish a counter with the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounter",
    value: function publishCounter(name, value) {
      this.publish(new _metricObject.Counter(name, value));
    }
    /**
     * Helper method to publish a timer with the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimer",
    value: function publishTimer(name, value) {
      this.publish(new _metricObject.Timer(name, value));
    }
    /**
     * Helper method to publish a counter with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounterMonitor",
    value: function publishCounterMonitor(name, value) {
      this.publish(new _metricObject.Counter(name, value).withMonitor());
    }
    /**
     * Helper method to publish a timer with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimerMonitor",
    value: function publishTimerMonitor(name, value) {
      this.publish(new _metricObject.Timer(name, value).withMonitor());
    }
    /**
     * Private helper method to extract an actionId from a context if one is provided, and otherwise generate a new one.
     *
     * @returns Action ID string
     */

  }, {
    key: "_generateActionid",
    value: function _generateActionid(context) {
      if (context) {
        var fields = getContextFields(context);

        if (fields.actionId) {
          return fields.actionId;
        }
      }

      return (0, _v.default)();
    }
  }]);
  return KatalMetricsPublisher;
}();

exports.default = KatalMetricsPublisher;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ERROR_HANDLER = void 0;

var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  throw err;
};

exports.DEFAULT_ERROR_HANDLER = DEFAULT_ERROR_HANDLER;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Abstract base class for a Katal metrics driver.
 */
var KatalMetricsDriver = /*#__PURE__*/function () {
  function KatalMetricsDriver() {
    (0, _classCallCheck2.default)(this, KatalMetricsDriver);
  }

  (0, _createClass2.default)(KatalMetricsDriver, [{
    key: "publish",
    value:
    /**
     * Publish the given metric object with the given error handler and context.
     *
     * @param metricObject Metric object to publish.  Contains metricKey, isMonitor, type, and value.
     * @param context Context for publishing this metric.  Contains all other fields to be published.
     */
    function publish(metricObject, context) {
      throw new Error('KatalMetricsDriver is an abstract class, please choose a driver and use that instead');
    }
  }]);
  return KatalMetricsDriver;
}();

exports.default = KatalMetricsDriver;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = firstMap;

/**
 * Returns the first non-undefined value that results from running each value
 * in the given array through the mapper function.
 * @param array An array of values.
 * @param mapper A mapper function that should return a value or undefined.
 * @returns The first non-undefined value from the mapper function.
 */
function firstMap(array, mapper) {
  var toReturn = undefined;
  array.some(function (val) {
    toReturn = mapper(val);
    return toReturn != null;
  });
  return toReturn;
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var objectValues = Object.values ? Object.values : function (object) {
  return Object.keys(object).map(function (key) {
    return object[key];
  });
};
var _default = objectValues;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleInt;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

/**
 * Number.isInteger is not in IE11, and letting Babel polyfill it added too much weight.
 * Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 */
var isInteger = function isInteger(val) {
  return isFinite(val) && Math.floor(val) === val;
};
/**
 * Check if the given value is valid to be published to KatalMetrics as an integer (Counter or Timer),
 * and return either undefined (no error), or an Error object describing the problem.
 *
 * @param val Value to check
 * @param nameForError Name to use when constructing the error message, if necessary
 * @returns Error, or undefined if no error
 */


function validateSimpleInt(val, nameForError) {
  if (typeof val !== 'number') {
    return new Error("Expected ".concat(nameForError, " to have type 'number', but it was type '").concat((0, _typeof2.default)(val), "'"));
  }

  if (val < 0) {
    return new Error("Expected ".concat(nameForError, " to be positive, but it was ").concat(val));
  } // This will also catch NaN and Infinity


  if (!isInteger(val)) {
    return new Error("Expected ".concat(nameForError, " to be an integer, but it was ").concat(val));
  } // Couldn't find anything wrong, implicitly return undefined

}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleString;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var SIMPLE_STRING_PAT = /^[A-Za-z0-9.:@_/-]+$/;
var SIMPLE_STRING_MAX_LEN = 127;
/**
 * Check if the given value is valid to be published to KatalMetrics as a field value,
 * such as site, serviceName, methodName, or actionId (note this is not used to check values for string metrics).
 * It returns either undefined (no error), or an Error object describing the problem.
 *
 * To be published, it must be a non-empty string, less than 256 characters, containing only ASCII
 * letters, numbers, or these characters: .:@_/- (those are the PMET field value requirements).
 *
 * @param val String value to check
 * @param nameForError Name to use in the error message, if one is generated
 * @returns Error, or undefined if no error
 */

function validateSimpleString(val, nameForError) {
  if (typeof val !== "string") {
    return new Error("Expected ".concat(nameForError, " to be a string, but it was a ").concat((0, _typeof2.default)(val)));
  }

  if (val.length > SIMPLE_STRING_MAX_LEN) {
    return new Error("Expected ".concat(nameForError, " to be less than ").concat(SIMPLE_STRING_MAX_LEN, " characters, but it was ").concat(val.length, " characters"));
  }

  if (val.length < 1) {
    return new Error("Expected ".concat(nameForError, " to be non-blank"));
  }

  if (!SIMPLE_STRING_PAT.test(val)) {
    return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It can only contain letters, numbers, and these symbols: .:@_/-"));
  } // Couldn't find anything wrong, implicitly return undefined

}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.embedRequestId = embedRequestId;

// until we can add a requestId field to the andes schema we will embed it in the actionId
function embedRequestId(actionId, requestId) {
  if (requestId) {
    return [requestId, actionId].join("::");
  }

  return actionId;
}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLists = mergeLists;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js"));

// Helper method to merge two lists which could be undefined
// Returns merged lists if either is defined, otherwise returns undefined
function mergeLists(list1, list2) {
  if (list1 || list2) {
    return [].concat((0, _toConsumableArray2.default)(list1 || []), (0, _toConsumableArray2.default)(list2 || []));
  } else {
    return undefined;
  }
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchMetricEvent = dispatchMetricEvent;

/**
 * Publish to external parties that are 
 * listening for katal.metrics.publish Custom Events
 */
function dispatchMetricEvent(metric, context) {
  if (typeof window === 'undefined') {
    return;
  }

  dispatchCustomEvent(metric, context); // for legacy purposes, also publish to __KATAL_METRICS_EXTENSION__

  publishToMetricsExtension(metric, context);
}

function dispatchCustomEvent(metric, context) {
  if (typeof CustomEvent !== "function") {
    return;
  }

  var event = new CustomEvent('katal.metrics.publish', {
    detail: {
      metric: metric,
      context: context.getFields()
    }
  });
  window.dispatchEvent(event);
}
/**
 * @Deprecated
 * Publish to https://code.amazon.com/packages/KatalMetricsExtension
 * The extension injects a global __KATAL_METRICS_EXTENSION__ object with a
 * `publish` method.
 */


function publishToMetricsExtension(metric, context) {
  var extension = window.__KATAL_METRICS_EXTENSION__;

  if (extension) {
    extension.publish(metric, context.getFields());
  }
}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/validateCloudWatchDimensions.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/validateCloudWatchDimensions.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateCloudWatchDimensions;

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ./FirstMap */ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

var PRINTABLE_ASCII_PATTERN = /^[\x20-\x7E]+$/;
var AT_LEAST_ONE_NON_WHITESPACE_PATTERN = /^.*\S+.*$/;
var DIMENSION_NAME_STRING_MAX_LEN = 255;
var DIMENSION_VALUE_STRING_MAX_LEN = 1024;
/**
 * Check if the given dimensions are valid to be published to KatalMonitoring back-end.
 * It returns either undefined (no error), or an Error object describing the problem.
 *
 * To be published, name and value of string metrics must follow restrictions as described by
 * CloudWatch Dimension API Documentation:
 * https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_Dimension.html
 *
 * @param dimensions Array of string metrics to check
 * @returns Error, or undefined if no error
 */

function validateCloudWatchDimensions(dimensions) {
  return (0, _FirstMap.default)(dimensions, function (dimension) {
    var name = dimension.name,
        value = dimension.value;
    return validateCloudWatchDimension(name, value);
  });
}
/**
 * Check if the given dimension is valid as described by CloudWatch documentation.
 * https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_Dimension.html
 *
 * @param name CloudWatch Dimension Name String to check
 * @param value CloudWatch Dimension Value String to check
 * @returns Error, or undefined if no error
 */


function validateCloudWatchDimension(name, value) {
  if (name.length > DIMENSION_NAME_STRING_MAX_LEN) {
    return new Error("Expected Dimension name for value ".concat(value, " to be ").concat(DIMENSION_NAME_STRING_MAX_LEN, " characters or less, but it was ").concat(name.length, " characters"));
  }

  if (name.length < 1) {
    return new Error("Expected Dimension name for value ".concat(value, " to be non-blank"));
  }

  if (!PRINTABLE_ASCII_PATTERN.test(name)) {
    return new Error("Expected Dimension name for value ".concat(value, " to contain only ASCII characters, but it was ").concat(name));
  }

  if (!AT_LEAST_ONE_NON_WHITESPACE_PATTERN.test(name)) {
    return new Error("Expected Dimension name for value ".concat(value, " to contain at least one non whitespace character, but it was ").concat(name));
  }

  if (name.startsWith(":")) {
    return new Error("Expected Dimension name for value ".concat(value, " to not start with a colon (\":\"), but it was ").concat(name));
  }

  if (value.length > DIMENSION_VALUE_STRING_MAX_LEN) {
    return new Error("Expected Dimension value for name ".concat(name, " to be ").concat(DIMENSION_VALUE_STRING_MAX_LEN, " characters or less, but it was ").concat(value.length, " characters"));
  }

  if (value.length < 1) {
    return new Error("Expected Dimension value for name ".concat(name, " to be non-blank"));
  }

  if (!PRINTABLE_ASCII_PATTERN.test(value)) {
    return new Error("Expected Dimension value for name ".concat(name, " to contain only ASCII characters, but it was ").concat(value));
  }

  if (!AT_LEAST_ONE_NON_WHITESPACE_PATTERN.test(value)) {
    return new Error("Expected Dimension value for name ".concat(name, " to contain at least one non whitespace character, but it was ").concat(value, "}"));
  } // Couldn't find anything wrong, implicitly return undefined

}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CloudWatchDimensions", {
  enumerable: true,
  get: function get() {
    return _CloudWatchDimensions.CloudWatchDimensions;
  }
});
Object.defineProperty(exports, "Context", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsContext.default;
  }
});
Object.defineProperty(exports, "ErrorHandler", {
  enumerable: true,
  get: function get() {
    return _ErrorHandler.ErrorHandler;
  }
});
exports.Metric = void 0;
Object.defineProperty(exports, "MetricsDriver", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsDriver.default;
  }
});
Object.defineProperty(exports, "Publisher", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsPublisher.default;
  }
});

var Metric = _interopRequireWildcard(__webpack_require__(/*! ./metricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/index.js"));

exports.Metric = Metric;

var _KatalMetricsPublisher = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsPublisher */ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _KatalMetricsDriver = _interopRequireDefault(__webpack_require__(/*! ./driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _ErrorHandler = __webpack_require__(/*! ./driver/ErrorHandler */ "./node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js");

var _CloudWatchDimensions = __webpack_require__(/*! ./types/CloudWatchDimensions */ "./node_modules/@amzn/katal-metrics/lib/types/CloudWatchDimensions.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Counter type.
 *
 * Can be used to count the number of times an event happened on a page, or as a simple 1/0 counter to track
 * success and failure.
 */
var KatalMetricCounter = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricCounter, _KatalMetricObject);

  var _super = _createSuper(KatalMetricCounter);

  /**
   * Create a new counter with the given name and value.
   *
   * @param name Counter name
   * @param value Counter value
   */
  function KatalMetricCounter(name) {
    var _this;

    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck2.default)(this, KatalMetricCounter);
    _this = _super.call(this, name);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this counter
   *
   * @return Counter value
   */


  (0, _createClass2.default)(KatalMetricCounter, [{
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set a new value for this counter
     *
     * @param value New value for this counter
     */
    ,
    set: function set(value) {
      // Math.round will also coerce from a string if necessary, and return NaN if invalid
      this._value = Math.round(value);
    }
    /**
     * Gets the type for this counter.
     *
     * @return Always returns "Counter".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Counter;
    }
    /**
     * Add a number to this counter.
     *
     * Can also be negative to subtract.
     *
     * @param addValue Amount to add to this counter
     */

  }, {
    key: "add",
    value: function add(addValue) {
      this.value += addValue;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricCounter.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Counter metrics object '".concat(this.name, "'"));
    }
  }]);
  return KatalMetricCounter;
}(_KatalMetricObject2.default);

exports.default = KatalMetricCounter;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Standardized metric for instrumenting HTTP requests.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name you provide prefixed with "HTTPRequest.".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * It has additional properties which will be emitted if set; see url, statusCode, and statusText.
 *
 * For example, if you gave the name "Search", these metrics will be created:
 *   HTTPRequest.Search.Latency - Latency for this request
 *   HTTPRequest.Search.Failure - Failure for this request (1 for failure, 0 for success)
 */
var KatalMetricHttpRequest = /*#__PURE__*/function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricHttpRequest, _KatalMetricTimedAtte);

  var _super = _createSuper(KatalMetricHttpRequest);

  /** The prefix for this metric. */

  /** The suffix for URL metrics of this class. */

  /** The suffix for HTTP response code metrics of this class. */

  /** The suffix for HTTP response text metrics of this class. */

  /**
   * Create a new HTTP Request timed attempt metric incorporating the given name.
   *
   * The name you give will be used to create a KatalMetricTimedAttempt with the provided name prefixed with "HTTPRequest.".
   *
   * @param name Name of this metric; resulting metrics will prefix this name with "HTTPRequest."
   */
  function KatalMetricHttpRequest(name) {
    (0, _classCallCheck2.default)(this, KatalMetricHttpRequest);
    return _super.call(this, "".concat(KatalMetricHttpRequest.HTTP_REQUEST_PREFIX, ".").concat(name));
  }
  /**
   * Set the url for this metric.
   *
   * A string metric will be added to the list of objects that will be published for this metric.  Its name will
   * be this metrics name suffixed with '.URL', and its value will be the URL value given here.
   *
   * @param value URL for this metric
   */


  (0, _createClass2.default)(KatalMetricHttpRequest, [{
    key: "url",
    get:
    /**
     * Get the URL for this metric, if defined.
     *
     * @return The URL for this metric, or undefined
     */
    function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Get the URL metric object associated with this metric, if defined.
     *
     * @return Associated URL metric object, or undefined
     */
    ,
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX, _KatalMetricString.default, value);
    }
  }, {
    key: "urlMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Set the HTTP response status code for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusCode', and its value will be the status code value given here.
     *
     * @param value HTTP response status code for this metric
     */

  }, {
    key: "statusCode",
    get:
    /**
     * Get the HTTP response status code for this metric, if defined.
     *
     * @return Associated HTTP response status code metric object, or undefined
     */
    function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Get the HTTP response status code metric object associated with this metric, if defined.
     *
     * @return HTTP response status code metric object, or undefined
     */
    ,
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX, _KatalMetricString.default, value);
    }
  }, {
    key: "statusCodeMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Set the HTTP response status text for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusText', and its value will be the status text value given here.
     *
     * @param statusText HTTP response status text for this metric, or undefined to remove
     */

  }, {
    key: "statusText",
    get:
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */
    function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */
    ,
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX, _KatalMetricString.default, value);
    }
  }, {
    key: "statusTextMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
  }]);
  return KatalMetricHttpRequest;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricHttpRequest;
(0, _defineProperty2.default)(KatalMetricHttpRequest, "HTTP_REQUEST_PREFIX", 'HTTPRequest');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "URL_SUFFIX", 'URL');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_CODE_SUFFIX", 'StatusCode');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_TEXT_SUFFIX", 'StatusText');

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Standardized metric for instrumenting application initialization.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name "Initialization".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * By default, these metrics will be created:
 *   Initialization.Latency - Latency for application initialization
 *   Initialization.Failure - Failure for this application initialization (1 for failure, 0 for success)
 */
var KatalMetricInitialization = /*#__PURE__*/function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricInitialization, _KatalMetricTimedAtte);

  var _super = _createSuper(KatalMetricInitialization);

  /** The name for this metric. */

  /**
   * Create a new timed attempt metric named "Initialization", for recording latency and failure information about
   * your application's initialization.
   */
  function KatalMetricInitialization() {
    (0, _classCallCheck2.default)(this, KatalMetricInitialization);
    return _super.call(this, KatalMetricInitialization.INITIALIZE_METRIC_NAME);
  }

  return KatalMetricInitialization;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricInitialization;
(0, _defineProperty2.default)(KatalMetricInitialization, "INITIALIZE_METRIC_NAME", 'Initialization');

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObjectList */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js"));

var _ObjectValuesPonyfill = _interopRequireDefault(__webpack_require__(/*! ../helper/ObjectValuesPonyfill */ "./node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Metric object list that tracks metrics by name, and generates metrics prefixed with the name of this object.
 */
var KatalMetricNamedObjectList = /*#__PURE__*/function (_KatalMetricObjectLis) {
  (0, _inherits2.default)(KatalMetricNamedObjectList, _KatalMetricObjectLis);

  var _super = _createSuper(KatalMetricNamedObjectList);

  /**
   * Create a new named object list.
   *
   * The name given here will be used to prefix all metrics.
   *
   * @param name Name of this metric
   */
  function KatalMetricNamedObjectList(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricNamedObjectList);
    _this = _super.call(this, name);
    _this.namedMetrics = {};
    return _this;
  }

  (0, _createClass2.default)(KatalMetricNamedObjectList, [{
    key: "metricList",
    get: function get() {
      return (0, _ObjectValuesPonyfill.default)(this.namedMetrics);
    }
    /**
     * Replace the metric with the given name with a new metric generated by the given function.
     *
     * If the newly created metric supports monitoring, its isMonitor flag will be set to the value of the
     * isMonitor flag for this containing object.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     */

  }, {
    key: "setNamedMetric",
    value: function setNamedMetric(subName, metricCreator) {
      var fullName = this.getNameForSubMetric(subName);
      var metric = metricCreator(fullName);

      if (metric.canMonitor) {
        metric.isMonitor = this.isMonitor;
      }

      this.namedMetrics[subName] = metric;
    }
    /**
     * If the given value is undefined or null, delete the metric with the give name; otherwise if the given named
     * metric already exists update its value; otherwise create a new metric of the given type and set its value.
     *
     * This specialized helper method is designed to deal with the common case of a value setter in a more complex
     * metric.  Outside of subclasses, other methods will probably prove more useful.
     *
     * If the value is null the metric will also be deleted.
     *
     * @param subName Name of metric to create or delete
     * @param newValueClass Class of new metric to create
     * @param newValue New value for this metric (or undefined to delete the metric)
     */

  }, {
    key: "setOrDeleteNamedMetricValue",
    value: function setOrDeleteNamedMetricValue(subName, newValueClass, newValue) {
      if (newValue == undefined) {
        this.deleteNamedMetric(subName);
      } else {
        var metric = this.getOrCreateNamedMetric(subName, function (name) {
          return new newValueClass(name, newValue);
        });
        metric.value = newValue;
      }
    }
    /**
     * Get the sub-metric with the given name if it exists, otherwise use the given function to create a new metric and
     * store and return that.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     * @return Metric object which was retrieved or created
     */

  }, {
    key: "getOrCreateNamedMetric",
    value: function getOrCreateNamedMetric(subName, metricCreator) {
      if (!this.namedMetrics[subName]) {
        this.setNamedMetric(subName, metricCreator);
      }

      return this.namedMetrics[subName];
    }
    /**
     * Return the given named sub-metric, if it exists.
     *
     * @param {string} subName Name of this sub-metric
     * @return {KatalMetricObject | undefined} Metric object with this name if it exists, otherwise undefined
     */

  }, {
    key: "getNamedMetric",
    value: function getNamedMetric(subName) {
      return this.namedMetrics[subName];
    }
    /**
     * Delete the given named sub-metric.
     *
     * @param subName Name of this sub-metric
     */

  }, {
    key: "deleteNamedMetric",
    value: function deleteNamedMetric(subName) {
      delete this.namedMetrics[subName];
    }
    /**
     * Get the value for the given metric, or undefined if the metric does not exist.
     *
     * @param subName Name of this sub-metric
     * @return Value for the given metric, or undefined if the metric does not exist
     */

  }, {
    key: "getNamedMetricValue",
    value: function getNamedMetricValue(subName) {
      var metric = this.getNamedMetric(subName);
      if (!metric) return undefined;
      return metric.value;
    }
    /**
     * Generate a name for the given sub-metric.
     *
     * @param subName Name of this sub-metric
     * @return Full name for this sub-metric
     */

  }, {
    key: "getNameForSubMetric",
    value: function getNameForSubMetric(subName) {
      return "".concat(this.name, ".").concat(subName);
    }
  }]);
  return KatalMetricNamedObjectList;
}(_KatalMetricObjectList.default);

exports.default = KatalMetricNamedObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleString */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricType */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

/**
 * Abstract base class for a single metric in Katal.
 *
 * A single metric contains the name (metricKey), value, type, and the isMonitor flag; everything else is in the
 * KatalMetricsContext it is published to.
 */
var KatalMetricObject = /*#__PURE__*/function () {
  /**
   * Metric types.
   */

  /**
   * Create a new KatalMetricObject with the given name.
   *
   * @param name Name for this metric; published as metricKey field
   */
  function KatalMetricObject(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObject);
    this._name = name;
    this._isMonitor = false;
  }
  /**
   * Get the name for this metric.
   *
   * Note that the name is immutable, and this cannot be set.
   *
   * @returns Name for this metric
   */


  (0, _createClass2.default)(KatalMetricObject, [{
    key: "name",
    get: function get() {
      return this._name;
    }
    /**
     * Alias for name.
     *
     * @returns Name for this metric
     */

  }, {
    key: "metricKey",
    get: function get() {
      return this._name;
    }
    /**
     * Set the isMonitor flag for this metric, and returns this object for continued use.
     *
     * This flag determines if the metric can be used for dashboards and alarms (i.e. if it will be published to PMET)
     * @param isMonitor New value for the isMonitor flag; defaults to true
     * @returns This object
     */

  }, {
    key: "withMonitor",
    value: function withMonitor() {
      var isMonitor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.isMonitor = isMonitor;
      return this;
    }
    /**
     * Set the isMonitor flag for this metric.
     *
     * The value is forced to a boolean based on its truthiness.
     *
     * @param isMonitor New value for the isMonitor flag
     */

  }, {
    key: "isMonitor",
    get:
    /**
     * Get the isMonitor flag for this metric.
     *
     * @returns isMonitor flag for this metric.
     */
    function get() {
      return this._isMonitor;
    }
    /**
     * Check if this metric can be meaningfully monitored.
     *
     * Subclasses must override this.
     *
     * @return Whether this metric can be meaningfully monitored
     */
    ,
    set: function set(isMonitor) {
      this._isMonitor = !!isMonitor;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement canMonitor');
    }
    /**
     * Get the type of this metric.
     *
     * @return Type of this metric (one of: String, Counter, Timer, List)
     */

  }, {
    key: "type",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement type getter');
    }
    /**
     * Check for a validation error on this object.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns {Error | undefined} Error found with this object, or undefined if no error is found
     */

  }, {
    key: "validationError",
    value: function validationError() {
      if (this.isMonitor !== undefined && typeof this.isMonitor !== 'boolean') {
        return new Error("Field isMonitor should be a boolean, but it was a ".concat((0, _typeof2.default)(this.isMonitor)));
      }

      return (0, _ValidateSimpleString.default)(this.name, 'field name');
    }
  }]);
  return KatalMetricObject;
}();

exports.default = KatalMetricObject;
(0, _defineProperty2.default)(KatalMetricObject, "Types", _KatalMetricType.default);

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@babel/runtime/helpers/set.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ../helper/FirstMap */ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Abstract metric that contains a list of other metrics; when it is published, the list of metrics is retrieved, and all
 * are published.
 */
var KatalMetricObjectList = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricObjectList, _KatalMetricObject);

  var _super = _createSuper(KatalMetricObjectList);

  /**
   * Create a new KatalMetricObjectList.
   *
   * @param name Name for this metric.  Not really used, but present for consistency with other metrics.
   */
  function KatalMetricObjectList(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObjectList);
    return _super.call(this, name);
  }
  /**
   * Get the list of for this object
   *
   * @returns Array of metrics for this object
   */


  (0, _createClass2.default)(KatalMetricObjectList, [{
    key: "metricList",
    get: function get() {
      throw new Error('Subclass of KatalMetricObjectList must implement metricList getter');
    }
  }, {
    key: "isMonitor",
    get: // This just delegates to the superclass, but if we override the setter without overriding the getter
    // getting the property will always return undefined.
    function get() {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", this);
    },
    set: function set(isMonitor) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", isMonitor, this, true);
      this.metricList.forEach(function (metric) {
        if (metric.canMonitor) {
          metric.isMonitor = isMonitor;
        }
      });
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.List;
    }
    /**
     * If any of the contained metrics are invalid, return the first validation error encountered; otherwise return
     * undefined.
     *
     * Note that this isn't called by the publisher; it validates each sub-metric on its own.
     *
     * @returns Error found with submetric, if any; else undefined
     */

  }, {
    key: "validationError",
    value: function validationError() {
      // Doesn't make sense to check superclass error here, since it is the contained metrics that matter.
      return (0, _FirstMap.default)(this.metricList, function (metric) {
        return metric.validationError();
      });
    }
  }]);
  return KatalMetricObjectList;
}(_KatalMetricObject2.default);

exports.default = KatalMetricObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * String type.
 *
 * Can be used to store arbitrary strings of data.
 */
var KatalMetricString = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricString, _KatalMetricObject);

  var _super = _createSuper(KatalMetricString);

  /**
   * Create a string with the given name and value.
   *
   * @param name String name
   * @param value String value
   */
  function KatalMetricString(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricString);
    _this = _super.call(this, name);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "truncate", false);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this string metric.
   *
   * @return Value for this metric
   */


  (0, _createClass2.default)(KatalMetricString, [{
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this string metric.
     *
     * The new value should be a string, but number and boolean types will be automatically converted to strings.
     * For other types, including undefined and null, the value will be accepted, but will fail validation when publishing.
     *
     * @param value New value for this metric
     */
    ,
    set: function set(value) {
      if (typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
      }

      this._value = value;
    }
    /**
     * Truncation flag for this string metric.
     *
     * If set, the value here will be automatically truncated to the maximum size allowed by the current schema.
     * Otherwise, sending a value larger than allowed will result in a failure.
     *
     * @param value True to automatically truncate metrics, otherwise false
     */

  }, {
    key: "type",
    get:
    /**
     * Gets the type for this metric.
     *
     * @return Always returns "String".
     */
    function get() {
      return _KatalMetricObject2.default.Types.String;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return false;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricString.prototype), "validationError", this).call(this);
      if (superError) return superError;

      if (typeof this.value !== 'string') {
        return new Error("Expected field value in String metrics object '".concat(this.name, "' to be type string, but it was ").concat((0, _typeof2.default)(this.value)));
      }

      if (this.value.length > KatalMetricString.MAX_SIZE) {
        if (this.truncate) {
          this.value = this.value.substring(0, KatalMetricString.MAX_SIZE);
        } else {
          return new Error("Expected field value in String metrics object '".concat(this.name, "' to be ").concat(KatalMetricString.MAX_SIZE, " characters or less, but it was ").concat(this.value.length, " characters."));
        }
      } // Didn't find anything wrong, implicitly return undefined

    }
  }]);
  return KatalMetricString;
}(_KatalMetricObject2.default);

exports.default = KatalMetricString;
(0, _defineProperty2.default)(KatalMetricString, "MAX_SIZE", 256);

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricNamedObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricNamedObjectList */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Metric that pairs a timer and a failure counter to record the time and status of an attempt to do something.
 */
var KatalMetricTimedAttempt = /*#__PURE__*/function (_KatalMetricNamedObje) {
  (0, _inherits2.default)(KatalMetricTimedAttempt, _KatalMetricNamedObje);

  var _super = _createSuper(KatalMetricTimedAttempt);

  /** The sub-metric name for latency. */

  /** The sub-metric name for failure count. */

  /**
   * Create a new timed attempt with the given name
   *
   * This will create two inner metrics, a KatalMetricCounter that has the given name with ".Failure" appended,
   * and a KatalMetricTimerStopwatch that has the given name with ".Latency" appended.
   *
   * @param name Name of this attempt
   */
  function KatalMetricTimedAttempt(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimedAttempt);
    _this = _super.call(this, name);

    _this.setNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX, function (name) {
      return new _KatalMetricTimerStopwatch.default(name);
    });

    _this.setNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX, function (name) {
      return new _KatalMetricCounter.default(name, 1);
    });

    return _this;
  }
  /**
   * Set the failure counter metric based on the given failure status.
   *
   * If failure is true the counter will have a value of 1; if it is false the counter will have a value of 0.
   *
   * @param failure Whether this is a failure or not; default true
   */


  (0, _createClass2.default)(KatalMetricTimedAttempt, [{
    key: "setFailure",
    value: function setFailure() {
      var failure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var failureCount = failure ? 1 : 0;
      var metric = this.failureMetric;
      metric.value = failureCount;
    }
    /**
     * Set the failure status to false.
     */

  }, {
    key: "setSuccess",
    value: function setSuccess() {
      this.setFailure(false);
    }
    /**
     * Set the latency metric to the given value, in milliseconds.
     *
     * Note you don't normally have to set this, the underlying metric is a KatalMetricTimerStopwatch that will start
     * and stop automatically.
     *
     * @param latencyMs Latency in milliseconds
     */

  }, {
    key: "setLatency",
    value: function setLatency(latencyMs) {
      var metric = this.latencyMetric;
      metric.value = latencyMs;
    }
    /**
     * Get the timer stopwatch metric for this attempt.
     *
     * @return Timer stopwatch metric for this attempt
     */

  }, {
    key: "latencyMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX);
    }
    /**
     * Get the failure counter metric for this attempt.
     *
     * @return Failure counter metric for this event
     */

  }, {
    key: "failureMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX);
    }
  }]);
  return KatalMetricTimedAttempt;
}(_KatalMetricNamedObjectList.default);

exports.default = KatalMetricTimedAttempt;
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "LATENCY_SUFFIX", 'Latency');
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "FAILURE_SUFFIX", 'Failure');

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Timer type.
 *
 * Can be used to record a time.  This class requires explicit value; see KatalMetricTimerStopwatch for automatic
 * timing.
 */
var KatalMetricTimer = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricTimer, _KatalMetricObject);

  var _super = _createSuper(KatalMetricTimer);

  /**
   * Create a new timer metric.
   *
   * @param name Name for the metric
   * @param value Timer value in milliseconds
   */
  function KatalMetricTimer(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimer);
    _this = _super.call(this, name);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this timer
   *
   * @return Timer value in milliseconds
   */


  (0, _createClass2.default)(KatalMetricTimer, [{
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this timer
     *
     * @param value New timer value in milliseconds
     */
    ,
    set: function set(value) {
      if (value == undefined) {
        this._value = value;
        return;
      } // Math.round will also coerce from a string if necessary, and return NaN if invalid


      this._value = Math.round(value);
    }
    /**
     * Get the type for this timer.
     *
     * @return Always returns "Timer".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Timer;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimer.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Timer metrics object '".concat(this.name, "'"));
    }
  }]);
  return KatalMetricTimer;
}(_KatalMetricObject2.default);

exports.default = KatalMetricTimer;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@babel/runtime/helpers/set.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricTimer2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Subclass of KatalMetricTimer that can be started and stopped, and will record the elapsed time between starting and
 * stopping.  By default it will start when the object is created, and stopped when the value is retrieved with
 * the getter "value".
 */
var KatalMetricTimerStopwatch = /*#__PURE__*/function (_KatalMetricTimer) {
  (0, _inherits2.default)(KatalMetricTimerStopwatch, _KatalMetricTimer);

  var _super = _createSuper(KatalMetricTimerStopwatch);

  /**
   * Create a new timer with the given name and starting time.  If no starting time is given, the current time is used.
   *
   * @param name Name for this timer
   * @param startTime Millisecond epoch time for the start time; defaults to now
   */
  function KatalMetricTimerStopwatch(name, startTime) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimerStopwatch);
    _this = _super.call(this, name, undefined);

    _this.start(startTime);

    _this._value = undefined;
    return _this;
  }
  /**
   * Re-start timer with the given start time, or the current time if none is given.
   *
   * @param startTime When the timer was started, in epoch milliseconds; defaults to now
   */


  (0, _createClass2.default)(KatalMetricTimerStopwatch, [{
    key: "start",
    value: function start(startTime) {
      this._startTime = startTime || this.now();
    }
    /**
     * Stop the timer and record the elapsed time.
     *
     * @param stopTime When the timer was stopped, in epoch milliseconds; defaults to now
     */

  }, {
    key: "stop",
    value: function stop(stopTime) {
      return this._stopTime = stopTime || this.now();
    }
    /**
     * Check if the timer has been stopped.
     *
     * @returns Whether the timer has been stopped yet
     */

  }, {
    key: "isStopped",
    get: function get() {
      return this._stopTime !== undefined;
    }
    /**
     * Get the elapsed time between when the timer was started and stopped; if the timer has not yet been stopped,
     * stop it first.
     *
     * @returns Elapsed time between when timer was started and stopped
     */

  }, {
    key: "value",
    get: function get() {
      if ((0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this) === undefined) {
        if (!this.isStopped) {
          this.stop();
        } // Rely on super.value setter to round


        (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this.stopTime - this.startTime, this, true);
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this);
    }
    /**
     * Get when this timer was started.
     *
     * @return Start time, in epoch milliseconds
     */
    ,
    set:
    /**
     * Set the value for this metric.  Note this will override the stopwatch behavior and just use the given value.
     *
     * @param value Value for this metric
     */
    function set(value) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", value, this, true);
    }
  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    }
    /**
     * Get when this timer was stopped (or undefined if it is still running)
     *
     * @return Stop time, in epoch millseconds, or undefined if the stopwatch is still running
     */

  }, {
    key: "stopTime",
    get: function get() {
      return this._stopTime;
    }
  }, {
    key: "now",
    value: function now() {
      return performance.now();
    }
  }]);
  return KatalMetricTimerStopwatch;
}(_KatalMetricTimer2.default);

exports.default = KatalMetricTimerStopwatch;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Metric types.
 */
var KatalMetricType;

(function (KatalMetricType) {
  KatalMetricType["String"] = "String";
  KatalMetricType["Counter"] = "Counter";
  KatalMetricType["Timer"] = "Timer";
  KatalMetricType["List"] = "List";
})(KatalMetricType || (KatalMetricType = {}));

;
var _default = KatalMetricType;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Counter", {
  enumerable: true,
  get: function get() {
    return _KatalMetricCounter.default;
  }
});
Object.defineProperty(exports, "HttpRequest", {
  enumerable: true,
  get: function get() {
    return _KatalMetricHttpRequest.default;
  }
});
Object.defineProperty(exports, "Initialization", {
  enumerable: true,
  get: function get() {
    return _KatalMetricInitialization.default;
  }
});
Object.defineProperty(exports, "Object", {
  enumerable: true,
  get: function get() {
    return _KatalMetricObject.default;
  }
});
Object.defineProperty(exports, "String", {
  enumerable: true,
  get: function get() {
    return _KatalMetricString.default;
  }
});
Object.defineProperty(exports, "TimedAttempt", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimedAttempt.default;
  }
});
Object.defineProperty(exports, "Timer", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimer.default;
  }
});
Object.defineProperty(exports, "TimerStopwatch", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimerStopwatch.default;
  }
});

var _KatalMetricObject = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

var _KatalMetricTimer = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricInitialization = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricInitialization */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js"));

var _KatalMetricHttpRequest = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricHttpRequest */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js"));

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/types/CloudWatchDimensions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/types/CloudWatchDimensions.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "./node_modules/@amzn/katal-sushi-client/dist/SushiClient.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@amzn/katal-sushi-client/dist/SushiClient.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This class encapsulates two IIFEs that the Sushi library contains. A fake CSM and Window object are created and provided
 * to the functions so that they actually execute in a controlled environment away from any CSM code that might be executing
 * at the platform level within the page.
 *
 * The basic run order is the following:
 * 1. Build the mock CSM object, then build a mock Window object that references the CSM object as ue_csm
 * 2. Run the transportation-clients.js Script from SushiJavascriptClient providing the mocks. It will modify globals on the mock objects.
 * 3. Run the sushi-client.js script from SushiJavaScriptClient providing the mocks. It will create an instance of the sushi client and inject it into the CSM globals in the mocks.
 * 4. whenever event() is called, refer to the encapsulated csm object to add the event to the queue.
 */
var SushiClient =
/*#__PURE__*/
function () {
  (0, _createClass2.default)(SushiClient, null, [{
    key: "createSushiUrl",
    value: function createSushiUrl(region, sourceGroup) {
      if (!sourceGroup) {
        throw new Error("Sushi Driver was not provided with a source group.");
      }

      var domain;

      switch (region) {
        case SushiClient.REGIONS.NA:
          domain = "unagi-na";
          break;

        case SushiClient.REGIONS.EU:
          domain = "unagi-eu";
          break;

        case SushiClient.REGIONS.FE:
          domain = "unagi-fe";
          break;

        case SushiClient.REGIONS.CN:
          domain = "unagi-cn";
          break;

        default:
          throw new Error("Unrecognized region '".concat(region, "' provided to SushiClient."));
      }

      return "https://".concat(domain, ".amazon.com/1/events/").concat(sourceGroup);
    }
  }, {
    key: "createCsmUserContext",
    value: function createCsmUserContext(sushiUrl) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _objectSpread({
        hiPriFlushInterval: 1000,
        lowPriFlushInterval: 10000,
        requestId: "1",
        errorChannel: "jserr",
        sessionStorageWrapper: undefined,
        errorHandlerFunction: console.log,
        sushiUrl: sushiUrl
      }, options);
    }
    /**
     * Create a Sushi Client for a region and source group
     *
     * @param region Region in SushiClient.REGIONS
     * @param sourceGroup Sushi Eel source group
     * @param errorHandler Error handler function
     * @param options Additional CSM context overrides
     * @param clientOverride An optional transportation client for overriding the default clients (navigator.sendBeacon and XDomainRequest or XMLHttpRequest)
     */

  }, {
    key: "REGIONS",
    get: function get() {
      return {
        NA: "NA",
        EU: "EU",
        FE: "FE",
        CN: "CN"
      };
    }
  }]);

  function SushiClient() {
    var region = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SushiClient.REGIONS.NA;
    var sourceGroup = arguments.length > 1 ? arguments[1] : undefined;
    var errorHandler = arguments.length > 2 ? arguments[2] : undefined;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var clientOverride = arguments.length > 4 ? arguments[4] : undefined;
    (0, _classCallCheck2.default)(this, SushiClient);
    var sushiUrl = SushiClient.createSushiUrl(region, sourceGroup);
    var csmUserContext = SushiClient.createCsmUserContext(sushiUrl, options);
    this.ue_csm = this.setupMockCSMObject(csmUserContext);
    this.encapsulatedWindow = this.setupMockWindow(this.ue_csm);
    this.transportationClientCode(this.ue_csm, window);

    if (clientOverride) {
      this.ue_csm.ue._sBcn = {
        isSupported: true,
        send: function send(endpoint, payload) {
          clientOverride(endpoint, payload);
          return true;
        }
      };
    }

    this.clientCode(this.ue_csm, this.encapsulatedWindow);
    this.errorHandler = errorHandler;
  }

  (0, _createClass2.default)(SushiClient, [{
    key: "event",
    value: function event(data, producerId, schemaId, options) {
      var debug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      if (debug) {
        console.log("SushiClient wrapper publishing the following:", {
          data: data,
          producerId: producerId,
          schemaId: schemaId,
          options: options
        });
      }

      return this.ue_csm.ue.event(data, producerId, schemaId, options);
    }
    /**
     * If you plan to emit 1000 or more events per instantiated client,
     * call reset after calling event to allow the CSM client to continue sending events.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.ue_csm.ue.event.reset();
    }
    /**
     * Register a callback that will be called just before each time metrics are
     * flushed to the network.
     * @param callback A function that sushi will call before flushes.
     */

  }, {
    key: "onSushiFlush",
    value: function onSushiFlush(callback) {
      this.ue_csm.ue.onSushiFlush(callback);
    }
    /**
     * Register a callback that will be called just before the page unloads.
     * This can be used to send any final metrics to sushi, such as page visit
     * duration or batched counters.
     * @param callback A function that sushi will call before unload.
     */

  }, {
    key: "onSushiUnload",
    value: function onSushiUnload(callback) {
      this.ue_csm.ue.onSushiUnload(callback);
    }
  }, {
    key: "setupMockCSMObject",
    value: function setupMockCSMObject(csmUserContext) {
      var _this = this;

      var execStub = function execStub(callback, attribution) {
        return callback;
      };

      var eventStub = function eventStub(log, producer, eventType) {
        console.warn("SushiClient CSM stub called in unsupported manner: event()");
      };

      var errorHandler = function errorHandler(logEvent, channel) {
        if (_this.errorHandler) {
          _this.errorHandler(logEvent);
        } else {
          console.log("An error has occurred in SushiClient channel " + channel, logEvent);
        }
      };

      var attachHandler = function attachHandler(evt, handler, container) {
        //TODO might be able to just use window.ue.attach?
        container = container || window; //ok to use real window global here.

        if (window.EventTarget && window.EventTarget.prototype && window.EventTarget.prototype.addEventListener) {
          window.EventTarget.prototype.addEventListener.call(container, evt, handler, !!window.ue_clf);
        } else if (container.addEventListener) {
          container.addEventListener(evt, handler, !!window.ue_clf);
        } else if (container.attachEvent) {
          container.attachEvent("on" + evt, handler);
        }
      };

      return {
        ue_hpsi: csmUserContext.hiPriFlushInterval,
        ue_lpsi: csmUserContext.lowPriFlushInterval,
        ue: {
          ssw: csmUserContext.sessionStorageWrapper,
          log: errorHandler,
          exec: execStub,
          event: eventStub,
          attach: attachHandler
        },
        ueLogError: csmUserContext.errorHandlerFunction,
        ue_surl: csmUserContext.sushiUrl,
        ue_id: csmUserContext.requestId,
        ue_err_chan: csmUserContext.errorChannel
      };
    }
  }, {
    key: "setupMockWindow",
    value: function setupMockWindow(ue_csm) {
      //apparently cannot ref the setTimeout function directly in some browsers so we have to wrap it.
      var timeoutWrapper = function timeoutWrapper(fn, timeout) {
        return window.setTimeout(fn, timeout);
      };

      return {
        ue_csm: ue_csm,
        ueLogError: ue_csm.ueLogError,
        ue: ue_csm.ue,
        setTimeout: timeoutWrapper
      };
    }
    /**
     * Code within function pulled directly from
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/sushi-client.js
     */

  }, {
    key: "clientCode",
    value: function clientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, k) {
        function A() {
          for (var a = 0; a < arguments.length; a++) {
            var c = arguments[a];

            try {
              var h;

              if (c.isSupported) {
                var b = t.buildPayload(l, e);
                h = c.send(J, b);
              } else throw dummyException;

              return h;
            } catch (d) {}
          }

          B({
            m: "All supported clients failed",
            attribution: "CSMSushiClient_TRANSPORTATION_FAIL",
            f: "sushi-client.js",
            logLevel: "ERROR"
          }, k.ue_err_chan || "jserr");
        }

        function m() {
          if (e.length) {
            for (var a = 0; a < n.length; a++) {
              n[a]();
            }

            A(d._sBcn || {}, d._ajx || {});
            e = [];
            f = {};
            l = {};
            u = v = q = w = 0;
          }
        }

        function K() {
          var a = new Date(),
              c = function c(a) {
            return 10 > a ? "0" + a : a;
          };

          return Date.prototype.toISOString ? a.toISOString() : a.getUTCFullYear() + "-" + c(a.getUTCMonth() + 1) + "-" + c(a.getUTCDate()) + "T" + c(a.getUTCHours()) + ":" + c(a.getUTCMinutes()) + ":" + c(a.getUTCSeconds()) + "." + String((a.getUTCMilliseconds() / 1E3).toFixed(3)).slice(2, 5) + "Z";
        }

        function x(a) {
          try {
            return JSON.stringify(a);
          } catch (c) {}

          return null;
        }

        function C(a, c, h, g) {
          var p = !1;
          g = g || {};
          r++;
          r == D && B({
            m: "Max number of Sushi Logs exceeded",
            f: "sushi-client.js",
            logLevel: "ERROR",
            attribution: "CSMSushiClient_MAX_CALLS"
          }, k.ue_err_chan || "jserr");
          var f;
          if (f = !(r >= D)) (f = a && -1 < a.constructor.toString().indexOf("Object") && c && -1 < c.constructor.toString().indexOf("String") && h && -1 < h.constructor.toString().indexOf("String")) || L++;
          f && (d.count && d.count("Event:" + h, 1), a.producerId = a.producerId || c, a.schemaId = a.schemaId || h, a.timestamp = K(), c = Date.now ? Date.now() : +new Date(), h = Math.random().toString().substring(2, 12), a.messageId = b.ue_id + "-" + c + "-" + h, g && !g.ssd && (a.sessionId = a.sessionId || b.ue_sid, a.requestId = a.requestId || b.ue_id, a.obfuscatedMarketplaceId = a.obfuscatedMarketplaceId || b.ue_mid), (c = x(a)) ? (c = c.length, (e.length == M || q + c > N) && m(), q += c, a = {
            data: t.compressEvent(a)
          }, e.push(a), (g || {}).n ? 0 === E ? m() : u || (u = k.setTimeout(m, E)) : v || (v = k.setTimeout(m, O)), p = !0) : p = !1);
          !p && b.ue_int && console.error("Invalid JS Nexus API call");
          return p;
        }

        function F() {
          if (!G) {
            for (var a = 0; a < y.length; a++) {
              y[a]();
            }

            for (a = 0; a < n.length; a++) {
              n[a]();
            }

            e.length && (b.ue_sbuimp && b.ue && b.ue.ssw && (a = x({
              dct: l,
              evt: e
            }), b.ue.ssw("eeldata", a), b.ue.ssw("eelsts", "unk")), A(d._sBcn || {}));
            G = !0;
          }
        }

        function H(a) {
          y.push(a);
        }

        function I(a) {
          n.push(a);
        }

        var D = 1E3,
            M = 499,
            N = 524288,
            s = function s() {},
            d = b.ue || {},
            B = d.log || s,
            P = b.uex || s;

        (b.uet || s)("bb", "ue_sushi_v1", {
          wb: 1
        });

        var J = b.ue_surl || "https://unagi-na.amazon.com/1/events/com.amazon.csm.nexusclient.gamma",
            Q = ["messageId", "timestamp"],
            z = "#",
            e = [],
            f = {},
            l = {},
            q = 0,
            w = 0,
            L = 0,
            r = 0,
            y = [],
            n = [],
            G = !1,
            u,
            v,
            E = void 0 === b.ue_hpsi ? 1E3 : b.ue_hpsi,
            O = void 0 === b.ue_lpsi ? 1E4 : b.ue_lpsi,
            t = function () {
          function a(a) {
            f[a] = z + w++;
            l[f[a]] = a;
            return f[a];
          }

          function c(b) {
            if (!(b instanceof Function)) {
              if (b instanceof Array) {
                for (var g = [], d = b.length, e = 0; e < d; e++) {
                  g[e] = c(b[e]);
                }

                return g;
              }

              if (b instanceof Object) {
                g = {};

                for (d in b) {
                  b.hasOwnProperty(d) && (g[f[d] ? f[d] : a(d)] = -1 === Q.indexOf(d) ? c(b[d]) : b[d]);
                }

                return g;
              }

              return "string" === typeof b && (b.length > (z + w).length || b.charAt(0) === z) ? f[b] ? f[b] : a(b) : b;
            }
          }

          return {
            compressEvent: c,
            buildPayload: function buildPayload() {
              return x({
                cs: {
                  dct: l
                },
                events: e
              });
            }
          };
        }();

        (function () {
          if (d.event && d.event.isStub) {
            if (b.ue_sbuimp && b.ue && b.ue.ssw) {
              var a = b.ue.ssw("eelsts").val;

              if (a && "unk" === a && (a = b.ue.ssw("eeldata").val)) {
                var c;

                a: {
                  try {
                    c = JSON.parse(a);
                    break a;
                  } catch (f) {}

                  c = null;
                }

                c && c.evt instanceof Array && c.dct instanceof Object && (e = c.evt, l = c.dct, e && l && (m(), b.ue.ssw("eeldata", "{}"), b.ue.ssw("eelsts", "scs")));
              }
            }

            d.event.replay(function (a) {
              a[3] = a[3] || {};
              a[3].n = 1;
              C.apply(this, a);
            });
            d.onSushiUnload.replay(function (a) {
              H(a[0]);
            });
            d.onSushiFlush.replay(function (a) {
              I(a[0]);
            });
          }
        })();

        d.attach("beforeunload", F);
        d.attach("pagehide", F);
        d._cmps = t;
        d.event = C;

        d.event.reset = function () {
          r = 0;
        };

        d.onSushiUnload = H;
        d.onSushiFlush = I;

        try {
          k.P && k.P.register && k.P.register("sushi-client", s);
        } catch (R) {
          b.ueLogError(R, {
            logLevel: "WARN"
          });
        }

        P("ld", "ue_sushi_v1", {
          wb: 1
        });
      }, "Nxs-JS-Client")(ue_csm, window);
    }
    /**
     * The code in this function is pulled directly from:
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/transportation-clients.js
     */

  }, {
    key: "transportationClientCode",
    value: function transportationClientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, c) {
        var e = function e() {},
            f = function () {
          return {
            send: function send(b, d) {
              if (d && b) {
                var a;
                if (c.XDomainRequest) a = new XDomainRequest(), a.onerror = e, a.ontimeout = e, a.onprogress = e, a.onload = e, a.timeout = 0;else if (c.XMLHttpRequest) {
                  if (a = new XMLHttpRequest(), !("withCredentials" in a)) throw "";
                } else a = void 0;
                if (!a) throw "";
                a.open("POST", b, !0);
                a.setRequestHeader && a.setRequestHeader("Content-type", "text/plain");
                a.send(d);
              }
            },
            isSupported: !0
          };
        }(),
            g = function () {
          return {
            send: function send(c, d) {
              if (c && d) if (navigator.sendBeacon(c, d)) b.ue_sbuimp && b.ue && b.ue.ssw && b.ue.ssw("eelsts", "scs");else throw "";
            },
            isSupported: !!navigator.sendBeacon && !(c.cordova && c.cordova.platformId && "ios" == c.cordova.platformId)
          };
        }();

        b.ue._ajx = f;
        b.ue._sBcn = g;
      }, "Transportation-clients")(ue_csm, window);
    }
  }]);
  return SushiClient;
}();

exports.default = SushiClient;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/get.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/get.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@babel/runtime/helpers/superPropBase.js");
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
  return _get.apply(this, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/set.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/set.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@babel/runtime/helpers/superPropBase.js");
var defineProperty = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set(target, property, value, receiver) {
      var base = superPropBase(target, property);
      var desc;
      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.set) {
          desc.set.call(receiver, value);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }
      desc = Object.getOwnPropertyDescriptor(receiver, property);
      if (desc) {
        if (!desc.writable) {
          return false;
        }
        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else {
        defineProperty(receiver, property, value);
      }
      return true;
    };
  }
  return set(target, property, value, receiver);
}
function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);
  if (!s && isStrict) {
    throw new TypeError('failed to set property');
  }
  return value;
}
module.exports = _set, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/superPropBase.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/superPropBase.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");
var iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");
var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/toPrimitive.js");
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(o) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/build-url-ts/dist/build-url.js":
/*!*****************************************************!*\
  !*** ./node_modules/build-url-ts/dist/build-url.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
function buildQueryString(r,n,a){var o=[];for(var t in r)!function(t){var e;Object.prototype.hasOwnProperty.call(r,t)&&void 0!==r[t]&&(a&&Array.isArray(r[t])&&r[t].length?r[t].forEach(function(r){e=0!==r?r||"":0,o.push("".concat(t,"=").concat(encodeURIComponent(String(e).trim())))}):(e=n?String(r[t]).toLowerCase()||"":0!==r[t]?r[t]||"":0,o.push("".concat(t,"=").concat(encodeURIComponent(String(e).trim())))))}(t);return"?".concat(o.join("&"))}function appendPath(r,t,e){void 0===t&&(t=""),"/"===t[t.length-1]&&(t=t.slice(0,-1));var n=String(r).trim();return e&&(n=n.toLowerCase()),0===n.indexOf("/")?t+=n:t+="/".concat(n),t}function buildHash(r,t){var e="#".concat(String(r).trim());return t?e.toLowerCase():e}function buildUrl(r,t){var e;return null===r?e="":"object"==typeof r?(e="",t=r):e=r,null!=t&&t.path&&(e=appendPath(t.path,e,t.lowerCase)),null!=t&&t.queryParams&&(e+=buildQueryString(t.queryParams,t.lowerCase,t.disableCSV)),null!=t&&t.hash&&(e+=buildHash(t.hash,t.lowerCase)),e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.appendPath=appendPath,exports.buildHash=buildHash,exports.buildQueryString=buildQueryString,exports.buildUrl=buildUrl,exports.default=buildUrl;
//# sourceMappingURL=build-url.js.map


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/iframe.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/iframe.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "#aa-challenge-whole-page-iframe {\n    overflow:hidden;\n    opacity:1.0;\n    position:fixed;\n    top:0px;\n    bottom:0px;\n    right:0px;\n    border:none;\n    margin:0;\n    padding:0;\n    height:100%;\n    width:100%;\n    z-index:999999;\n}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ __webpack_exports__["default"] = (index);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/HostnameResolver.ts":
/*!*********************************!*\
  !*** ./src/HostnameResolver.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var HostnameResolver=function(){var _Il=['\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x61\x65','\x70\x6c','\x74\x72','\x61\x65\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x61\x75','\x73\x61\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x65\x67','\x73\x65','\x69\x6e\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x61\x74','\x61\x65','\x62\x72\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x2e\x75\x6b','\x61\x75\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x67','\x6e\x6c','\x62\x6c\x6f\x62','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x73\x61','\x65\x73\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x6d\x78','\x6d\x78\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x63\x61\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x64\x65\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x65\x73','\x65\x73\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6e\x6c\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x6c\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x61\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x66\x72',22386,'\x66\x72','\x6a\x70\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x74\x72\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x75\x6b\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x75\x6b\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x6c\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x78\x63\x6f\x72\x70\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x74\x72','\x6a\x70','\x62\x6c\x6f\x62\x45\x6e\x63\x72\x79\x70\x74','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x62\x72','\x64\x65','\x69\x6e','\x62\x72\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x74\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x74\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x69\x74','\x62\x72','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x73\x65','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x2e\x6a\x70','\x63\x61','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x61','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x65\x67','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x73\x67','\x75\x6b','\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x65\x75','\x61\x75\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x66\x72\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x65\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x75','\x65\x67\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x74','\x6a\x70\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x65\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x78\x63\x6f\x72\x70\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x65\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6d\x78','\x65\x73','\x65\x67\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x6e\x6c','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x69\x6e','\x74\x72\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x67\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x75\x73','\x63\x61\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6d\x78\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x6e\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x70\x6c','\x64\x65\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x64\x65','\x66\x72\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x74','\x61\x74\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x61','\x73\x67\x2d\x70\x72\x65\x70\x72\x6f\x64\x2e\x70\x64\x78\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6e\x6c\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x74\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d'];function HostnameResolver(){}HostnameResolver.getServiceHostnameByConfiguration=function(configuration){var _1Ll=[.467530776752656,'\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x62\x6c\x6f\x62\x46\x77\x63\x69\x6d'];var _QOoQ0oO0=function(_LL11ILlI){var _$z=[31448,28310,'\x6f\x62\x66\x75\x73\x63\x61\x74\x65\x4c\x69\x73\x74','\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x44\x6f\x6d\x41\x6d\x61\x7a\x6f\x6e','\x64\x6f\x63\x75\x6d\x65\x6e\x74\x4c\x69\x73\x74',.6224037153540378];var _Ll11Liil=_$z[3],_Oo0O00OO=_$z[5];var _IL1Iill1=_$z[0],_iIIIL1lL=_$z[4];var _oOO0QQ0Q=_$z[1];return _$z[2];};if(configuration in HostnameResolver.DOMAIN_REALM_HOSTNAME){var _Z2ZZsss$=_1Ll[2],_iIl11iLi=_1Ll[0];return HostnameResolver.DOMAIN_REALM_HOSTNAME[configuration];}else{return _1Ll[1];}};HostnameResolver.getServiceHostnameByHostname=function(hostname){var _O0O=['\x62\x6c\x6f\x62','\x6d\x61\x73\x74\x65\x72','\x70\x72\x6f\x64','\x6c\x69\x73\x74\x45\x6c',.39037469599676955,'\x74\x65\x73\x74',.8315583805167002];if(HostnameResolver.isDevelopment(hostname)){var _0OOoO0Oo=_O0O[4],_oQQOoo00=_O0O[6],_IlIlLlil=_O0O[0];return this.getServiceHostByCountryCode(_O0O[5],this.getCountryCodePrefix(hostname));}else if(HostnameResolver.isPreProd(hostname)){var _2$S2ZzZ2=_O0O[3];return this.getServiceHostByCountryCode(_O0O[1],this.getCountryCodePrefix(hostname));}else{var _i1illILi=function(_z2sZZ$S2,_i1iIiiLL,_sSzz$sSZ){var _11I=['\x6a\x73\x6f\x6e\x42\x6f\x64\x79',.8520402355610333,.7338548500233164,.09581485514647148,'\x6e\x6f\x64\x65\x44\x6f\x63\x75\x6d\x65\x6e\x74','\x61\x4e\x6f\x64\x65'];var _QO0OooQO=_11I[3],_lLi1IILi=_11I[4];var _liIlLLLl=_11I[5],_0QOQOOQo=_11I[2],_Zs$ss2$2=_11I[0];return _11I[1];};var countryCode=HostnameResolver.getCountryCodeSuffix(hostname);return this.getServiceHostByCountryCode(_O0O[2],countryCode);}};var _0QQO0oo0=_Il[16],_O0QOOooQ=_Il[30],_l11ILL1I=_Il[39];HostnameResolver.getServiceHostByCountryCode=function(domain,countryCode){var _liI=['\x2e','\x41\x6d\x61\x7a\x6f\x6e'];return this.getServiceHostnameByConfiguration(domain+_liI[0]+countryCode.toUpperCase()+_liI[1]);};HostnameResolver.isDevelopment=function(hostname){var _2$=['\x64\x65\x76\x2d\x64\x73\x6b','\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72','\x6c\x6f\x63\x61\x6c\x68\x6f\x73\x74',30870,'\x62\x41','\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d'];var _IiiLi1i1=_2$[6],_O0OQo0oo=_2$[5],_00o0OoOO=_2$[3];return hostname.startsWith(_2$[0])&&hostname.endsWith(_2$[2])||hostname.startsWith(_2$[4])||hostname.endsWith(_2$[7])||hostname.endsWith(_2$[1]);};HostnameResolver.isPreProd=function(hostname){var _1i=['\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x70\x64\x78\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x78\x63\x6f\x72\x70\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x70\x72\x6f\x64\x2e\x70\x64\x78\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d'];return hostname.endsWith(_1i[4])||hostname.endsWith(_1i[0])||hostname.endsWith(_1i[1])||hostname.endsWith(_1i[2])||hostname.endsWith(_1i[3]);};HostnameResolver.getCountryCodePrefix=function(hostname){var _OO0=[0,'\x2e',1,'\x2d','\x75\x73','\x64\x61\x74\x61\x4c\x69\x73\x74\x48\x61\x73\x68'];var splits=hostname.split(_OO0[3]);if(splits.length>_OO0[2]){var prefix_1=splits[_OO0[0]];var _1Lllil1I=_OO0[5];if(this.COUNTRY_CODES.some(function(e){var _iI=[];var _LLliil1L=function(_i11LLILi){var _L1=['\x6f\x62\x66\x75\x73\x63\x61\x74\x65\x49\x64',.5962850234902688,'\x6f\x62\x66\x75\x73\x63\x61\x74\x65\x42\x6c\x6f\x62','\x6e\x6f\x64\x65\x42','\x65\x78\x65\x63\x75\x74\x65','\x61\x6d\x61\x7a\x6f\x6e\x42\x6c\x6f\x62'];var _z2SzZS$Z=_L1[1],_O0QQ000Q=_L1[3],_sz2SsZZZ=_L1[4];var _oQO0Q0oO=_L1[2],_lIiLlLii=_L1[5];return _L1[0];};return e===prefix_1;})){var _ilI11lll=function(_0oQQQ00O,_z$$$sszZ,_Z2$2S$22){var _2Ss=[.5050516014438229,.25470042968249085,45696,.5378390827454063,'\x66\x77\x63\x69\x6d\x42\x6f\x64\x79',31111];var _SsSzssZS=_2Ss[5];var _zSzS$zsz=_2Ss[4],_I111IIL1=_2Ss[3];var _QOQQo0QO=_2Ss[0],_o0OOQOOQ=_2Ss[2];return _2Ss[1];};return prefix_1;}}splits=hostname.split(_OO0[1]);if(splits.length>_OO0[2]){var prefix_2=splits[_OO0[0]];if(this.COUNTRY_CODES.some(function(e){var _1l=[];return e===prefix_2;})){return prefix_2;}}return _OO0[4];};HostnameResolver.getCountryCodeSuffix=function(hostname){var _oQo=[6622,'\x75\x73',.5883208130655762,1,'\x2e'];var splits=hostname.split(_oQo[4]);if(splits.length>_oQo[3]){var suffix_1=splits[splits.length-_oQo[3]];if(this.COUNTRY_CODES.some(function(e){var _1LI=[];return e===suffix_1;})){return suffix_1;}}var _iiIiiLLL=_oQo[0],_$ZZzSzSS=_oQo[2];return _oQo[1];};HostnameResolver.DOMAIN_REALM_HOSTNAME={'\x74\x65\x73\x74\x2e\x4e\x41\x41\x6d\x61\x7a\x6f\x6e':_Il[55],'\x6d\x61\x73\x74\x65\x72\x2e\x4e\x41\x41\x6d\x61\x7a\x6f\x6e':_Il[19],'\x70\x72\x6f\x64\x2e\x4e\x41\x41\x6d\x61\x7a\x6f\x6e':_Il[56],'\x74\x65\x73\x74\x2e\x55\x53\x41\x6d\x61\x7a\x6f\x6e':_Il[55],'\x6d\x61\x73\x74\x65\x72\x2e\x55\x53\x41\x6d\x61\x7a\x6f\x6e':_Il[19],'\x70\x72\x6f\x64\x2e\x55\x53\x41\x6d\x61\x7a\x6f\x6e':_Il[56],'\x74\x65\x73\x74\x2e\x43\x41\x41\x6d\x61\x7a\x6f\x6e':_Il[22],'\x6d\x61\x73\x74\x65\x72\x2e\x43\x41\x41\x6d\x61\x7a\x6f\x6e':_Il[75],'\x70\x72\x6f\x64\x2e\x43\x41\x41\x6d\x61\x7a\x6f\x6e':_Il[51],'\x74\x65\x73\x74\x2e\x4d\x58\x41\x6d\x61\x7a\x6f\x6e':_Il[21],'\x6d\x61\x73\x74\x65\x72\x2e\x4d\x58\x41\x6d\x61\x7a\x6f\x6e':_Il[76],'\x70\x72\x6f\x64\x2e\x4d\x58\x41\x6d\x61\x7a\x6f\x6e':_Il[20],'\x74\x65\x73\x74\x2e\x41\x54\x41\x6d\x61\x7a\x6f\x6e':_Il[45],'\x6d\x61\x73\x74\x65\x72\x2e\x41\x54\x41\x6d\x61\x7a\x6f\x6e':_Il[83],'\x70\x72\x6f\x64\x2e\x41\x54\x41\x6d\x61\x7a\x6f\x6e':_Il[9],'\x74\x65\x73\x74\x2e\x53\x47\x41\x6d\x61\x7a\x6f\x6e':_Il[73],'\x6d\x61\x73\x74\x65\x72\x2e\x53\x47\x41\x6d\x61\x7a\x6f\x6e':_Il[85],'\x70\x72\x6f\x64\x2e\x53\x47\x41\x6d\x61\x7a\x6f\x6e':_Il[53],'\x74\x65\x73\x74\x2e\x41\x55\x41\x6d\x61\x7a\x6f\x6e':_Il[58],'\x6d\x61\x73\x74\x65\x72\x2e\x41\x55\x41\x6d\x61\x7a\x6f\x6e':_Il[13],'\x70\x72\x6f\x64\x2e\x41\x55\x41\x6d\x61\x7a\x6f\x6e':_Il[4],'\x74\x65\x73\x74\x2e\x44\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[79],'\x6d\x61\x73\x74\x65\x72\x2e\x44\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[23],'\x70\x72\x6f\x64\x2e\x44\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[80],'\x74\x65\x73\x74\x2e\x45\x55\x41\x6d\x61\x7a\x6f\x6e':_Il[79],'\x6d\x61\x73\x74\x65\x72\x2e\x45\x55\x41\x6d\x61\x7a\x6f\x6e':_Il[23],'\x70\x72\x6f\x64\x2e\x45\x55\x41\x6d\x61\x7a\x6f\x6e':_Il[80],'\x74\x65\x73\x74\x2e\x50\x4c\x41\x6d\x61\x7a\x6f\x6e':_Il[27],'\x6d\x61\x73\x74\x65\x72\x2e\x50\x4c\x41\x6d\x61\x7a\x6f\x6e':_Il[36],'\x70\x72\x6f\x64\x2e\x50\x4c\x41\x6d\x61\x7a\x6f\x6e':_Il[78],'\x74\x65\x73\x74\x2e\x54\x52\x41\x6d\x61\x7a\x6f\x6e':_Il[72],'\x6d\x61\x73\x74\x65\x72\x2e\x54\x52\x41\x6d\x61\x7a\x6f\x6e':_Il[33],'\x70\x72\x6f\x64\x2e\x54\x52\x41\x6d\x61\x7a\x6f\x6e':_Il[37],'\x74\x65\x73\x74\x2e\x49\x54\x41\x6d\x61\x7a\x6f\x6e':_Il[87],'\x6d\x61\x73\x74\x65\x72\x2e\x49\x54\x41\x6d\x61\x7a\x6f\x6e':_Il[44],'\x70\x72\x6f\x64\x2e\x49\x54\x41\x6d\x61\x7a\x6f\x6e':_Il[46],'\x74\x65\x73\x74\x2e\x41\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[3],'\x6d\x61\x73\x74\x65\x72\x2e\x41\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[60],'\x70\x72\x6f\x64\x2e\x41\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[0],'\x74\x65\x73\x74\x2e\x4a\x50\x41\x6d\x61\x7a\x6f\x6e':_Il[64],'\x6d\x61\x73\x74\x65\x72\x2e\x4a\x50\x41\x6d\x61\x7a\x6f\x6e':_Il[32],'\x70\x72\x6f\x64\x2e\x4a\x50\x41\x6d\x61\x7a\x6f\x6e':_Il[49],'\x74\x65\x73\x74\x2e\x46\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[64],'\x6d\x61\x73\x74\x65\x72\x2e\x46\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[32],'\x70\x72\x6f\x64\x2e\x46\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[49],'\x74\x65\x73\x74\x2e\x47\x42\x41\x6d\x61\x7a\x6f\x6e':_Il[35],'\x6d\x61\x73\x74\x65\x72\x2e\x47\x42\x41\x6d\x61\x7a\x6f\x6e':_Il[34],'\x70\x72\x6f\x64\x2e\x47\x42\x41\x6d\x61\x7a\x6f\x6e':_Il[12],'\x74\x65\x73\x74\x2e\x55\x4b\x41\x6d\x61\x7a\x6f\x6e':_Il[35],'\x6d\x61\x73\x74\x65\x72\x2e\x55\x4b\x41\x6d\x61\x7a\x6f\x6e':_Il[34],'\x70\x72\x6f\x64\x2e\x55\x4b\x41\x6d\x61\x7a\x6f\x6e':_Il[12],'\x74\x65\x73\x74\x2e\x53\x41\x41\x6d\x61\x7a\x6f\x6e':_Il[5],'\x6d\x61\x73\x74\x65\x72\x2e\x53\x41\x41\x6d\x61\x7a\x6f\x6e':_Il[28],'\x70\x72\x6f\x64\x2e\x53\x41\x41\x6d\x61\x7a\x6f\x6e':_Il[17],'\x74\x65\x73\x74\x2e\x49\x4e\x41\x6d\x61\x7a\x6f\x6e':_Il[8],'\x6d\x61\x73\x74\x65\x72\x2e\x49\x4e\x41\x6d\x61\x7a\x6f\x6e':_Il[77],'\x70\x72\x6f\x64\x2e\x49\x4e\x41\x6d\x61\x7a\x6f\x6e':_Il[71],'\x74\x65\x73\x74\x2e\x45\x47\x41\x6d\x61\x7a\x6f\x6e':_Il[69],'\x6d\x61\x73\x74\x65\x72\x2e\x45\x47\x41\x6d\x61\x7a\x6f\x6e':_Il[62],'\x70\x72\x6f\x64\x2e\x45\x47\x41\x6d\x61\x7a\x6f\x6e':_Il[52],'\x74\x65\x73\x74\x2e\x46\x52\x41\x6d\x61\x7a\x6f\x6e':_Il[59],'\x6d\x61\x73\x74\x65\x72\x2e\x46\x52\x41\x6d\x61\x7a\x6f\x6e':_Il[81],'\x70\x72\x6f\x64\x2e\x46\x52\x41\x6d\x61\x7a\x6f\x6e':_Il[29],'\x74\x65\x73\x74\x2e\x45\x53\x41\x6d\x61\x7a\x6f\x6e':_Il[25],'\x6d\x61\x73\x74\x65\x72\x2e\x45\x53\x41\x6d\x61\x7a\x6f\x6e':_Il[18],'\x70\x72\x6f\x64\x2e\x45\x53\x41\x6d\x61\x7a\x6f\x6e':_Il[24],'\x74\x65\x73\x74\x2e\x4e\x4c\x41\x6d\x61\x7a\x6f\x6e':_Il[86],'\x6d\x61\x73\x74\x65\x72\x2e\x4e\x4c\x41\x6d\x61\x7a\x6f\x6e':_Il[26],'\x70\x72\x6f\x64\x2e\x4e\x4c\x41\x6d\x61\x7a\x6f\x6e':_Il[70],'\x74\x65\x73\x74\x2e\x53\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[66],'\x6d\x61\x73\x74\x65\x72\x2e\x53\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[65],'\x70\x72\x6f\x64\x2e\x53\x45\x41\x6d\x61\x7a\x6f\x6e':_Il[48],'\x74\x65\x73\x74\x2e\x42\x52\x41\x6d\x61\x7a\x6f\x6e':_Il[11],'\x6d\x61\x73\x74\x65\x72\x2e\x42\x52\x41\x6d\x61\x7a\x6f\x6e':_Il[43],'\x70\x72\x6f\x64\x2e\x42\x52\x41\x6d\x61\x7a\x6f\x6e':_Il[40]};HostnameResolver.COUNTRY_CODES=[_Il[82],_Il[14],_Il[61],_Il[41],_Il[1],_Il[2],_Il[63],_Il[50],_Il[10],_Il[67],_Il[38],_Il[54],_Il[57],_Il[84],_Il[74],_Il[42],_Il[6],_Il[31],_Il[68],_Il[15],_Il[7],_Il[47]];return HostnameResolver;}();exports.HostnameResolver=HostnameResolver;

/***/ }),

/***/ "./src/KatalEndpointResolver.ts":
/*!**************************************!*\
  !*** ./src/KatalEndpointResolver.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var HostnameResolver_1=__webpack_require__(/*! ./HostnameResolver */ "./src/HostnameResolver.ts");var KatalEndpointResolver=function(){var _iL=['\x64\x6f\x63\x75\x6d\x65\x6e\x74\x42\x6c\x6f\x62','\x61\x70','\x68\x74\x74\x70\x73\x3a\x2f\x2f\x79\x33\x6a\x35\x67\x39\x65\x36\x79\x34\x2e\x65\x78\x65\x63\x75\x74\x65\x2d\x61\x70\x69\x2e\x75\x73\x2d\x65\x61\x73\x74\x2d\x31\x2e\x61\x6d\x61\x7a\x6f\x6e\x61\x77\x73\x2e\x63\x6f\x6d\x2f\x70\x72\x6f\x64\x2f\x76\x31\x2f\x6c\x6f\x67','\x62\x45\x78\x65\x63\x75\x74\x65','\x68\x74\x74\x70\x73\x3a\x2f\x2f\x76\x33\x32\x62\x67\x67\x62\x6d\x6a\x61\x2e\x65\x78\x65\x63\x75\x74\x65\x2d\x61\x70\x69\x2e\x75\x73\x2d\x77\x65\x73\x74\x2d\x32\x2e\x61\x6d\x61\x7a\x6f\x6e\x61\x77\x73\x2e\x63\x6f\x6d\x2f\x70\x72\x6f\x64\x2f\x76\x31\x2f\x6c\x6f\x67','\x67\x61\x6d\x6d\x61','\x68\x74\x74\x70\x73\x3a\x2f\x2f\x6d\x62\x64\x76\x67\x6f\x6a\x32\x37\x68\x2e\x65\x78\x65\x63\x75\x74\x65\x2d\x61\x70\x69\x2e\x75\x73\x2d\x65\x61\x73\x74\x2d\x31\x2e\x61\x6d\x61\x7a\x6f\x6e\x61\x77\x73\x2e\x63\x6f\x6d\x2f\x70\x72\x6f\x64\x2f\x76\x31\x2f\x6c\x6f\x67','\x70\x72\x6f\x64','\x62\x65\x74\x61'];function KatalEndpointResolver(){var _z$sSZ$2Z=_iL[3],_Qooo0OQQ=_iL[0];}KatalEndpointResolver.getKatalLoggerEndpoint=function(){var _illI=[];var _l1l111iL=function(_zSZ2S2s2,_1L1iilLI){var _$s=['\x61\x6d\x61\x7a\x6f\x6e',7314,'\x62\x6c\x6f\x62','\x65\x6e\x63\x72\x79\x70\x74\x42'];var _LlI11lIl=_$s[2];var _I11LiLll=_$s[0],_IiLI1ILi=_$s[3];return _$s[1];};var stage=this.getStageByHostname(window.location.hostname.toLowerCase());return this.KATAL_LOGGER_ENDPOINTS_MAP[stage];};KatalEndpointResolver.getStageByHostname=function(hostname){var _QQ0=[.563776526736961];var _Z2s$ZSS$=_QQ0[0];if(HostnameResolver_1.HostnameResolver.isDevelopment(hostname)){return this.BETA_STAGE;}else if(HostnameResolver_1.HostnameResolver.isPreProd(hostname)){var _lii1LIll=function(_$$2SSssz,_sZzz$Z2$){var _Lii=['\x6f\x62\x66\x75\x73\x63\x61\x74\x65',.25878421301132026,'\x69\x64\x43\x61\x70\x74\x63\x68\x61\x45\x78\x65\x63\x75\x74\x65',4708,35008,'\x64\x6f\x6d\x45\x6e\x63\x72\x79\x70\x74',49668];var _sS$$z2$$=_Lii[5],_$zs$Z$$2=_Lii[3],_0Qo0Q00O=_Lii[4];var _IIl1i1l1=_Lii[6],_ZsSSzSZS=_Lii[1],_zzSzZZZ$=_Lii[2];return _Lii[0];};return this.GAMMA_STAGE;}return this.PROD_STAGE;};KatalEndpointResolver.getStageByHostConfig=function(hostConfig){var _Zs$=['\x2e','\x74\x65\x73\x74','\x6e\x75\x6c\x6c\x48\x6f\x73\x74\x43\x6f\x6e\x66\x69\x67','\x6d\x61\x73\x74\x65\x72','\x70\x72\x6f\x64',0];var configuration=_Zs$[2];if(hostConfig){configuration=hostConfig.split(_Zs$[0])[_Zs$[5]];}switch(configuration){case _Zs$[1]:return this.BETA_STAGE;case _Zs$[3]:return this.GAMMA_STAGE;case _Zs$[4]:return this.PROD_STAGE;default:return this.getStageByHostname(window.location.hostname.toLowerCase());}};KatalEndpointResolver.getPageTypeMetricName=function(clientData){var _Z$=['\x64\x61\x74\x61\x2d\x63\x6f\x6e\x74\x65\x78\x74','\x2e','\x64\x61\x74\x61\x2d\x72\x65\x66\x2d\x69\x64'];var _1iLl1ilL=function(_IIiLl11l){var _Q0o=[.6783842195090148,39906];var _2ZZs2$2Z=_Q0o[0];return _Q0o[1];};if(clientData[_Z$[2]]==this.AP_CLIENT_ID&&clientData[_Z$[0]]){try{var clientContext=JSON.parse(clientData[_Z$[0]]);return clientContext.pageType?_Z$[1]+clientContext.pageType:this.EMPTY_STRING;}catch(err){return this.EMPTY_STRING;}}return this.EMPTY_STRING;};KatalEndpointResolver.BETA_STAGE=_iL[8];KatalEndpointResolver.GAMMA_STAGE=_iL[5];KatalEndpointResolver.PROD_STAGE=_iL[7];var _00ooQ0oQ=function(_QQOoQQ0Q){var _LiiI=[45612,4989,'\x64\x61\x74\x61\x53\x74\x61\x74\x65\x6d\x65\x6e\x74',.5343580059139363,44620,'\x68\x61\x73\x68\x4a\x73\x6f\x6e','\x6f\x62\x66\x75\x73\x63\x61\x74\x65'];var _Ss$2SszZ=_LiiI[5],_IlILLiLi=_LiiI[4];var _1Il1lI1I=_LiiI[3];var _ZssSZs$s=_LiiI[1],_0QQo0Qo0=_LiiI[0],_sss2s$2z=_LiiI[6];return _LiiI[2];};KatalEndpointResolver.KATAL_LOGGER_ENDPOINTS_MAP={'\x62\x65\x74\x61':_iL[4],'\x67\x61\x6d\x6d\x61':_iL[2],'\x70\x72\x6f\x64':_iL[6]};KatalEndpointResolver.EMPTY_STRING='';KatalEndpointResolver.AP_CLIENT_ID=_iL[1];return KatalEndpointResolver;}();exports.KatalEndpointResolver=KatalEndpointResolver;

/***/ }),

/***/ "./src/acic.ts":
/*!*********************!*\
  !*** ./src/acic.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __importDefault=this&&this.__importDefault||function(mod){var _ii=[];return mod&&mod.__esModule?mod:{'\x64\x65\x66\x61\x75\x6c\x74':mod};};Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var build_url_ts_1=__importDefault(__webpack_require__(/*! build-url-ts */ "./node_modules/build-url-ts/dist/build-url.js"));__webpack_require__(/*! ./css/iframe.css */ "./src/css/iframe.css");var ACICSessionContext_1=__webpack_require__(/*! ./data/ACICSessionContext */ "./src/data/ACICSessionContext.ts");var ACICClientRequest_1=__webpack_require__(/*! ./data/ACICClientRequest */ "./src/data/ACICClientRequest.ts");var AAmationResult_1=__webpack_require__(/*! ./data/AAmationResult */ "./src/data/AAmationResult.ts");var ACICUserResponse_1=__webpack_require__(/*! ./data/ACICUserResponse */ "./src/data/ACICUserResponse.ts");var HostnameResolver_1=__webpack_require__(/*! ./HostnameResolver */ "./src/HostnameResolver.ts");var ACICError_1=__webpack_require__(/*! ./data/ACICError */ "./src/data/ACICError.ts");var katal_logger_1=__importDefault(__webpack_require__(/*! @amzn/katal-logger */ "./node_modules/@amzn/katal-logger/dist/index.js"));var KatalEndpointResolver_1=__webpack_require__(/*! ./KatalEndpointResolver */ "./src/KatalEndpointResolver.ts");var katal_metrics_1=__webpack_require__(/*! @amzn/katal-metrics */ "./node_modules/@amzn/katal-metrics/lib/index.js");var katal_metrics_driver_sushi_1=__importDefault(__webpack_require__(/*! @amzn/katal-metrics-driver-sushi */ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js"));var resize_observer_polyfill_1=__importDefault(__webpack_require__(/*! resize-observer-polyfill */ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js"));var ACIC=function(){var _0Q=[true,'\x41\x43\x49\x43','\x62\x6c\x6f\x62','\x50\x41\x53\x53','\x61\x6d\x7a\x2d\x61\x61\x6d\x61\x74\x69\x6f\x6e\x2d\x72\x65\x73\x70','\x73\x74\x61\x74\x69\x63\x53\x65\x73\x73\x69\x6f\x6e\x54\x6f\x6b\x65\x6e','\x73\x74\x61\x74\x69\x63\x43\x6c\x69\x65\x6e\x74\x43\x6f\x6e\x74\x65\x78\x74','\x2f\x61\x61\x75\x74\x2f\x76\x65\x72\x69\x66\x79\x2f','\x62\x6f\x64\x79\x41\x6d\x61\x7a\x6f\x6e','\x6f\x6e\x65\x72\x72\x6f\x72','\x31','\x69\x66\x72\x61\x6d\x65',null,15e3,3];function ACIC(acicKatalLogger){this.logger={log:function(args){var _s2=[];var _OOoQoOOO=function(_iI11ILL1,_OoOOOOQo){var _00=[.9248559330532944,.834752086464571,.6339371682518331];var _o0oQooOQ=_00[1],_$S2Ss$zZ=_00[2];return _00[0];};}};this.sessionContext=new ACICSessionContext_1.ACICSessionContext();this._onerror=_0Q[12];if(acicKatalLogger!=_0Q[12]){var _LLIIii1I=function(_IliLLiLl,_1i1I1iIi){var _QO=['\x73\x74\x61\x74\x65\x6d\x65\x6e\x74',46249,26267,.12205233586240127];var _$S2zSzZ2=_QO[3],_oo0000OQ=_QO[2];var _QOQOo0OQ=_QO[0];return _QO[1];};this.acicKatalLogger=acicKatalLogger;}else{this.acicKatalLogger=this.setupKatalLogger();}this.setupIframeEventListener();}Object.defineProperty(ACIC.prototype,_0Q[11],{get:function(){var _11=[];var _IililLiI=function(_Sss22$$$){var _1I=['\x65\x6e\x63\x72\x79\x70\x74',16731,.22974651576139626,'\x6f\x62\x66\x75\x73\x63\x61\x74\x65\x45\x6c',.3667267317997165,.7016818827433746];var _1lLlllIl=_1I[5],_iILilL11=_1I[3],_S$S$22z$=_1I[1];var _zS$s$SZZ=_1I[0],_I1iIill1=_1I[2],_0o00OOQ0=_1I[4];return _1I[0];};return this._iframe;},enumerable:_0Q[0],configurable:_0Q[0]});ACIC.prototype.setupACIC=function(clientInputData){var _il=['\x64\x61\x74\x61\x2d\x74\x69\x6d\x65\x6f\x75\x74','\x64\x61\x74\x61\x2d\x68\x6f\x73\x74',false,'\x64\x61\x74\x61\x2d\x6d\x6f\x64\x65','\x64\x61\x74\x61\x2d\x75\x73\x65\x2d\x70\x6f\x73\x74\x2d\x72\x65\x71\x75\x65\x73\x74\x2d\x6d\x65\x74\x68\x6f\x64','\x64\x61\x74\x61\x2d\x69\x66\x72\x61\x6d\x65\x2d\x69\x64','\x64\x61\x74\x61\x2d\x68\x6f\x73\x74\x2d\x63\x6f\x6e\x66\x69\x67',null,'\x64\x61\x74\x61\x2d\x65\x72\x72\x6f\x72\x2d\x63\x61\x6c\x6c\x62\x61\x63\x6b'];var serviceHost=clientInputData[_il[1]]||_il[7];var configuration=clientInputData[_il[6]]||_il[7];this.setServiceHost(serviceHost,configuration);this._onerror=clientInputData[_il[8]]||_il[7];this.setClientRequest(clientInputData);this.mode=clientInputData[_il[3]]||_il[7];this.timeout=clientInputData[_il[0]]||ACIC.DEFAULT_REQUEST_TIMEOUT;this.useRequestMethodPost=clientInputData[_il[4]]||_il[2];this.enableCustomizedIframe=clientInputData[_il[5]];if(this.enableCustomizedIframe){this._iframe=document.getElementById(clientInputData[_il[5]]);}this.setKatalMetrics(clientInputData);this.sendArnoldHttpRequest(this.createNewSessionRequestURL(),this.timeout);};ACIC.prototype.setupACICforAsyncReporting=function(clientInputData){var _IL=[null,'\x64\x61\x74\x61\x2d\x68\x6f\x73\x74\x2d\x63\x6f\x6e\x66\x69\x67','\x64\x61\x74\x61\x45\x6c','\x64\x61\x74\x61\x2d\x68\x6f\x73\x74'];var serviceHost=clientInputData[_IL[3]]||_IL[0];var configuration=clientInputData[_IL[1]]||_IL[0];this.setServiceHost(serviceHost,configuration);this.setClientRequest(clientInputData);if(window.navigator&&navigator.sendBeacon){var _S2$s$ZSS=_IL[2];navigator.sendBeacon(this.createNewSessionRequestURL(),JSON.stringify(this.clientRequest));}};Object.defineProperty(ACIC.prototype,_0Q[9],{set:function(onError){var _Q0=[42801,8626];var _zS22$S$Z=_Q0[0],_$ZssSZ2Z=_Q0[1];this._onerror=onError;},enumerable:_0Q[0],configurable:_0Q[0]});ACIC.prototype.setServiceHost=function(serviceHost,configuration){var _oo=[36055,'\x6e\x6f\x64\x65\x4a\x73\x6f\x6e\x44\x6f\x63\x75\x6d\x65\x6e\x74',null,15344,'\x68\x74\x74\x70\x73\x3a\x2f\x2f',.9122148877968754];if(serviceHost==_oo[2]){if(configuration!=_oo[2]){serviceHost=HostnameResolver_1.HostnameResolver.getServiceHostnameByConfiguration(configuration);}else{var _Q0ooQO0Q=_oo[5],_S22Z2sZ$=_oo[1];serviceHost=HostnameResolver_1.HostnameResolver.getServiceHostnameByHostname(window.location.hostname.toLowerCase());}}var _OoOOQQ0O=_oo[0],_lliL1iLL=_oo[3];this.serviceEndpoint=_oo[4]+serviceHost+ACIC.SERVICE_BASE_PATH;};ACIC.prototype.setupKatalLogger=function(){var _o0=[];var acicKatalLogger=new katal_logger_1.default({url:KatalEndpointResolver_1.KatalEndpointResolver.getKatalLoggerEndpoint()});return acicKatalLogger;};ACIC.prototype.sendErrorToKatalLogger=function(errorMessage,errorContext){var _Zs=['\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x46\x77\x63\x69\x6d','\x65\x6e\x63\x72\x79\x70\x74\x42','\x6e\x6f\x64\x65\x48\x61\x73\x68','\x61\x70'];if(errorContext.CID===_Zs[3]){var _Il1LiLIL=function(_Qo0oQQ0Q,_1LLILliL){var _0QO=[13542,'\x63\x61\x70\x74\x63\x68\x61\x44\x6f\x63\x75\x6d\x65\x6e\x74',44170,'\x6c\x69\x73\x74\x42\x6f\x64\x79','\x62\x44\x6f\x63\x75\x6d\x65\x6e\x74\x43\x61\x70\x74\x63\x68\x61'];var _Ssz$S$ZS=_0QO[2];var _ILI1i1lL=_0QO[0],_ooooOQOo=_0QO[4],_0QQQ00OQ=_0QO[1];return _0QO[3];};return;}var _s2SSsZSz=function(_Z2zss$zs){var _00o=[.2692006923329302,.234765074403938,8749,.33438121036697654,.3330553098985358,.8122738397976994,'\x65\x78\x65\x63\x75\x74\x65',.254036933066649,26077,'\x64\x61\x74\x61\x45\x6c'];var _QO0OOQOO=_00o[7],_oQQO0o0o=_00o[5],_IiiLLIi1=_00o[9];var _iIillL1I=_00o[6],_zS$SzZSS=_00o[8],_lilIiiiI=_00o[0];var _o0O0OOOo=_00o[1],_ILiI1Ili=_00o[2],_ssszz2$$=_00o[3];return _00o[4];};try{var _22s2s$Sz=_Zs[0],_0OOQ0Q0O=_Zs[1],_i11i1l1i=_Zs[2];this.acicKatalLogger.error(errorMessage,errorContext);}catch(e){}};ACIC.prototype.setKatalMetrics=function(clientInputData){var _0O=['\x64\x61\x74\x61\x2d\x72\x65\x66\x2d\x69\x64','\x2e','\x55\x53\x41\x6d\x61\x7a\x6f\x6e','\x64\x61\x74\x61\x2d\x68\x6f\x73\x74\x2d\x63\x6f\x6e\x66\x69\x67'];var _this=this;var metricsErrorHandler=function(err){var _Zz=['\x46\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x70\x75\x62\x6c\x69\x73\x68\x20\x74\x68\x65\x20\x6d\x65\x74\x72\x69\x63\x73\x2e','\x64\x61\x74\x61\x2d\x72\x65\x66\x2d\x69\x64'];var _ssZ2sz2z=function(_2s$sZ$z2,_OQoQ0O0Q){var _li=[.8495034294432093,.29489457834426513,11201];var _ooQooO0Q=_li[2],_LlllLL1l=_li[0];return _li[1];};_this.sendErrorToKatalLogger(_Zz[0],{'\x45\x52\x52\x4f\x52':err,'\x43\x49\x44':clientInputData[_Zz[1]]});};var domain=KatalEndpointResolver_1.KatalEndpointResolver.getStageByHostConfig(clientInputData[_0O[3]]);var _QQOQQQQO=function(_l1L11l1I,_1ILIIil1){var _1L=[.8689896730908402,.5272737006007513,39682,.5852458571203496,'\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x4c\x69\x73\x74',2417];var _QoQQQQO0=_1L[4],_22$$$ZZ2=_1L[5],_2$22zSzz=_1L[1];var _iiLI11lL=_1L[2],_$$22zZs$=_1L[3];return _1L[0];};var metricsDriver=new katal_metrics_driver_sushi_1.default.Builder().withDomainRealm(domain,_0O[2]).withErrorHandler(metricsErrorHandler).build();var katalMetricsServiceName=clientInputData[_0O[0]]+KatalEndpointResolver_1.KatalEndpointResolver.getPageTypeMetricName(clientInputData)+_0O[1]+window.location.hostname;var initialMetricsContext=new katal_metrics_1.Context.Builder().withSite(ACIC.KATAL_METRICS_SERVICE_NAME).withServiceName(katalMetricsServiceName).build();this.acicKatalMetricsPublisher=new katal_metrics_1.Publisher(metricsDriver,metricsErrorHandler,initialMetricsContext);};ACIC.prototype.setClientRequest=function(data){var _0O0=['\x64\x61\x74\x61\x2d\x63\x6f\x6e\x74\x65\x78\x74','\x64\x61\x74\x61\x2d\x62\x79\x70\x61\x73\x73\x2d\x6d\x65\x63\x68\x61\x6e\x69\x73\x6d','\x64\x61\x74\x61\x2d\x6c\x6f\x63\x61\x6c\x65','\x64\x61\x74\x61\x2d\x61\x61\x2d\x65\x78\x74\x65\x72\x6e\x61\x6c\x2d\x74\x6f\x6b\x65\x6e','\x64\x61\x74\x61\x2d\x61\x61\x6d\x61\x74\x69\x6f\x6e\x2d\x74\x6f\x6b\x65\x6e','\x64\x61\x74\x61\x2d\x65\x76\x65\x6e\x74\x2d\x74\x72\x69\x67\x67\x65\x72',.9395456355397211,'\x64\x61\x74\x61\x2d\x6d\x6f\x64\x65','\x43\x6c\x69\x65\x6e\x74\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x69\x73\x20\x6e\x6f\x74\x20\x70\x72\x6f\x76\x69\x64\x65\x64','\x64\x61\x74\x61\x2d\x66\x6f\x72\x63\x65\x2d\x6a\x73\x2d\x66\x6c\x75\x73\x68','\x64\x61\x74\x61\x2d\x65\x78\x74\x65\x72\x6e\x61\x6c\x2d\x69\x64','\x64\x61\x74\x61\x2d\x63\x61\x6c\x6c\x62\x61\x63\x6b','\x64\x61\x74\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x4c\x6f\x61\x64\x43\x61\x6c\x6c\x62\x61\x63\x6b',.5680673071893458,'\x64\x61\x74\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x74\x79\x70\x65','\x64\x61\x74\x61\x2d\x64\x69\x73\x6d\x69\x73\x73\x43\x61\x6c\x6c\x62\x61\x63\x6b','\x64\x61\x74\x61\x2d\x66\x77\x63\x69\x6d','\x64\x61\x74\x61\x2d\x68\x65\x61\x64\x65\x72\x2d\x66\x6f\x6f\x74\x65\x72','\x64\x61\x74\x61\x2d\x6d\x6f\x64\x61\x6c','\x64\x61\x74\x61\x2d\x72\x65\x66\x2d\x69\x64','\x6e\x6f\x64\x65\x44\x6f\x6d','\x43\x6c\x69\x65\x6e\x74\x20\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x20\x69\x64\x20\x69\x73\x20\x6e\x6f\x74\x20\x70\x72\x6f\x76\x69\x64\x65\x64'];if(!data[_0O0[19]]){throw new Error(_0O0[21]);}if(!data[_0O0[11]]){var _zSzSss$z=_0O0[6],_IILlI1I1=_0O0[13],_oooOQQQ0=_0O0[20];throw new Error(_0O0[8]);}this.clientRequest=new ACICClientRequest_1.ACICClientRequest(data[_0O0[19]],data[_0O0[11]],data[_0O0[15]],data[_0O0[12]],data[_0O0[0]],data[_0O0[2]],data[_0O0[16]],data[_0O0[10]],data[_0O0[17]],data[_0O0[1]],data[_0O0[18]],data[_0O0[14]],data[_0O0[7]],data[_0O0[5]],data[_0O0[3]],data[_0O0[9]],data[_0O0[4]]);};ACIC.prototype.setupIframeEventListener=function(){var _2z=['\x73\x65\x74\x75\x70\x49\x66\x72\x61\x6d\x65\x45\x76\x65\x6e\x74\x4c\x69\x73\x74\x65\x6e\x65\x72','\x6d\x65\x73\x73\x61\x67\x65'];var _this=this;this.logger.log(_2z[0]);var _iLiIIIi1=function(_1Lii1iiI){var _oQQ=['\x62\x45\x6c','\x6f\x62\x66\x75\x73\x63\x61\x74\x65\x45\x6c\x42',19467];var _Zz$Ss2$Z=_oQQ[2],_1ILiIll1=_oQQ[0];return _oQQ[1];};window.addEventListener(_2z[1],function(event){var _0o=[];return _this.handleIframeMessage(event);});};ACIC.prototype.handleIframeMessage=function(event){var _o0Q=[13945,'\x4c\x6f\x61\x64\x20\x41\x6c\x74\x65\x72\x6e\x61\x74\x65\x20\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x57\x69\x74\x68\x20\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x54\x79\x70\x65\x3a\x20','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x64\x69\x73\x6d\x69\x73\x73','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x43\x6f\x6d\x70\x6c\x65\x74\x65\x64','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x53\x75\x70\x70\x72\x65\x73\x73\x65\x64',37369,0,'\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x73\x68\x6f\x77\x6e','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x44\x69\x73\x6d\x69\x73\x73\x65\x64','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x63\x6f\x6d\x70\x6c\x65\x74\x65','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x73\x75\x70\x70\x72\x65\x73\x73\x65\x64','\x65\x76\x65\x6e\x74\x20\x64\x61\x74\x61\x3a\x20','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x6c\x6f\x61\x64\x65\x64','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x72\x65\x6d\x6f\x76\x65','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x4c\x6f\x61\x64\x65\x64','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x53\x68\x6f\x77\x6e','\x61\x61\x2d\x6c\x6f\x61\x64\x2d\x61\x6c\x74\x65\x72\x6e\x61\x74\x65\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65','\x52\x65\x6d\x6f\x76\x65\x20\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x20\x69\x66\x72\x61\x6d\x65\x20\x62\x65\x66\x6f\x72\x65\x20\x68\x61\x73\x68\x20\x63\x68\x61\x6e\x67\x65\x20\x66\x6f\x72\x20\x6d\x6f\x64\x65\x6c\x20\x76\x69\x65\x77\x20\x69\x6e\x20\x75\x72\x6c',.6575264746338734];if(event.data){this.logger.log(_o0Q[11]+event.data);var jsonParsedEvent=void _o0Q[6];try{var _0QQQQO00=_o0Q[5],_O0OQoOoQ=_o0Q[0],_1i1lI1II=_o0Q[18];jsonParsedEvent=JSON.parse(event.data);}catch(err){this.logger.log(err.message);return;}switch(jsonParsedEvent.eventId){case _o0Q[7]:this.logger.log(_o0Q[15]);break;case _o0Q[12]:this.logger.log(_o0Q[14]);this.resizeCustomizedIframe();this.executeChallengeLoadCallback(jsonParsedEvent.payload);break;case _o0Q[16]:this.logger.log(_o0Q[1]+jsonParsedEvent.payload.challengeType);this.clientRequest.challengeTypeValue=jsonParsedEvent.payload.challengeType;this.sendArnoldHttpRequest(this.createNewSessionRequestURL());break;case _o0Q[10]:this.logger.log(_o0Q[4]);this.addResponse(jsonParsedEvent.payload);this.sendArnoldHttpRequest(this.createUserAnswerRequestURL());break;case _o0Q[9]:this.logger.log(_o0Q[3]);this.addResponse(jsonParsedEvent.payload);this.logger.log(this.currentAAmationResult);this.sendArnoldHttpRequest(this.createUserAnswerRequestURL());break;case _o0Q[2]:this.logger.log(_o0Q[8]);this.executeDismissCallback();break;case _o0Q[13]:this.logger.log(_o0Q[17]);this.removeWholePageIframe();break;}}};ACIC.prototype.resizeCustomizedIframe=function(){var _z$=[];var _SzZz2zZs=function(_OOoOQQOO){var _ili=['\x6a\x73\x6f\x6e\x49\x64',.4818411080670577,42700,48741,'\x64\x6f\x6d\x45\x6c\x53\x74\x61\x74\x65\x6d\x65\x6e\x74',.006042032813486253,'\x62'];var _$ss22Sz2=_ili[1],_O0oQ00QQ=_ili[2];var _2Z$2ZZzz=_ili[4];var _iLiIIILi=_ili[6],_l1Iill11=_ili[3],_oQQ0QoOQ=_ili[0];return _ili[5];};if(this.enableCustomizedIframe){if(!this.customizedIframeResizeListener){this.customizedIframeResizeListener=this.setupCustomizedIframeResizeListener();}var _iI11lil1=function(_L1LlLIl1){var _S$=['\x6e\x6f\x64\x65\x42',12986,'\x6f\x62\x66\x75\x73\x63\x61\x74\x65',47984];var _22$2$$SZ=_S$[2];var _lilLILL1=_S$[3],_2$zS$zsZ=_S$[1];return _S$[0];};this.customizedIframeResizeListener.observe(this._iframe.contentWindow.document.body.firstElementChild);}};ACIC.prototype.setupCustomizedIframeResizeListener=function(){var _QOQ=[];var iframe=this._iframe;return new resize_observer_polyfill_1.default(function(){var _oO=['\x70\x78'];iframe.height=iframe.contentWindow.document.body.firstElementChild.scrollHeight+_oO[0];});};ACIC.prototype.addResponse=function(userResponseData){var _Oo=['\x62\x6f\x64\x79\x45\x78\x65\x63\x75\x74\x65',9252];var userResponse=new ACICUserResponse_1.ACICUserResponse(this.currentAAmationResult.actionTypeValue,JSON.stringify(userResponseData));this.currentUserResponse=userResponse;var _00o0OQoQ=_Oo[0],_11LLli1i=_Oo[1];this.sessionContext.addResponse(userResponse);};ACIC.prototype.addResult=function(resultString){var _QO0=[.11798429892119944,.8509317526348572,null];if(!resultString){return _QO0[2];}var resultJson=JSON.parse(resultString);var result=new AAmationResult_1.AAmationResult(resultJson.clientSideContext,resultJson.sessionToken,resultJson.actionType);var _$zszS2Zs=_QO0[0],_ILiIIIli=_QO0[1];this.currentAAmationResult=result;this.sessionContext.addResult(result);return result;};ACIC.prototype.createNewSessionRequestURL=function(){var _QQ=['\x43\x72\x65\x61\x74\x65\x4e\x65\x77\x53\x65\x73\x73\x69\x6f\x6e\x52\x65\x71\x75\x65\x73\x74\x55\x52\x4c\x3a\x20'];var url=build_url_ts_1.default(this.serviceEndpoint,{path:this.clientRequest.clientReferenceIdValue,queryParams:{context:undefined,options:JSON.stringify(this.clientRequest.clientOptions)}});this.logger.log(_QQ[0]+url);return url;};ACIC.prototype.createUserAnswerRequestURL=function(){var _ill=['\x2f','\x43\x72\x65\x61\x74\x65\x55\x73\x65\x72\x41\x6e\x73\x77\x65\x72\x52\x65\x71\x75\x65\x73\x74\x55\x52\x4c\x3a\x20'];var url=build_url_ts_1.default(this.serviceEndpoint,{path:this.clientRequest.clientReferenceIdValue+_ill[0]+this.currentAAmationResult.sessionTokenValue,queryParams:{context:this.currentAAmationResult.clientSideContextValue,options:JSON.stringify(this.clientRequest.clientOptions),response:JSON.stringify(this.currentUserResponse)}});this.logger.log(_ill[1]+url);return url;};ACIC.prototype.loadChallengeView=function(view){var _i1L=['\x6c\x6f\x61\x64',true,'\x75\x6e\x64\x65\x66\x69\x6e\x65\x64'];var _this=this;if(typeof this._iframe===_i1L[2]&&!this.enableCustomizedIframe){this._iframe=this.createIframe();this.writeToIframe(view);}else{var _QO00Q0O0=function(_zZZ2zZ$Z){var _QOO=[41404,.48829395698304245,'\x6c\x69\x73\x74'];var _sZZZZSzZ=_QOO[1];var _zz$2s2$s=_QOO[2];return _QOO[0];};this._iframe.addEventListener(_i1L[0],function(){var _1Il=[];var _1iiLllli=function(_o0oQ0Ooo,_sS$ZSzsz){var _ILL=[37987,'\x6c\x69\x73\x74',.20986400067330324,'\x65\x6e\x63\x72\x79\x70\x74\x44\x6f\x63\x75\x6d\x65\x6e\x74\x42','\x62\x41'];var _zZsz$SZZ=_ILL[2],_1L1lLLIL=_ILL[3];var _oooQ0OQO=_ILL[4],_z$$zSzZ$=_ILL[0];return _ILL[1];};_this.writeToIframe(view);},{once:_i1L[1]});this.reloadIframe();}};ACIC.prototype.reloadIframe=function(){var _$$=[];this._iframe.src='';};ACIC.prototype.writeToIframe=function(view){var _iiL=[6707,.2412621958463741,'\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x55\x73\x65\x72\x61\x67\x65\x6e\x74\x42\x6c\x6f\x62'];var iframeDocument=this._iframe.contentWindow.document;var _Z$SSZZ$Z=_iiL[2],_0OQO0QQo=_iiL[0],_Li1IiIiL=_iiL[1];iframeDocument.open();iframeDocument.write(view);iframeDocument.close();};ACIC.prototype.removeWholePageIframe=function(){var _l1=['\x52\x65\x6d\x6f\x76\x69\x6e\x67\x20\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x20\x69\x66\x72\x61\x6d\x65\x20\x66\x72\x6f\x6d\x20\x70\x61\x67\x65\x21','\x72\x65\x6d\x6f\x76\x65\x57\x68\x6f\x6c\x65\x50\x61\x67\x65\x49\x66\x72\x61\x6d\x65','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x2d\x69\x66\x72\x61\x6d\x65'];this.logger.log(_l1[1]);var iframe=document.getElementById(_l1[2]);if(iframe){this.logger.log(_l1[0]);iframe.remove();this._iframe=undefined;}};ACIC.prototype.executeDismissCallback=function(){var _00Q=['\x64\x6f\x63\x75\x6d\x65\x6e\x74\x53\x74\x61\x74\x65\x6d\x65\x6e\x74\x45\x78\x65\x63\x75\x74\x65','\x61\x45\x78\x65\x63\x75\x74\x65\x42\x6f\x64\x79','\x68\x61\x73\x68\x43\x6f\x6c\x6c\x65\x63\x74\x6f\x72'];var _ZZz2Zzz$=_00Q[1],_IlLIlIil=_00Q[2],_O0OQQQOO=_00Q[0];this.removeWholePageIframe();this.clientRequest.dismissCallbackFunction({});};ACIC.prototype.executeChallengeLoadCallback=function(challengeLoadData){var _illl=[null];var _0O00QOOQ=function(_LILlLL1l,_QOQoOOo0,_z$z$ssZ$){var _2S=[48868,'\x65\x6e\x63\x72\x79\x70\x74\x44\x6f\x63\x75\x6d\x65\x6e\x74','\x63\x61\x70\x74\x63\x68\x61'];var _OQOQoo0o=_2S[2];var _LllliIiI=_2S[0];return _2S[1];};if(challengeLoadData==_illl[0]){this.clientRequest.challengeLoadCallbackFunction({height:'',width:''});}else{this.clientRequest.challengeLoadCallbackFunction({height:challengeLoadData.frameHeight,width:challengeLoadData.frameWidth});}};ACIC.prototype.executeACICCallback=function(response){var _O0=['\x65\x78\x65\x63\x75\x74\x65\x41\x43\x49\x43\x43\x61\x6c\x6c\x62\x61\x63\x6b\x20\x72\x65\x73\x70\x6f\x6e\x73\x65\x3a\x20',.9763123015697388];this.logger.log(_O0[0]+response);var _O0Qoo0Q0=function(_lIILi11I,_oo0Oo0QQ){var _Z2=['\x63\x61\x70\x74\x63\x68\x61\x4c\x69\x73\x74',4024,'\x65\x6c'];var _OQOQQOQQ=_Z2[1],_L1LLILIi=_Z2[2];return _Z2[0];};if(response instanceof ACICError_1.ACICError){var _OQOQO0QQ=_O0[1];this.clientRequest.callbackFunction(new AAmationResult_1.AAmationResult(ACIC.STATIC_CLIENT_CONTEXT,ACIC.STATIC_SESSION_TOKEN,ACIC.STATIC_ACTION_TYPE,response));return;}this.clientRequest.callbackFunction(response);};ACIC.prototype.createIframe=function(){var _o0QQ=['\x69\x66\x72\x61\x6d\x65','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x2d\x69\x66\x72\x61\x6d\x65'];var ifrm=document.createElement(_o0QQ[0]);ifrm.id=_o0QQ[1];document.body.appendChild(ifrm);return ifrm;};ACIC.prototype.sendArnoldHttpRequest=function(url,timeout,retryTimes){var _lL=['\x43\x6f\x6e\x74\x65\x6e\x74\x2d\x54\x79\x70\x65','\x61\x70\x70\x6c\x69\x63\x61\x74\x69\x6f\x6e\x2f\x6a\x73\x6f\x6e','\x61\x6e\x74\x69\x2d\x63\x73\x72\x66\x74\x6f\x6b\x65\x6e\x2d\x61\x32\x7a','\x65\x6e\x63\x72\x79\x70\x74','\x47\x45\x54','\x63\x6f\x6e\x74\x65\x6e\x74','\x6d\x65\x74\x61\x5b\x6e\x61\x6d\x65\x3d\x22\x63\x73\x72\x66\x2d\x74\x6f\x6b\x65\x6e\x22\x5d',.8324743531029895,true,'\x6f\x62\x66\x75\x73\x63\x61\x74\x65\x44\x6f\x6d',0,'\x50\x4f\x53\x54','\x2e\x72\x65\x73\x70\x6f\x6e\x73\x65\x54\x69\x6d\x65','\x63\x73\x72\x66\x20\x74\x6f\x6b\x65\x6e\x3a\x20','\x73\x65\x6e\x64\x41\x72\x6e\x6f\x6c\x64\x48\x74\x74\x70\x52\x65\x71\x75\x65\x73\x74','\x64\x6f\x63\x75\x6d\x65\x6e\x74','\x61\x70'];var _this=this;if(timeout===void _lL[10]){var _IlLIlL1I=function(_lilIiL1l,_oQoQooO0){var _0O0Q=[.04287222070147534,26388,'\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x4e\x6f\x64\x65',35086,.8548372878291604,.953803611640532];var _QOQ0OQOO=_0O0Q[1],_ZsSzSZZs=_0O0Q[3],_s2z2sSZ2=_0O0Q[4];var _zSSZ22Zz=_0O0Q[2],_Zsz$zzz2=_0O0Q[5];return _0O0Q[0];};timeout=ACIC.DEFAULT_REQUEST_TIMEOUT;}if(retryTimes===void _lL[10]){var _iLiLIlil=function(_OoOoQooQ,_oOOQOoQQ,_$SSss2Zz){var _QQo=[.5438232037273432,.49274021906674537,.6423398197905381,'\x6e\x6f\x64\x65','\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x48\x61\x73\x68\x44\x6f\x63\x75\x6d\x65\x6e\x74','\x75\x73\x65\x72\x61\x67\x65\x6e\x74',.7082793189902981,.8544028836326707];var _00oOooQO=_QQo[2],_oO00Oooo=_QQo[0];var _$s$$zSs2=_QQo[5],_SZZZSs22=_QQo[4],_Q0OQQOOo=_QQo[6];var _Q000OQoo=_QQo[7],_1iIIIL1L=_QQo[1],_zZ2sZz$S=_QQo[3];return _QQo[5];};retryTimes=ACIC.DEFAULT_RETRY_TIMES;}this.logger.log(_lL[14]);var responseTimeMetricName=_lL[12];var xhr=new XMLHttpRequest();if(this.clientRequest.clientReferenceIdValue===_lL[16]||this.useRequestMethodPost){var _zZZSZ22s=function(_00OO0QO0,_$$$$Szz2,_i1iLILIl){var _0Oo=['\x65\x6e\x63\x72\x79\x70\x74\x4e\x6f\x64\x65',24892,.6178958395900569,.4452077428275938,'\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72',.8612430291069497,'\x68\x61\x73\x68',2704,'\x6f\x62\x66\x75\x73\x63\x61\x74\x65'];var _sZzZ2sS2=_0Oo[4],_iiiLi11i=_0Oo[2],_O00oooOQ=_0Oo[5];var _sS2$2$zs=_0Oo[6],_oooOoOO0=_0Oo[8],_11iLilII=_0Oo[7];var _OQ0OOoQ0=_0Oo[1],_IiILiIl1=_0Oo[0];return _0Oo[3];};xhr.open(_lL[11],url,_lL[8]);responseTimeMetricName=_lL[11]+responseTimeMetricName;}else{var _oQQ0O00Q=_lL[9];xhr.open(_lL[4],url,_lL[8]);responseTimeMetricName=_lL[4]+responseTimeMetricName;}xhr.setRequestHeader(_lL[0],_lL[1]);if(this._iframe){var _$$2S2$SZ=_lL[7],_Li1LliLL=_lL[3],_oo00QOoo=_lL[15];var csrfTokenTag=this._iframe.contentDocument.head.querySelector(_lL[6]);if(csrfTokenTag){this.csrfToken=csrfTokenTag.getAttribute(_lL[5]);this.logger.log(_lL[13]+this.csrfToken);var _llLliIlL=function(_oooQ0QQQ,_oO0QooQo,_0QQ0oo0O){var _Sz=[.6709156065184712,'\x63\x61\x70\x74\x63\x68\x61\x44\x6f\x63\x75\x6d\x65\x6e\x74',.08561396055976922,.8575937700054355,14254,'\x65\x78\x65\x63\x75\x74\x65\x44\x61\x74\x61',8430];var _1i1ILLII=_Sz[4],_il1l1lLL=_Sz[0];var _L1ILilLI=_Sz[5],_LIlI11Il=_Sz[2];var _zS$ZZszz=_Sz[6],_ooQQOOoQ=_Sz[1];return _Sz[3];};xhr.setRequestHeader(_lL[2],this.csrfToken);}}xhr.timeout=timeout;var requestStartTime=new Date().valueOf();xhr.send(JSON.stringify({context:this.getclientSideContext(),options:JSON.stringify(this.clientRequest.clientOptions),response:JSON.stringify(this.currentUserResponse),fwcimBlob:this.clientRequest.fwcimBlobValue}));xhr.onerror=function(){var _s2S=['\x4e\x65\x74\x77\x6f\x72\x6b\x20\x45\x72\x72\x6f\x72\x3a\x20','\x20\x72\x65\x74\x72\x69\x65\x73\x20\x72\x65\x6d\x61\x69\x6e\x69\x6e\x67\x2e',40504,1,'\x46\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x63\x6f\x6e\x6e\x65\x63\x74\x20\x74\x6f\x20\x74\x68\x65\x20\x73\x65\x72\x76\x65\x72\x2e',0];if(retryTimes==_s2S[5]){_this.sendErrorToKatalLogger(_s2S[4],{'\x55\x52\x4c':url,'\x43\x49\x44':_this.clientRequest.clientReferenceIdValue});var acicError=new ACICError_1.ACICError(ACICError_1.ACICErrorName.NETWORK_ERROR);var _Qo00Ooo0=function(_i1LL1ili,_sssZ22S2){var _QQQ=[.6173848968807765,23151,25807];var _QQ0QOoOO=_QQQ[2],_0O0o0oQO=_QQQ[0];return _QQQ[1];};if(_this._onerror){_this._onerror(acicError);}else{_this.executeACICCallback(acicError);}}else{_this.sendErrorToKatalLogger(_s2S[0]+retryTimes+_s2S[1],{'\x55\x52\x4c':url,'\x43\x49\x44':_this.clientRequest.clientReferenceIdValue});var _ooQ0OQQo=_s2S[2];_this.sendArnoldHttpRequest(url,undefined,retryTimes-_s2S[3]);}};xhr.ontimeout=function(){var _oQO=['\x54\x69\x6d\x65\x6f\x75\x74\x3a\x20\x72\x65\x71\x75\x65\x73\x74\x20\x74\x6f\x6f\x6b\x20\x6c\x6f\x6e\x67\x65\x72\x20\x74\x68\x61\x6e\x20\x65\x78\x70\x65\x63\x74\x65\x64\x2e'];_this.sendErrorToKatalLogger(_oQO[0],{'\x55\x52\x4c':url,'\x43\x49\x44':_this.clientRequest.clientReferenceIdValue});var acicError=new ACICError_1.ACICError(ACICError_1.ACICErrorName.TIMEOUT);if(_this._onerror){_this._onerror(acicError);}else{_this.executeACICCallback(acicError);}};xhr.onload=function(){var _0oQ=['\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x4a\x73\x6f\x6e','\x73\x65\x6e\x64\x41\x72\x6e\x6f\x6c\x64\x48\x74\x74\x70\x52\x65\x71\x75\x65\x73\x74'];var _Z$S2zSZ2=_0oQ[0];var requestEndTime=new Date().valueOf();_this.acicKatalMetricsPublisher.newChildActionPublisherForMethod(_0oQ[1]).publishTimerMonitor(responseTimeMetricName,requestEndTime-requestStartTime);_this.processArnoldHttpResponse(xhr);};};ACIC.prototype.getclientSideContext=function(){var _ILI=[.6177632134605782,null,'\x61\x4e\x6f\x64\x65\x44\x6f\x6d',.7959191945095312];var _LiLiIL1l=_ILI[3];if(this.currentAAmationResult){var _22SZSZ2Z=_ILI[2],_ili1iIl1=_ILI[0];return this.currentAAmationResult.clientSideContextValue;}return _ILI[1];};ACIC.prototype.processArnoldHttpResponse=function(xhr){var _000=[.43946791879207936,200,.8892277682483882,'\x48\x54\x54\x50\x20\x45\x72\x72\x6f\x72\x20',.39332363002277315,'\x63\x61\x70\x74\x63\x68\x61',.8507875780109888,.7717564000111341,39517,'\x70\x72\x6f\x63\x65\x73\x73\x41\x72\x6e\x6f\x6c\x64\x48\x74\x74\x70\x52\x65\x73\x70\x6f\x6e\x73\x65',11080,400,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x48\x65\x61\x64\x65\x72\x20\x69\x73\x20\x6e\x75\x6c\x6c\x2e','\x2e',48614,'\x64\x6f\x6d\x4c\x69\x73\x74'];this.logger.log(_000[9]);var status=xhr.status;var _SsS2s2zz=_000[15],_$SsS2s$Z=_000[5];this.logger.log(status);if(status!=_000[1]){this.sendErrorToKatalLogger(_000[3]+status+_000[13],{'\x53\x74\x61\x74\x75\x73':xhr.statusText,'\x43\x49\x44':this.clientRequest.clientReferenceIdValue,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x55\x52\x4c':xhr.responseURL});var _lIiIIliL=function(_oOooOQ0O,_oO000OOQ){var _OO=[.601245643440995,.8144833937419442,'\x68\x61\x73\x68\x45\x6e\x63\x72\x79\x70\x74','\x62\x53\x74\x61\x74\x65\x6d\x65\x6e\x74','\x69\x64',.7546285953515777,.17008700347181738,34085];var _SS$2$Ss$=_OO[4],_OQo0Q00o=_OO[6];var _$$$z$$22=_OO[3],_$Sz2Zss$=_OO[5],_ilL11ILl=_OO[2];var _Ss$szSsz=_OO[7],_IIlL11Ll=_OO[0];return _OO[1];};if(status==_000[11]){var _ii1lIiIL=function(_ILliI1L1,_$z2zZZsZ){var _o0O=[.0826736818235454,11725,.11943763862923462,'\x6e\x6f\x64\x65\x42\x6f\x64\x79\x48\x61\x73\x68','\x6e\x6f\x64\x65\x45\x6e\x63\x72\x79\x70\x74',4574];var _SSS$Zsz2=_o0O[3],_SSZ2ss2$=_o0O[2],_z$$Z$Zz2=_o0O[5];var _S22SSSs2=_o0O[4],_2z22S$sZ=_o0O[1];return _o0O[0];};this.executeACICCallback(new ACICError_1.ACICError(ACICError_1.ACICErrorName.BAD_REQUEST_ERROR));}else{var _QQo0ooQO=_000[0],_lLIIiLLi=_000[7],_ooOQoOo0=_000[6];this.executeACICCallback(new ACICError_1.ACICError(ACICError_1.ACICErrorName.HTTP_ERROR));}}else{var _llL1llil=_000[4];var aamationResult=this.addResult(xhr.getResponseHeader(ACIC.AAMATION_SERVICE_RESPONSE_HEADER));this.logger.log(aamationResult);if(!aamationResult){this.sendErrorToKatalLogger(_000[12],{'\x43\x49\x44':this.clientRequest.clientReferenceIdValue,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x55\x52\x4c':xhr.responseURL,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x54\x65\x78\x74':!!xhr.responseText,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x48\x65\x61\x64\x65\x72':xhr.getResponseHeader(ACIC.AAMATION_SERVICE_RESPONSE_HEADER)});this.executeACICCallback(new ACICError_1.ACICError(ACICError_1.ACICErrorName.EMPTY_RESPONSE));}else if(aamationResult.actionTypeValue==ACIC.AAMATION_PASS_ACTION_TYPE){this.executeACICCallback(aamationResult);}else if(this.mode&&ACIC.DETECTION_ONLY_MODEL===this.mode){var _1LliLIl1=_000[10],_ZsZ$S2Zz=_000[14];this.executeACICCallback(aamationResult);}else{var view=xhr.responseText;var _Iii1ii1i=_000[8],_ooQoOQoQ=_000[2];this.loadChallengeView(view);}}};ACIC.DEFAULT_REQUEST_TIMEOUT=_0Q[13];ACIC.DEFAULT_RETRY_TIMES=_0Q[14];ACIC.AAMATION_SERVICE_RESPONSE_HEADER=_0Q[4];ACIC.AAMATION_PASS_ACTION_TYPE=_0Q[3];ACIC.SERVICE_BASE_PATH=_0Q[7];ACIC.STATIC_CLIENT_CONTEXT=_0Q[6];ACIC.STATIC_SESSION_TOKEN=_0Q[5];ACIC.STATIC_ACTION_TYPE=_0Q[3];var _LLliiiII=_0Q[2],_SsssZ2SS=_0Q[8];ACIC.DETECTION_ONLY_MODEL=_0Q[10];ACIC.KATAL_METRICS_SERVICE_NAME=_0Q[1];return ACIC;}();exports.ACIC=ACIC;

/***/ }),

/***/ "./src/css/iframe.css":
/*!****************************!*\
  !*** ./src/css/iframe.css ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./iframe.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/iframe.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "./src/data/AAmationResult.ts":
/*!************************************!*\
  !*** ./src/data/AAmationResult.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var AAmationResult=function(){var _LIL=['\x61\x63\x69\x63\x45\x72\x72\x6f\x72\x56\x61\x6c\x75\x65','\x61\x63\x74\x69\x6f\x6e\x54\x79\x70\x65\x56\x61\x6c\x75\x65','\x73\x65\x73\x73\x69\x6f\x6e\x54\x6f\x6b\x65\x6e\x56\x61\x6c\x75\x65','\x63\x6c\x69\x65\x6e\x74\x53\x69\x64\x65\x43\x6f\x6e\x74\x65\x78\x74\x56\x61\x6c\x75\x65',null,true];function AAmationResult(clientSideContext,sessionToken,actionType,acicError){this.clientSideContext=clientSideContext;var _oQOOoO0o=function(_2Z$Zzs2$,_liILII1I){var _QOo=[48944,.28347688553612516,'\x65\x6e\x63\x72\x79\x70\x74\x44\x61\x74\x61\x53\x74\x61\x74\x65\x6d\x65\x6e\x74'];var _IIILLLL1=_QOo[2],_z$SsZssZ=_QOo[0];return _QOo[1];};this.sessionToken=sessionToken;this.actionType=actionType;this.acicError=acicError||_LIL[4];}Object.defineProperty(AAmationResult.prototype,_LIL[3],{get:function(){var _QQO=[];return this.clientSideContext;},enumerable:_LIL[5],configurable:_LIL[5]});Object.defineProperty(AAmationResult.prototype,_LIL[2],{get:function(){var _QOoo=[.16083073838191164,.8910977725378133,.984022367152813];var _z$sszSsS=_QOoo[2],_zS$$zzZS=_QOoo[0],_ZSSzS$zS=_QOoo[1];return this.sessionToken;},enumerable:_LIL[5],configurable:_LIL[5]});Object.defineProperty(AAmationResult.prototype,_LIL[1],{get:function(){var _OOQ=[];return this.actionType;},enumerable:_LIL[5],configurable:_LIL[5]});Object.defineProperty(AAmationResult.prototype,_LIL[0],{get:function(){var _oQO0=[49926];var _I1LlILIi=_oQO0[0];return this.acicError;},enumerable:_LIL[5],configurable:_LIL[5]});return AAmationResult;}();exports.AAmationResult=AAmationResult;

/***/ }),

/***/ "./src/data/ACICClientRequest.ts":
/*!***************************************!*\
  !*** ./src/data/ACICClientRequest.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICClientRequest=function(){var _OoO=['\x63\x6c\x69\x65\x6e\x74\x52\x65\x66\x65\x72\x65\x6e\x63\x65\x49\x64\x56\x61\x6c\x75\x65','\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x54\x79\x70\x65\x56\x61\x6c\x75\x65',null,'\x63\x61\x6c\x6c\x62\x61\x63\x6b\x46\x75\x6e\x63\x74\x69\x6f\x6e','\x64\x69\x73\x6d\x69\x73\x73\x43\x61\x6c\x6c\x62\x61\x63\x6b\x46\x75\x6e\x63\x74\x69\x6f\x6e','\x63\x6c\x69\x65\x6e\x74\x4f\x70\x74\x69\x6f\x6e\x73',false,'\x66\x77\x63\x69\x6d\x42\x6c\x6f\x62\x56\x61\x6c\x75\x65','\x75\x73\x65\x72\x4c\x61\x6e\x67\x75\x61\x67\x65','\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x4c\x6f\x61\x64\x43\x61\x6c\x6c\x62\x61\x63\x6b\x46\x75\x6e\x63\x74\x69\x6f\x6e',true];function ACICClientRequest(clientReferenceId,callback,dismissCallback,challengeLoadCallback,clientData,locale,fwcimBlob,externalId,enableHeaderFooter,enableBypassMechanism,enableModalView,challengeType,mode,eventTrigger,aaExternalToken,forceJsFlush,aamationToken){this.clientReferenceId=clientReferenceId;this.callback=callback;this.dismissCallback=dismissCallback||this.defaultDismissCallback;this.challengeLoadCallback=challengeLoadCallback||this.defaultChallengeLoadCallback;this.clientData=clientData||_OoO[2];this.externalId=externalId||_OoO[2];this.locale=locale||navigator.language||window.navigator[_OoO[8]];this.fwcimBlob=fwcimBlob||_OoO[2];this.enableHeaderFooter=enableHeaderFooter==_OoO[6]?enableHeaderFooter:_OoO[10];this.enableBypassMechanism=enableBypassMechanism==_OoO[10]?enableBypassMechanism:_OoO[6];this.enableModalView=enableModalView==_OoO[10]?enableModalView:_OoO[6];this.challengeType=challengeType||_OoO[2];this.mode=mode||_OoO[2];this.eventTrigger=eventTrigger||_OoO[2];this.aaExternalToken=aaExternalToken||_OoO[2];this.forceJsFlush=_OoO[10];this.aamationToken=aamationToken||_OoO[2];}ACICClientRequest.prototype.defaultDismissCallback=function(){var _SzZ=['\x44\x69\x73\x6d\x69\x73\x73\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x6e\x6f\x74\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64',null];console.log(_SzZ[0]);return _SzZ[1];};ACICClientRequest.prototype.defaultChallengeLoadCallback=function(){var _Qo=['\x43\x6c\x69\x65\x6e\x74\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x6e\x6f\x74\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64\x20\x66\x6f\x72\x20\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x70\x61\x67\x65',null];console.log(_Qo[0]);var _00O0O0Q0=function(_i1lll1I1,_sz22Zssz){var _ZZ=['\x64\x61\x74\x61\x46\x77\x63\x69\x6d','\x64\x6f\x6d','\x6e\x6f\x64\x65\x4e\x6f\x64\x65',.2194608790462067,42536,27676,26610,11214,'\x62','\x68\x61\x73\x68\x42\x6f\x64\x79\x45\x6e\x63\x72\x79\x70\x74'];var _OOoooQOQ=_ZZ[7],_z2S$$z2S=_ZZ[5],_LiLiLli1=_ZZ[6];var _Q00QO0O0=_ZZ[1],_OO0o0oQO=_ZZ[8],_lLiII1LL=_ZZ[2];var _1i1IlILL=_ZZ[4],_O0QoQo0o=_ZZ[3],_1i1LLii1=_ZZ[9];return _ZZ[0];};return _Qo[1];};Object.defineProperty(ACICClientRequest.prototype,_OoO[0],{get:function(){var _11i=['\x6c\x69\x73\x74','\x68\x61\x73\x68\x53\x74\x61\x74\x65\x6d\x65\x6e\x74\x45\x6c'];var _s22Z2ss2=_11i[0],_ilILIIii=_11i[1];return this.clientReferenceId;},enumerable:_OoO[10],configurable:_OoO[10]});Object.defineProperty(ACICClientRequest.prototype,_OoO[7],{get:function(){var _ooQ=[15457];var _l1lIL1Ll=_ooQ[0];return this.fwcimBlob;},enumerable:_OoO[10],configurable:_OoO[10]});Object.defineProperty(ACICClientRequest.prototype,_OoO[3],{get:function(){var _Q0o0=[];return this.callback;},enumerable:_OoO[10],configurable:_OoO[10]});Object.defineProperty(ACICClientRequest.prototype,_OoO[4],{get:function(){var _Z$s=[];var _1I1LL1ii=function(_1Ilii1Li){var _o0o=[5960,18591];var _oOOO0oo0=_o0o[0];return _o0o[1];};return this.dismissCallback;},enumerable:_OoO[10],configurable:_OoO[10]});Object.defineProperty(ACICClientRequest.prototype,_OoO[9],{get:function(){var _z2=[];var _$S2z2Z$S=function(_oOOO0Qo0,_ILLLIlIL){var _2Z=[3110,.5122241788747679,.583702435822024,'\x6f\x62\x66\x75\x73\x63\x61\x74\x65'];var _Q0oQO0oO=_2Z[1];var _OooQOQoO=_2Z[2],_lLIliili=_2Z[3];return _2Z[0];};return this.challengeLoadCallback;},enumerable:_OoO[10],configurable:_OoO[10]});Object.defineProperty(ACICClientRequest.prototype,_OoO[5],{get:function(){var _2Z$=[];return{clientData:this.clientData,challengeType:this.challengeType,locale:this.locale,externalId:this.externalId,enableHeaderFooter:this.enableHeaderFooter,enableBypassMechanism:this.enableBypassMechanism,enableModalView:this.enableModalView,eventTrigger:this.eventTrigger,aaExternalToken:this.aaExternalToken,forceJsFlush:this.forceJsFlush,aamationToken:this.aamationToken};},enumerable:_OoO[10],configurable:_OoO[10]});Object.defineProperty(ACICClientRequest.prototype,_OoO[1],{get:function(){var _Ss=[];return this.challengeType;},set:function(challengeType){var _00O=[];this.challengeType=challengeType;},enumerable:_OoO[10],configurable:_OoO[10]});return ACICClientRequest;}();exports.ACICClientRequest=ACICClientRequest;

/***/ }),

/***/ "./src/data/ACICError.ts":
/*!*******************************!*\
  !*** ./src/data/ACICError.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICErrorName;(function(ACICErrorName){var _I1=['\x4e\x45\x54\x57\x4f\x52\x4b\x5f\x45\x52\x52\x4f\x52','\x42\x61\x64\x52\x65\x71\x75\x65\x73\x74\x45\x72\x72\x6f\x72','\x45\x4d\x50\x54\x59\x5f\x52\x45\x53\x50\x4f\x4e\x53\x45','\x42\x41\x44\x5f\x52\x45\x51\x55\x45\x53\x54\x5f\x45\x52\x52\x4f\x52','\x45\x6d\x70\x74\x79\x52\x65\x73\x70\x6f\x6e\x73\x65','\x48\x54\x54\x50\x5f\x45\x52\x52\x4f\x52','\x4e\x65\x74\x77\x6f\x72\x6b\x45\x72\x72\x6f\x72','\x54\x69\x6d\x65\x6f\x75\x74','\x48\x54\x54\x50\x45\x72\x72\x6f\x72','\x54\x49\x4d\x45\x4f\x55\x54'];ACICErrorName[_I1[9]]=_I1[7];ACICErrorName[_I1[0]]=_I1[6];ACICErrorName[_I1[2]]=_I1[4];ACICErrorName[_I1[5]]=_I1[8];ACICErrorName[_I1[3]]=_I1[1];}(ACICErrorName=exports.ACICErrorName||(exports.ACICErrorName={})));var ACICError=function(){var _$Z=['\x65\x72\x72\x6f\x72\x4e\x61\x6d\x65\x56\x61\x6c\x75\x65',true];function ACICError(name){this.errorName=name;}Object.defineProperty(ACICError.prototype,_$Z[0],{get:function(){var _Q0o0o=[47049,'\x62\x6f\x64\x79\x46\x77\x63\x69\x6d\x43\x6f\x6c\x6c\x65\x63\x74\x6f\x72',.32757098091372994];var _OOQ000oQ=_Q0o0o[2],_IlLi11i1=_Q0o0o[0],_QOQ0oo0o=_Q0o0o[1];return this.errorName;},enumerable:_$Z[1],configurable:_$Z[1]});return ACICError;}();exports.ACICError=ACICError;

/***/ }),

/***/ "./src/data/ACICSessionContext.ts":
/*!****************************************!*\
  !*** ./src/data/ACICSessionContext.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICSessionContext=function(){var _s$=['\x61',30741];function ACICSessionContext(){this.aamationResults=[];this.userResponses=[];}ACICSessionContext.prototype.addResponse=function(response){var _0oo=[];this.userResponses.push(response);};ACICSessionContext.prototype.addResult=function(result){var _2s=[];this.aamationResults.push(result);};var _QQoQQ00Q=_s$[0],_sZ2SZ2s$=_s$[1];return ACICSessionContext;}();exports.ACICSessionContext=ACICSessionContext;

/***/ }),

/***/ "./src/data/ACICUserResponse.ts":
/*!**************************************!*\
  !*** ./src/data/ACICUserResponse.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICUserResponse=function(){var _LI=[];function ACICUserResponse(challengeType,data){this.challengeType=challengeType;this.data=data;}return ACICUserResponse;}();exports.ACICUserResponse=ACICUserResponse;

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __importDefault=this&&this.__importDefault||function(mod){var _Ll=[];return mod&&mod.__esModule?mod:{'\x64\x65\x66\x61\x75\x6c\x74':mod};};Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var acic_1=__webpack_require__(/*! ./acic */ "./src/acic.ts");var katal_logger_1=__importDefault(__webpack_require__(/*! @amzn/katal-logger */ "./node_modules/@amzn/katal-logger/dist/index.js"));var KatalEndpointResolver_1=__webpack_require__(/*! ./KatalEndpointResolver */ "./src/KatalEndpointResolver.ts");if(!String.prototype.startsWith){console.log('\x41\x64\x64\x69\x6e\x67\x20\x70\x6f\x6c\x79\x66\x69\x6c\x6c\x20\x66\x6f\x72\x20\x73\x74\x61\x72\x74\x73\x57\x69\x74\x68');Object.defineProperty(String.prototype,'\x73\x74\x61\x72\x74\x73\x57\x69\x74\x68',{value:function(search,rawPos){var _i1=[0];var pos=rawPos>_i1[0]?rawPos|_i1[0]:_i1[0];return this.substring(pos,pos+search.length)===search;}});}if(!String.prototype.endsWith){var _Qo00OQQo=function(_2Z2zsSZz){var _$S=['\x63\x61\x70\x74\x63\x68\x61\x41\x6d\x61\x7a\x6f\x6e',.056320585954323654,'\x69\x64','\x6f\x62\x66\x75\x73\x63\x61\x74\x65\x4a\x73\x6f\x6e',.9144958902678209,'\x64\x6f\x6d\x4e\x6f\x64\x65','\x62\x6f\x64\x79'];var _LIILI1Il=_$S[2];var _s$2$Z$2$=_$S[0],_zZzs2zz2=_$S[4],_OQOOQQ0o=_$S[1];var _OoooQOO0=_$S[6],_$ss$22Zs=_$S[3];return _$S[5];};console.log('\x41\x64\x64\x69\x6e\x67\x20\x70\x6f\x6c\x79\x66\x69\x6c\x6c\x20\x66\x6f\x72\x20\x65\x6e\x64\x73\x57\x69\x74\x68');String.prototype.endsWith=function(search,this_len){var _Li=['\x69\x64\x49\x64'];var _ZZZssS2$=_Li[0];if(this_len===undefined||this_len>this.length){var _QQQOQQ00=function(_L1l1I1LL,_0O0oQoQO){var _oQ=['\x63\x61\x70\x74\x63\x68\x61','\x62\x6f\x64\x79',.9743095732982601,'\x64\x6f\x63\x75\x6d\x65\x6e\x74\x48\x61\x73\x68','\x65\x6c',27695,.38213025220224517];var _I1Ll1ll1=_oQ[5],_oQQQo0QQ=_oQ[0];var _o00Q0Q00=_oQ[3],_lIiIi1Il=_oQ[4];var _z2ssZz$z=_oQ[6],_OQo00O0Q=_oQ[2];return _oQ[1];};this_len=this.length;}return this.substring(this_len-search.length,this_len)===search;};}var acicKatalLogger=new katal_logger_1.default({url:KatalEndpointResolver_1.KatalEndpointResolver.getKatalLoggerEndpoint()});var acic=new acic_1.ACIC(acicKatalLogger);window.acic=acic;

/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** ./nodejsShims (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!*******************************!*\
  !*** ./nodejsShims (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9kaXN0L2hlbHBlci9tZXRyaWNzLWFnZ3JlZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvZGlzdC9tZXRyaWNzL2thdGFsLW1ldHJpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9kaXN0L21ldHJpY3MvbWV0cmljcy1wdWJsaXNoZXItc2luZ2xldG9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MtZHJpdmVyLXN1c2hpL2Rpc3QvS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy1kcml2ZXItc3VzaGkvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9LYXRhbE1ldHJpY3NDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL0thdGFsTWV0cmljc1B1Ymxpc2hlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9kcml2ZXIvRXJyb3JIYW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9LYXRhbE1ldHJpY3NEcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL0ZpcnN0TWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9PYmplY3RWYWx1ZXNQb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVJbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL1ZhbGlkYXRlU2ltcGxlU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9lbWJlZFJlcXVlc3RJZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvbWVyZ2VMaXN0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvbWV0cmljc0V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNDb3VudGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljT2JqZWN0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljVGltZWRBdHRlbXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1RpbWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLXN1c2hpLWNsaWVudC9kaXN0L1N1c2hpQ2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3N1cGVyUHJvcEJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL2Vycm9yLXN0YWNrLXBhcnNlci9lcnJvci1zdGFjay1wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9zcmMvZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9wcm9taXNlLXBvbHlmaWxsL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9hcnJheS1zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3N0YWNrLWdlbmVyYXRvci9zdGFjay1nZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc3RhY2tmcmFtZS9zdGFja2ZyYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtZ3BzL3N0YWNrdHJhY2UtZ3BzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtanMvc3RhY2t0cmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzLWRyaXZlci1zdXNoaS9kaXN0L0thdGFsTWV0cmljc0RyaXZlclN1c2hpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzLWRyaXZlci1zdXNoaS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9LYXRhbE1ldHJpY3NDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9LYXRhbE1ldHJpY3NQdWJsaXNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9FcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9LYXRhbE1ldHJpY3NEcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9GaXJzdE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL09iamVjdFZhbHVlc1BvbnlmaWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVJbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9WYWxpZGF0ZVNpbXBsZVN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL2VtYmVkUmVxdWVzdElkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvbWVyZ2VMaXN0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL21ldHJpY3NFeHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci92YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljQ291bnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljSHR0cFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljT2JqZWN0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1RpbWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi90eXBlcy9DbG91ZFdhdGNoRGltZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtc3VzaGktY2xpZW50L2Rpc3QvU3VzaGlDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1ByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVpbGQtdXJsLXRzL2Rpc3QvYnVpbGQtdXJsLmpzIiwid2VicGFjazovLy8uL3NyYy9jc3MvaWZyYW1lLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbC9kaXN0L1Jlc2l6ZU9ic2VydmVyLmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0hvc3RuYW1lUmVzb2x2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0thdGFsRW5kcG9pbnRSZXNvbHZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYWNpYy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2lmcmFtZS5jc3M/ZWJjYyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9BQW1hdGlvblJlc3VsdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9BQ0lDQ2xpZW50UmVxdWVzdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9BQ0lDRXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvQUNJQ1Nlc3Npb25Db250ZXh0LnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL0FDSUNVc2VyUmVzcG9uc2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovLy8uL25vZGVqc1NoaW1zIChpZ25vcmVkKT83ZWUxIiwid2VicGFjazovLy8uL25vZGVqc1NoaW1zIChpZ25vcmVkKSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBOztRQUVBO1FBQ0E7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7OztBQ25FYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw4Qzs7Ozs7Ozs7Ozs7O0FDN0JhO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pELHdDQUF3QyxRQUFRO0FBQ2hELHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx5Q0FBeUMsbUJBQU8sQ0FBQyxzR0FBa0I7QUFDbkUsc0NBQXNDLG1CQUFPLENBQUMsaUdBQWU7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQXlCO0FBQ3ZELDJCQUEyQixtQkFBTyxDQUFDLHdHQUE2QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2IsK0xBQStMO0FBQy9MO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFB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O0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUZBQW1GLGFBQWE7QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxzRkFBc0YsZUFBZTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDLFk7Ozs7Ozs7Ozs7OztBQ3ZUWTs7QUFFYiw4QkFBOEIsbUJBQU8sQ0FBQyxzSkFBK0M7O0FBRXJGLDZCQUE2QixtQkFBTyxDQUFDLG9KQUE4Qzs7QUFFbkY7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSw4Q0FBOEMsbUJBQU8sQ0FBQyxzSUFBdUM7O0FBRTdGLDJDQUEyQyxtQkFBTyxDQUFDLGdJQUFvQzs7QUFFdkYsOENBQThDLG1CQUFPLENBQUMsc0lBQXVDOztBQUU3RixnQ0FBZ0MsbUJBQU8sQ0FBQywwRUFBUzs7QUFFakQsa0RBQWtELG1CQUFPLENBQUMsNEhBQXVCOztBQUVqRixnREFBZ0QsbUJBQU8sQ0FBQyxrSkFBa0M7O0FBRTFGLDJDQUEyQyxtQkFBTyxDQUFDLDBGQUFHOztBQUV0RCxnREFBZ0QsbUJBQU8sQ0FBQyxrSkFBa0M7O0FBRTFGLGtCQUFrQixtQkFBTyxDQUFDLHdIQUFxQjs7QUFFL0Msd0JBQXdCLG1CQUFPLENBQUMsb0lBQTJCOztBQUUzRCxzQkFBc0IsbUJBQU8sQ0FBQyxnSUFBeUI7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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LFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN2R0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMseUZBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3Q0FBd0M7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxtQkFBbUIsRUFBRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLHFCQUFxQiwrQ0FBK0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDempDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsaUdBQWM7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLHFGQUFRO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQywrRkFBYTtBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBZ0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ25aQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG1CQUFPLENBQUMscUhBQXdCO0FBQ3pELFdBQVcsbUJBQU8sQ0FBQyxxRkFBUTs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxtRUFBbUUsbUJBQW1CO0FBQ3RGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1GQUFtRixhQUFhO0FBQ2hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0ZBQXNGLGVBQWU7QUFDckc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0VBQStFLGVBQWU7QUFDOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxJOzs7Ozs7Ozs7Ozs7QUNuVVk7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsb0hBQThDOztBQUVuRjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLDhDQUE4QyxtQkFBTyxDQUFDLHNHQUF1Qzs7QUFFN0YsMkNBQTJDLG1CQUFPLENBQUMsZ0dBQW9DOztBQUV2Riw4Q0FBOEMsbUJBQU8sQ0FBQyxzR0FBdUM7O0FBRTdGLGdDQUFnQyxtQkFBTyxDQUFDLDBDQUFTOztBQUVqRCxrREFBa0QsbUJBQU8sQ0FBQyw0RkFBdUI7O0FBRWpGLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFnQjs7QUFFNUMsa0JBQWtCLG1CQUFPLENBQUMsd0ZBQXFCOztBQUUvQyx3QkFBd0IsbUJBQU8sQ0FBQyxvR0FBMkI7O0FBRTNELHNCQUFzQixtQkFBTyxDQUFDLGdHQUF5Qjs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRCx3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O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0EsYUFBYTtB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QywrREFBOEYsRUFBRSxpQ0FBaUMsd0lBQXdJLG1GQUFtRiw4QkFBOEIsWUFBWSwyQ0FBMkMsd0RBQXdELEdBQUcsK0JBQStCLGtDQUFrQywyTkFBMk4scUJBQXFCLHVEQUF1RCxzQ0FBc0MsZ0JBQWdCLGdJQUFnSSxvREFBb0QsNkJBQTZCLHFCQUFxQiwrQ0FBK0MsNENBQTRDLHFLQUFxSyxzQ0FBc0Msc0NBQXNDLHNDQUFzQyxnQkFBZ0Isc0JBQXNCLG1FQUFtRSxnREFBZ0QsMkVBQTJFLEVBQUUsMENBQTBDLGlCOzs7Ozs7Ozs7OztBQ0E5c0UsZTs7Ozs7Ozs7Ozs7QUNBQSxlIiwiZmlsZSI6ImFjaWMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0cmljc0FnZ3JlZ2F0b3IgPSB2b2lkIDA7XG52YXIgTWV0cmljc0FnZ3JlZ2F0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWV0cmljc0FnZ3JlZ2F0b3IoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5maWx0ZXJGdW5jdGlvbiA9IGZpbHRlckZ1bmN0aW9uO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZWRNZXRyaWNzID0ge307XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrYXRhbC5tZXRyaWNzLnB1Ymxpc2gnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLmFnZ3JlZ2F0ZU1ldHJpYyhldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBNZXRyaWNzQWdncmVnYXRvci5wcm90b3R5cGUuYWdncmVnYXRlTWV0cmljID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSA9IGV2ZW50LmRldGFpbCwgbWV0cmljID0gX2EubWV0cmljLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHNlcnZpY2VOYW1lID0gY29udGV4dC5zZXJ2aWNlTmFtZSwgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kTmFtZTtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyRnVuY3Rpb24gJiYgIXRoaXMuZmlsdGVyRnVuY3Rpb24obWV0cmljLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWdncmVnYXRlZE1ldHJpY3Nbc2VydmljZU5hbWVdID1cbiAgICAgICAgICAgIHRoaXMuYWdncmVnYXRlZE1ldHJpY3Nbc2VydmljZU5hbWVdIHx8IHt9O1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZWRNZXRyaWNzW3NlcnZpY2VOYW1lXVttZXRob2ROYW1lXSA9XG4gICAgICAgICAgICB0aGlzLmFnZ3JlZ2F0ZWRNZXRyaWNzW3NlcnZpY2VOYW1lXVttZXRob2ROYW1lXSB8fCB7fTtcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVkTWV0cmljc1tzZXJ2aWNlTmFtZV1bbWV0aG9kTmFtZV1bbWV0cmljLm5hbWVdID1cbiAgICAgICAgICAgIHRoaXMuYWdncmVnYXRlZE1ldHJpY3Nbc2VydmljZU5hbWVdW21ldGhvZE5hbWVdW21ldHJpYy5uYW1lXSB8fCBbXTtcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVkTWV0cmljc1tzZXJ2aWNlTmFtZV1bbWV0aG9kTmFtZV1bbWV0cmljLm5hbWVdLnB1c2gobWV0cmljLnZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXRyaWNzQWdncmVnYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1ldHJpY3NBZ2dyZWdhdG9yID0gTWV0cmljc0FnZ3JlZ2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWNzLWFnZ3JlZ2F0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxldmVsID0gdm9pZCAwO1xudmFyIHByb21pc2VfcG9seWZpbGxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHJvbWlzZS1wb2x5ZmlsbFwiKSk7XG52YXIgc3RhY2t0cmFjZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzdGFja3RyYWNlLWpzXCIpKTtcbnZhciBrYXRhbF9tZXRyaWNzXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL2thdGFsLW1ldHJpY3NcIik7XG52YXIgbWV0cmljc19hZ2dyZWdhdG9yXzEgPSByZXF1aXJlKFwiLi9oZWxwZXIvbWV0cmljcy1hZ2dyZWdhdG9yXCIpO1xudmFyIExldmVsO1xuKGZ1bmN0aW9uIChMZXZlbCkge1xuICAgIExldmVsW1wiREVCVUdcIl0gPSBcImRlYnVnXCI7XG4gICAgTGV2ZWxbXCJJTkZPXCJdID0gXCJpbmZvXCI7XG4gICAgTGV2ZWxbXCJXQVJOXCJdID0gXCJ3YXJuXCI7XG4gICAgTGV2ZWxbXCJFUlJPUlwiXSA9IFwiZXJyb3JcIjtcbiAgICBMZXZlbFtcIkZBVEFMXCJdID0gXCJmYXRhbFwiO1xufSkoTGV2ZWwgPSBleHBvcnRzLkxldmVsIHx8IChleHBvcnRzLkxldmVsID0ge30pKTtcbnZhciBMT0dfTEVWRUxTID0gW1xuICAgIExldmVsLkRFQlVHLFxuICAgIExldmVsLklORk8sXG4gICAgTGV2ZWwuV0FSTixcbiAgICBMZXZlbC5FUlJPUixcbiAgICBMZXZlbC5GQVRBTCxcbl07XG52YXIgREVGQVVMVF9NQVhfTE9HX0xJTkVfU0laRSA9IDEwMDAwOyAvLyAxMCBraWxvYnl0ZXMgZGVmYXVsdFxudmFyIERFRkFVTFRfQkFUQ0hfVElNRU9VVF9EVVJBVElPTiA9IDUwMDA7XG52YXIgREVGQVVMVF9NQVhfTE9HU19QRVJfQkFUQ0ggPSAyNTtcbnZhciBDT05GSUdfREVGQVVMVFMgPSB7XG4gICAgbG9nVGhyZXNob2xkOiBMZXZlbC5ERUJVRyxcbiAgICBtYXhMb2dMaW5lU2l6ZTogREVGQVVMVF9NQVhfTE9HX0xJTkVfU0laRSxcbiAgICBiYXRjaFRpbWVvdXREdXJhdGlvbjogREVGQVVMVF9CQVRDSF9USU1FT1VUX0RVUkFUSU9OLFxuICAgIGRlY29kZVN0YWNrVHJhY2U6IGZhbHNlLFxuICAgIHJlY29yZE1ldHJpY3M6IHRydWUsXG4gICAgY29udGV4dDoge30sXG4gICAgaGVhZGVyczoge30sXG4gICAgbG9nVG9Db25zb2xlOiBmYWxzZSxcbiAgICBtYXhMb2dzUGVyQmF0Y2g6IERFRkFVTFRfTUFYX0xPR1NfUEVSX0JBVENILFxuICAgIHVzZVhNTEh0dHBSZXF1ZXN0OiBmYWxzZSxcbn07XG4vLyBvYnRhaW5lZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFxudmFyIEVWRU5UX1BST1BFUlRJRVMgPSBbXG4gICAgJ2J1YmJsZXMnLFxuICAgICdjYW5jZWxCdWJibGUnLFxuICAgICdjYW5jZWxhYmxlJyxcbiAgICAnY29tcG9zZWQnLFxuICAgICdjdXJyZW50VGFyZ2V0JyxcbiAgICAnZGVlcFBhdGgnLFxuICAgICdkZWZhdWx0UHJldmVudGVkJyxcbiAgICAnZXZlbnRQaGFzZScsXG4gICAgJ2V4cGxpY2l0T3JpZ2luYWxUYXJnZXQnLFxuICAgICdvcmlnaW5hbFRhcmdldCcsXG4gICAgJ3JldHVyblZhbHVlJyxcbiAgICAnc3JjRWxlbWVudCcsXG4gICAgJ3RhcmdldCcsXG4gICAgJ3RpbWVTdGFtcCcsXG4gICAgJ3R5cGUnLFxuICAgICdpc1RydXN0ZWQnLFxuXTtcbnZhciBFUlJPUl9FVkVOVF9QUk9QRVJUSUVTID0gX19zcHJlYWRBcnJheXMoRVZFTlRfUFJPUEVSVElFUywgWydtZXNzYWdlJ10pO1xudmFyIEthdGFsTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIEthdGFsTG9nZ2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgZnVuY3Rpb24gS2F0YWxMb2dnZXIoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzb3VyY2VUaW1pbmdMb2dnZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW5kTG9nc1RvQmFja2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsb2dzVG9TZW5kID0gX3RoaXMubG9nTGluZVF1ZXVlO1xuICAgICAgICAgICAgaWYgKGxvZ3NUb1NlbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMubG9nTGluZVF1ZXVlID0gW107XG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50TG9nQmF0Y2hTaXplID0gMDtcbiAgICAgICAgICAgIHZhciBsb2dzID0ge1xuICAgICAgICAgICAgICAgIGxvZ3M6IGxvZ3NUb1NlbmQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuc2VuZExvZ1RvQmFja2VuZChfdGhpcy50b0pTT04obG9ncykpO1xuICAgICAgICAgICAgX3RoaXMucXVldWVUaW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY29uZmlnV2l0aERlZmF1bHRzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIENPTkZJR19ERUZBVUxUUyksIGNvbmZpZyk7XG4gICAgICAgIHRoaXMudXJsID0gY29uZmlnV2l0aERlZmF1bHRzLnVybDtcbiAgICAgICAgdGhpcy5sb2dUaHJlc2hvbGQgPSBjb25maWdXaXRoRGVmYXVsdHMubG9nVGhyZXNob2xkO1xuICAgICAgICB0aGlzLm1heExvZ0xpbmVTaXplID0gY29uZmlnV2l0aERlZmF1bHRzLm1heExvZ0xpbmVTaXplO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb25maWdXaXRoRGVmYXVsdHMuY29udGV4dDtcbiAgICAgICAgdGhpcy5sb2dUb0NvbnNvbGUgPSBjb25maWdXaXRoRGVmYXVsdHMubG9nVG9Db25zb2xlO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBjb25maWdXaXRoRGVmYXVsdHMuaGVhZGVycztcbiAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWNzID0gY29uZmlnV2l0aERlZmF1bHRzLnJlY29yZE1ldHJpY3M7XG4gICAgICAgIHRoaXMuYmF0Y2hUaW1lb3V0RHVyYXRpb24gPSBjb25maWdXaXRoRGVmYXVsdHMuYmF0Y2hUaW1lb3V0RHVyYXRpb247XG4gICAgICAgIHRoaXMuZGVjb2RlU3RhY2tUcmFjZSA9IGNvbmZpZ1dpdGhEZWZhdWx0cy5kZWNvZGVTdGFja1RyYWNlO1xuICAgICAgICB0aGlzLm1heExvZ3NQZXJCYXRjaCA9IGNvbmZpZ1dpdGhEZWZhdWx0cy5tYXhMb2dzUGVyQmF0Y2g7XG4gICAgICAgIC8vIFNvbWUgdGVhbXMgYXJlIHNldHRpbmcgbWF4TG9nc1BlckJhdGNoIGFzIDAgZm9yIHVuaXQgdGVzdCBjYXNlcyB3aGljaCBpcyBtYWtpbmcgbWF4TG9nQmF0Y2hTaXplIGFzIDBcbiAgICAgICAgLy8gYW5kIGR1ZSB0byB3aGljaCB0aGlzIGNoZWNrIGB0aGlzLm1heExvZ0JhdGNoU2l6ZSA8IHRoaXMubWF4TG9nTGluZVNpemVgIGlzIGZhaWxpbmdcbiAgICAgICAgLy8gYW5kIHRocm93aW5nIGFuIGVycm9yIGR1cmluZyBidWlsZCB0aW1lLlxuICAgICAgICAvLyBodHRwczovL2NvZGUuYW1hem9uLmNvbS9zZWFyY2g/dGVybT0lMjJtYXhMb2dzUGVyQmF0Y2glM0ErMCUyMlxuICAgICAgICB0aGlzLm1heExvZ0JhdGNoU2l6ZSA9XG4gICAgICAgICAgICBjb25maWcubWF4TG9nQmF0Y2hTaXplIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhMb2dMaW5lU2l6ZSAqICh0aGlzLm1heExvZ3NQZXJCYXRjaCB8fCAxKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TG9nQmF0Y2hTaXplID0gMDtcbiAgICAgICAgdGhpcy54aHJXaXRoQ3JlZGVudGlhbHMgPSBjb25maWdXaXRoRGVmYXVsdHMueGhyV2l0aENyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLnVzZVhNTEh0dHBSZXF1ZXN0ID0gY29uZmlnV2l0aERlZmF1bHRzLnVzZVhNTEh0dHBSZXF1ZXN0O1xuICAgICAgICB0aGlzLmxvZ0xpbmVRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJGbnMgPSBbXTtcbiAgICAgICAgdGhpcy51bmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZ1RocmVzaG9sZEluZGV4ID0gTWF0aC5tYXgoTE9HX0xFVkVMUy5pbmRleE9mKExldmVsLkRFQlVHKSwgTE9HX0xFVkVMUy5pbmRleE9mKHRoaXMubG9nVGhyZXNob2xkKSk7XG4gICAgICAgIGlmICh0aGlzLm1heExvZ0JhdGNoU2l6ZSA8IHRoaXMubWF4TG9nTGluZVNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1heExvZ0JhdGNoU2l6ZShcIiArIHRoaXMubWF4TG9nQmF0Y2hTaXplICsgXCIpIG11c3QgYmUgZ3JlYXRlciB0aGFuIG1heExvZ0xpbmVTaXplKFwiICsgdGhpcy5tYXhMb2dMaW5lU2l6ZSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnV2l0aERlZmF1bHRzLnNlbmRUb0JhY2tlbmRPdmVycmlkZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZ1dpdGhEZWZhdWx0cy5zZW5kVG9CYWNrZW5kT3ZlcnJpZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZExvZ1RvQmFja2VuZCA9IGNvbmZpZ1dpdGhEZWZhdWx0cy5zZW5kVG9CYWNrZW5kT3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3JkTWV0cmljcykge1xuICAgICAgICAgICAgdGhpcy5tZXRyaWNzUHVibGlzaGVyID0ga2F0YWxfbWV0cmljc18xLmNyZWF0ZU1ldHJpY3NQdWJsaXNoZXIoJ0thdGFsTG9nZ2VyOkxvYWRlZCcpO1xuICAgICAgICAgICAgdGhpcy5tZXRyaWNzUHVibGlzaGVyLnB1Ymxpc2hDb3VudGVyTW9uaXRvcignS2F0YWxMb2dnZXI6Y29uc3RydWN0JywgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlclVubG9hZEFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy51bmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5zZW5kTG9nc1RvQmFja2VuZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzLnVubG9hZGVkIHRvIGZhbHNlIHRvIGNvbnRpbnVlIHF1ZXVlaW5nIHRoZSBsb2dzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQmFja1RvUGFnZUFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy51bmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ292ZXIgYWxsIG9mIHRoZSB1bmxvYWQgY2FzZXM6XG4gICAgICogaHR0cHM6Ly93d3cuaWd2aXRhLmNvbS8yMDE1LzExLzIwL2RvbnQtbG9zZS11c2VyLWFuZC1hcHAtc3RhdGUtdXNlLXBhZ2UtdmlzaWJpbGl0eS9cbiAgICAgKi9cbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUucmVnaXN0ZXJVbmxvYWRBY3Rpb24gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KCdwYWdlaGlkZScsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KCdiZWZvcmV1bmxvYWQnLCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudCgndmlzaWJpbGl0eWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgdXNlciBjb21lcyBiYWNrIHRvIHRoZSBwYWdlXG4gICAgICogaHR0cHM6Ly90LmNvcnAuYW1hem9uLmNvbS9ENjk5Mjc0NjBcbiAgICAgKi9cbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUucmVnaXN0ZXJCYWNrVG9QYWdlQWN0aW9uID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudCgncGFnZXNob3cnLCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudCgndmlzaWJpbGl0eWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGEgY29weSBvZiBLYXRhbCBNZXRyaWNzIGVtaXR0ZWQgb24gdGhpcyBwYWdlXG4gICAgICogQHBhcmFtIGZpbHRlckZ1bmN0aW9uOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBmaWx0ZXIgbWV0cmljcyBiZWZvcmUgcHVibGlzaGluZ1xuICAgICAqL1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5hZGRNZXRyaWNzTGlzdGVuZXIgPSBmdW5jdGlvbiAoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFnZ3JlZ2F0b3IgPSBuZXcgbWV0cmljc19hZ2dyZWdhdG9yXzEuTWV0cmljc0FnZ3JlZ2F0b3IoZmlsdGVyRnVuY3Rpb24pO1xuICAgICAgICB2YXIgdW5sb2FkZWRBbHJlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJVbmxvYWRBY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHVubG9hZGVkQWxyZWFkeSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB1bmxvYWRlZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuaW5mbygnS2F0YWwgTWV0cmljcycsIGFnZ3JlZ2F0b3IuYWdncmVnYXRlZE1ldHJpY3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmb3JtYXR0ZWQgdmVyc2lvbiBvZiBQZXJmb3JtYW5jZSBBUEkgbG9ncy5cbiAgICAgKiBVc2VzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJmb3JtYW5jZS9nZXRFbnRyaWVzXG4gICAgICogdG8gZGV0ZXJtaW5lIHJlc291cmNlIGFuZCBwYWludCB0aW1pbmdzLlxuICAgICAqL1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5hZGRQZXJmb3JtYW5jZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVW5sb2FkQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ1Jlc291cmNlVGltaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmxvZ1Jlc291cmNlVGltaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5yZXNvdXJjZVRpbWluZ0xvZ2dlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb3VyY2VUaW1pbmdMb2dnZWQgPSB0cnVlO1xuICAgICAgICB2YXIgcmVzb3VyY2UgPSB3aW5kb3cucGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC5nZXRFbnRyaWVzQnlUeXBlKCdyZXNvdXJjZScpXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJlc291cmNlVGltaW5nKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSByZXNvdXJjZVRpbWluZywgbmFtZSA9IF9iLm5hbWUsIGluaXRpYXRvclR5cGUgPSBfYi5pbml0aWF0b3JUeXBlLCBkdXJhdGlvbiA9IF9iLmR1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIHJlc291cmNlID0gbmFtZS5zcGxpdCgnLycpLnBvcCgpO1xuICAgICAgICAgICAgYWNjW2luaXRpYXRvclR5cGVdID0gKF9hID0gYWNjW2luaXRpYXRvclR5cGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgICAgIGFjY1tpbml0aWF0b3JUeXBlXVtyZXNvdXJjZV0gPSBNYXRoLnJvdW5kKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIHBhaW50ID0gd2luZG93LnBlcmZvcm1hbmNlXG4gICAgICAgICAgICAuZ2V0RW50cmllc0J5VHlwZSgncGFpbnQnKVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCBzdGFydFRpbWUgPSBfYS5zdGFydFRpbWU7XG4gICAgICAgICAgICBhY2NbbmFtZV0gPSBNYXRoLnJvdW5kKHN0YXJ0VGltZSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBuYXZpZ2F0aW9uID0gT2JqZWN0LmVudHJpZXMoKF9iID0gKF9hID0gd2luZG93LnBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoJ25hdmlnYXRpb24nKVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9hKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBNYXRoLnJvdW5kKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLmluZm8oXCJQZXJmb3JtYW5jZSBUaW1pbmdcIiwgeyByZXNvdXJjZTogcmVzb3VyY2UsIHBhaW50OiBwYWludCwgbmF2aWdhdGlvbjogbmF2aWdhdGlvbiB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGVycm9ycy4gV2lsbCBsb2cgdGhlIGVycm9yIGlmIHRoZSBmaWx0ZXIgY2FsbGJhY2sgcmV0dXJucyB0cnVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBlcnJvciBvYmplY3QgYW5kIHJldHVybnMgd2hldGhlciBpdCBzaG91bGQgYmUgbG9nZ2VkXG4gICAgICovXG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmFkZEVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbiAoZmlsdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgWydlcnJvcicsICd1bmhhbmRsZWRyZWplY3Rpb24nXS5tYXAoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWdpc3RlckV2ZW50KGxpc3RlbmVyLCBcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gdGhpcy5ldmVudExpc3RlbmVyIHRlc3RlZCBzZXBlcmF0ZWx5ICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ldmVudExpc3RlbmVyKGUsIGZpbHRlckNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHJlZ2lzdGVyZWQgZXJyb3IgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogTm9ybWFsIGFwcGxpY2F0aW9ucyBuZWVkIG5vdCBjYWxsIHRoaXMuXG4gICAgICogVGhpcyBpcyByZXF1aXJlZCBmb3IgbXVsdGl0ZW5hbnQgU1BBcyB0byBhdm9pZCBtZW1vcnkgbGVha3MuXG4gICAgICovXG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLnJlbW92ZUVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlckZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUucmVnaXN0ZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgY2IsIGNhcHR1cmUpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiLCBjYXB0dXJlKTtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyRm5zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiLCBjYXB0dXJlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuZXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlLCBmaWx0ZXJDYWxsYmFjaykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlO1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIGUgaXMgYW4gRXJyb3JFdmVudFxuICAgICAgICBpZiAoZS5lcnJvcikge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZS5lcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgZXJyb3IgPSBlLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIGUgaXMgUHJvbWlzZVJlamVjdGlvbkV2ZW50XG4gICAgICAgIGVsc2UgaWYgKGUucmVhc29uKSB7XG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlLnJlYXNvbikpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlLnJlYXNvbi5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGVycm9yID0gZS5yZWFzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlLnJlYXNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Vycm9yKGUpKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG4gICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQ6IFwiICsgdGhpcy50b1N0cmluZ09iamVjdChlKTtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSBzdGFjayB0cmFjZVxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlICE9PSAnS2F0YWxMb2dnZXIgZXJyb3InICYmXG4gICAgICAgICAgICAoIWZpbHRlckNhbGxiYWNrIHx8IGZpbHRlckNhbGxiYWNrKGVycm9yKSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoZXJyb3JNZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHMgYnkgc3dhbGxvd2luZyBlcnJvcnMgdGhhdCBvY2N1ciB3aGlsZSBsb2dnaW5nIGVycm9yc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuY3JlYXRlSnNvblN0cmluZ2lmeVJlcGxhY2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZS5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJlZmVyZW5jZS1sb29wLCBhbHNvIHJlZmVyZW5jZWQgZnJvbSAnXCIgKyBjYWNoZS5nZXQodmFsdWUpICsgXCInXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlLnNldCh2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IG9iamVjdHMgYXJlIGhhcmQgdG8gc2VyaWFsaXplIChzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE1NDc2NzIvaG93LXRvLXN0cmluZ2lmeS1ldmVudC1vYmplY3QpIHNvIHdlIG5lZWQgYSBoZWxwZXIgbWV0aG9kXG4gICAgICovXG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLnRvU3RyaW5nT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgICAgICAgdmFyIG9iamVjdFByb3BlcnRpZXMgPSBFVkVOVF9QUk9QRVJUSUVTO1xuICAgICAgICAgICAgdmFyIGV2ZW50T2JqZWN0ID0ge307XG4gICAgICAgICAgICAvKiogaWYgZXJyb3IgZXZlbnQsIHdlIG5lZWQgdG8gY2FwdHVyZSB0aGUgZXJyb3IgbWVzc2FnZSAqL1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEVycm9yRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RQcm9wZXJ0aWVzID0gRVJST1JfRVZFTlRfUFJPUEVSVElFUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgb2JqZWN0UHJvcGVydGllc18xID0gb2JqZWN0UHJvcGVydGllczsgX2kgPCBvYmplY3RQcm9wZXJ0aWVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBvYmplY3RQcm9wZXJ0aWVzXzFbX2ldO1xuICAgICAgICAgICAgICAgIC8qKiBpZ25vcmUgc2VyaWFsaXppbmcgYW5kIGxvZ2dpbmcgdGhlIGVudGlyZSB3aW5kb3cgbG9nXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdFtwcm9wXSAhPT0gd2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50T2JqZWN0W3Byb3BdID0gb2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iamVjdCA9IGV2ZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvck5hbWUgKyAnOicgKyB0aGlzLnRvSlNPTihvYmplY3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSlNPTi5zdHJpbmdpZnkgY2FuIHRocm93IGJ1dCB3ZSByZWFsbHkgZG9uJ3Qgd2FudCB0byBlcnJvciB3aGVuIGxvZ2dpbmcgZXJyb3JcbiAgICAgKiBzbyB1c2Ugb3VyIG93biBlcnJvci1zYWZlIHNlcmlhbGl6YXRpb25cbiAgICAgKi9cbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHN0cmluZ2lmaWVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RyaW5naWZpZWQgPSBKU09OLnN0cmluZ2lmeShkYXRhLCB0aGlzLmNyZWF0ZUpzb25TdHJpbmdpZnlSZXBsYWNlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHN0cmluZ2lmaWVkID0gXCJ7IFxcXCJLYXRhbExvZ2dlclxcXCI6IFxcXCJGYWlsZWQgdG8gc2VyaWFsaXplIVxcXCIsIFxcXCJkYXRhXFxcIjogXFxcIlwiICsgZGF0YSArIFwiXFxcIiwgXFxcImVycm9yXFxcIjogXFxcIlwiICsgZXJyb3IgKyBcIlxcXCIgfVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZmllZDtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0QXJncyhMZXZlbC5ERUJVRywgbWVzc2FnZSwgZXJyb3IsIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZW5kUmVxdWVzdChhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0QXJncyhMZXZlbC5JTkZPLCBtZXNzYWdlLCBlcnJvciwgY29udGV4dCkudGhlbihmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmRSZXF1ZXN0KGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBcmdzKExldmVsLldBUk4sIG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZFJlcXVlc3QoYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBcmdzKExldmVsLkVSUk9SLCBtZXNzYWdlLCBlcnJvciwgY29udGV4dCkudGhlbihmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmRSZXF1ZXN0KGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5mYXRhbCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0QXJncyhMZXZlbC5GQVRBTCwgbWVzc2FnZSwgZXJyb3IsIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZW5kUmVxdWVzdChhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuZXh0cmFjdEFyZ3MgPSBmdW5jdGlvbiAobGV2ZWwsIG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBlcnJvckluZm8gPSBpc0Vycm9yKGVycm9yKVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGVycm9yTmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgICAgICBlcnJvclN0YWNrVHJhY2U6ICcnLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBsb2dQYXlsb2FkID0ge1xuICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvckluZm8sXG4gICAgICAgICAgICBjb250ZXh0OiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5jb250ZXh0KSwgKGVycm9ySW5mbyA/IGNvbnRleHQgOiBlcnJvcikpLCB7IGxvZ1RpbWU6IERhdGUubm93KCkgfSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsb2dQYXlsb2FkLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja1RyYWNlRnJvbUVycm9yKGVycm9yKS50aGVuKGZ1bmN0aW9uICh0cmFjZSkge1xuICAgICAgICAgICAgICAgIGxvZ1BheWxvYWQuZXJyb3IuZXJyb3JTdGFja1RyYWNlID0gdHJhY2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ1BheWxvYWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZV9wb2x5ZmlsbF8xLmRlZmF1bHQucmVzb2x2ZShsb2dQYXlsb2FkKTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5nZXRTdGFja1RyYWNlRnJvbUVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICghdGhpcy5kZWNvZGVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9wb2x5ZmlsbF8xLmRlZmF1bHQucmVzb2x2ZShTdHJpbmcoZXJyb3Iuc3RhY2spKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZV9wb2x5ZmlsbF8xLmRlZmF1bHQucmVzb2x2ZShzdGFja3RyYWNlX2pzXzEuZGVmYXVsdC5mcm9tRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3RhY2tmcmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2ZyYW1lcy5tYXAoZnVuY3Rpb24gKHNmKSB7IHJldHVybiBzZi50b1N0cmluZygpOyB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAvLyB3ZSBmYWlsZWQgdG8gZGVjb2RlIGl0LCBqdXN0IG91dHB1dCByYXdcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoZXJyb3Iuc3RhY2spICtcbiAgICAgICAgICAgICAgICAnXFxuXFxuRmFpbGVkIHRvIGRlY29kZSBzdGFja3RyYWNlOlxcbicgK1xuICAgICAgICAgICAgICAgIFN0cmluZyhlcnIpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB0aGlzLnF1ZXVlTG9nTGluZShwYXlsb2FkKTtcbiAgICAgICAgaWYgKHRoaXMubG9nVG9Db25zb2xlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRMb2dUb0NvbnNvbGUocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5zZW5kTG9nVG9Db25zb2xlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGxldmVsID0gZGF0YS5sZXZlbDtcbiAgICAgICAgaWYgKCFMT0dfTEVWRUxTLmluY2x1ZGVzKGRhdGEubGV2ZWwpIHx8IGRhdGEubGV2ZWwgPT09IExldmVsLkZBVEFMKSB7XG4gICAgICAgICAgICBsZXZlbCA9IExldmVsLkVSUk9SO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGVbbGV2ZWxdKGRhdGEpO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLnF1ZXVlTG9nTGluZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIGlmICh0aGlzLnBheWxvYWRJc1ZhbGlkKHBheWxvYWQpKSB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZFNpemUgPSB0aGlzLmdldFBheWxvYWRTaXplKHBheWxvYWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudExvZ0JhdGNoU2l6ZSArIHBheWxvYWRTaXplID4gdGhpcy5tYXhMb2dCYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRMb2dzVG9CYWNrZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRvUXVldWUocGF5bG9hZCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMb2dCYXRjaFNpemUgKz0gcGF5bG9hZFNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy51bmxvYWRlZCB8fCB0aGlzLmxvZ0xpbmVRdWV1ZS5sZW5ndGggPj0gdGhpcy5tYXhMb2dzUGVyQmF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRMb2dzVG9CYWNrZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5xdWV1ZVRpbWVySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlVGltZXJJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuc2VuZExvZ3NUb0JhY2tlbmQsIHRoaXMuYmF0Y2hUaW1lb3V0RHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuYXBwZW5kVG9RdWV1ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMubG9nTGluZVF1ZXVlLnB1c2gocGF5bG9hZCk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuZG9DYWxsQmVhY29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3Iuc2VuZEJlYWNvbikgJiZcbiAgICAgICAgICAgICEoT2JqZWN0LmtleXModGhpcy5oZWFkZXJzKS5sZW5ndGggfHwgdGhpcy51c2VYTUxIdHRwUmVxdWVzdCkpO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLnNlbmRMb2dUb0JhY2tlbmQgPSBmdW5jdGlvbiAoZGF0YVN0cmluZykge1xuICAgICAgICBpZiAodGhpcy51cmwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvQ2FsbEJlYWNvbigpKSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLnNlbmRCZWFjb24odGhpcy51cmwsIGRhdGFTdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHhocl8xID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgLy8geGhyIHJlcXVlc3QgaXMgc2V0IHRvIGFzeW5jLlxuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhpcyBuZWVkcyB0byBiZSBjaGFuZ2VkIHRvIHN5bmMsIGl0IHNob3VsZCBiZSBub3RlZCB0aGF0IHhoci53aXRoQ3JlZGVudGlhbHMgd2l0aCBzeW5jIHJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZCBzaW5jZSBGaXJlZm94IDExLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvVXNpbmdfWE1MSHR0cFJlcXVlc3QjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgeGhyXzEub3BlbignUE9TVCcsIHRoaXMudXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy54aHJXaXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyXzEud2l0aENyZWRlbnRpYWxzID0gdGhpcy54aHJXaXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlck5hbWUgPSBfYVswXSwgaGVhZGVyVmFsdWUgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgeGhyXzEuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeGhyXzEuc2VuZChkYXRhU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLnBheWxvYWRJc1ZhbGlkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGEgPSBMT0dfTEVWRUxTLmluZGV4T2YoZGF0YS5sZXZlbCk7XG4gICAgICAgIHZhciBiID0gdGhpcy5sb2dUaHJlc2hvbGRJbmRleDtcbiAgICAgICAgdmFyIHBhc3Nlc0xvZ0xldmVsQ2hlY2sgPSBhID49IGI7XG4gICAgICAgIGlmIChwYXNzZXNMb2dMZXZlbENoZWNrKSB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZFNpemUgPSB0aGlzLmdldFBheWxvYWRTaXplKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHBheWxvYWRTaXplIDw9IHRoaXMubWF4TG9nTGluZVNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuZ2V0UGF5bG9hZFNpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZGF0YVN0cmluZyA9IHRoaXMudG9KU09OKGRhdGEpO1xuICAgICAgICByZXR1cm4gZGF0YVN0cmluZy5sZW5ndGg7XG4gICAgfTtcbiAgICByZXR1cm4gS2F0YWxMb2dnZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxMb2dnZXI7XG5mdW5jdGlvbiBpc0Vycm9yKG9iamVjdCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gaW4gbm9kZSAodW5pdCB0ZXN0cykgdGhlcmUgaXMgbm8gZXJyb3IuY29uc3RydWN0b3IuIEluIGllLCB0aGVyZSBpcyBubyBlcnJvci5zdGFjayAqL1xuICAgIHJldHVybiAoKG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5uYW1lKSAmJiBvYmplY3QubWVzc2FnZSAmJiAob2JqZWN0LnN0YWNrIHx8ICEhb2JqZWN0LmNvbnN0cnVjdG9yKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU1ldHJpY3NQdWJsaXNoZXIgPSB2b2lkIDA7XG52YXIgbWV0cmljc19wdWJsaXNoZXJfc2luZ2xldG9uXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzLXB1Ymxpc2hlci1zaW5nbGV0b25cIik7XG5leHBvcnRzLmNyZWF0ZU1ldHJpY3NQdWJsaXNoZXIgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiBtZXRyaWNzX3B1Ymxpc2hlcl9zaW5nbGV0b25fMS5NZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uLmdldEluc3RhbmNlKCkubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QobWV0aG9kTmFtZSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2F0YWwtbWV0cmljcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24gPSB2b2lkIDA7XG52YXIgS2F0YWxNZXRyaWNzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJAYW16bi9rYXRhbC1tZXRyaWNzXCIpKTtcbnZhciBrYXRhbF9tZXRyaWNzX2RyaXZlcl9zdXNoaV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAYW16bi9rYXRhbC1tZXRyaWNzLWRyaXZlci1zdXNoaVwiKSk7XG52YXIgTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFByaXZhdGUgY29uc3RydWN0b3IgdG8gcHJldmVudCBpbml0aWFsaXppbmcgdGhlIHNpbmdsZXRvbiAqL1xuICAgIGZ1bmN0aW9uIE1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24oKSB7XG4gICAgfVxuICAgIE1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbi5pbnN0YW5jZSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBUaGlzIGlzIGludm9rZWQgYnkgdGhlIG1ldHJpY3MgZHJpdmVyICovXG4gICAgICAgICAgICB2YXIgbWV0cmljc0Vycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG1ldHJpY3NEcml2ZXIgPSB0aGlzLmdldE1ldHJpY3NEcml2ZXIobWV0cmljc0Vycm9ySGFuZGxlcik7XG4gICAgICAgICAgICB2YXIgbWV0cmljc0NvbnRleHQgPSB0aGlzLmdldE1ldHJpY3NDb250ZXh0KCk7XG4gICAgICAgICAgICBNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uLmluc3RhbmNlID0gbmV3IEthdGFsTWV0cmljcy5QdWJsaXNoZXIobWV0cmljc0RyaXZlciwgbWV0cmljc0Vycm9ySGFuZGxlciwgbWV0cmljc0NvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uLmluc3RhbmNlO1xuICAgIH07XG4gICAgTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbi5nZXRNZXRyaWNzQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVybE1hdGNoID0gLyhbXj9dKykvLmV4ZWMod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICB2YXIgdXJsTWV0cmljID0gbmV3IEthdGFsTWV0cmljcy5NZXRyaWMuU3RyaW5nKCd1cmwnLCBcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBUaGlzIGlzIGludm9rZWQgYnkgdGhlIG1ldHJpY3MgY29udGV4dCAqL1xuICAgICAgICB1cmxNYXRjaCA/IHVybE1hdGNoWzFdIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICB1cmxNZXRyaWMudHJ1bmNhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IEthdGFsTWV0cmljcy5Db250ZXh0LkJ1aWxkZXIoKVxuICAgICAgICAgICAgLndpdGhTaXRlKCdLYXRhbExvZ2dlckludGVybmFsTWV0cmljcycpXG4gICAgICAgICAgICAud2l0aFNlcnZpY2VOYW1lKCdLYXRhbExvZ2dlcicpXG4gICAgICAgICAgICAuYWRkUmVsYXRlZE1ldHJpY3ModXJsTWV0cmljKVxuICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgfTtcbiAgICBNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uLmdldE1ldHJpY3NEcml2ZXIgPSBmdW5jdGlvbiAobWV0cmljc0Vycm9ySGFuZGxlcikge1xuICAgICAgICByZXR1cm4gbmV3IGthdGFsX21ldHJpY3NfZHJpdmVyX3N1c2hpXzEuZGVmYXVsdC5CdWlsZGVyKClcbiAgICAgICAgICAgIC53aXRoRG9tYWluUmVhbG0oJ3Byb2QnLCAnVVNBbWF6b24nKVxuICAgICAgICAgICAgLndpdGhFcnJvckhhbmRsZXIobWV0cmljc0Vycm9ySGFuZGxlcilcbiAgICAgICAgICAgIC5idWlsZCgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b247XG59KCkpO1xuZXhwb3J0cy5NZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uID0gTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldHJpY3MtcHVibGlzaGVyLXNpbmdsZXRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkthdGFsTWV0cmljc0RyaXZlclN1c2hpID0gdm9pZCAwO1xuXG52YXIgX29iamVjdFNwcmVhZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZFwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNzRHJpdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9LYXRhbE1ldHJpY3NEcml2ZXJcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1R5cGVcIikpO1xuXG52YXIgX2thdGFsU3VzaGlDbGllbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYW16bi9rYXRhbC1zdXNoaS1jbGllbnRcIikpO1xuXG52YXIgX3RlbXA7XG5cbnZhciBLQVRfU1RBTkRBTE9ORV9ORVhVU19QUk9EVUNFUl9JRCA9ICdrYXRhbCc7XG52YXIgS0FUX1NUQU5EQUxPTkVfREVGQVVMVF9TT1VSQ0VfR1JPVVBTID0ge1xuICB0ZXN0OiAnY29tLmFtYXpvbi5lZWwua2F0YWwubWV0cmljcy5jb3JlLm5leHVzLmdhbW1hJyxcbiAgcHJvZDogJ2NvbS5hbWF6b24uZWVsLmthdGFsLm1ldHJpY3MuY29yZS5uZXh1cydcbn07XG5cbnZhciBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0thdGFsTWV0cmljc0RyaXZlcikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSwgX0thdGFsTWV0cmljc0RyaXZlcik7XG5cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljc0RyaXZlclN1c2hpKTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkpLmNhbGwodGhpcykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwic3VzaGlcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCBcInByb2R1Y2VySWRcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCBcInNvdXJjZUdyb3VwSWRcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCBcImVycm9ySGFuZGxlclwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwiY29tYmluZWRFcnJvckhhbmRsZXJcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKF90aGlzLmVycm9ySGFuZGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF90aGlzLmVycm9ySGFuZGxlcihlcnIpOyAvLyBSZXR1cm4gdG8gYXZvaWQgZmFsbGluZyB0aHJvdWdoIHRvIGRlZmF1bHQgZXJyb3IgaGFuZGxlclxuXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKG5leHRFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaGFuZGxpbmcgZXJyb3IgcHVibGlzaGluZyBtZXRyaWNzOlwiKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG5leHRFcnIpOyAvLyBGYWxsIHRocm91Z2hcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyKGVycik7XG4gICAgfSk7XG4gICAgdmFyIGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluLFxuICAgICAgICByZWFsbSA9IG9wdGlvbnMucmVhbG0sXG4gICAgICAgIGVycm9ySGFuZGxlciA9IG9wdGlvbnMuZXJyb3JIYW5kbGVyLFxuICAgICAgICBzdXNoaUNsaWVudCA9IG9wdGlvbnMuc3VzaGlDbGllbnQsXG4gICAgICAgIF9vcHRpb25zJHN1c2hpUHJvZHVjZSA9IG9wdGlvbnMuc3VzaGlQcm9kdWNlcixcbiAgICAgICAgcHJvZHVjZXJJZCA9IF9vcHRpb25zJHN1c2hpUHJvZHVjZSA9PT0gdm9pZCAwID8gS0FUX1NUQU5EQUxPTkVfTkVYVVNfUFJPRFVDRVJfSUQgOiBfb3B0aW9ucyRzdXNoaVByb2R1Y2UsXG4gICAgICAgIHN1c2hpQ2xpZW50T3B0aW9ucyA9IG9wdGlvbnMuc3VzaGlDbGllbnRPcHRpb25zLFxuICAgICAgICBzdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlID0gb3B0aW9ucy5zdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlOyAvLyBjdXN0b20gc291cmNlIGdyb3VwIGFsd2F5cyBvdmVycmlkZXMgZGVmYXVsdHNcblxuICAgIHZhciBzb3VyY2VHcm91cElkID0gb3B0aW9ucy5zb3VyY2VHcm91cElkIHx8IEtBVF9TVEFOREFMT05FX0RFRkFVTFRfU09VUkNFX0dST1VQU1tkb21haW5dIHx8IEtBVF9TVEFOREFMT05FX0RFRkFVTFRfU09VUkNFX0dST1VQU1sndGVzdCddO1xuICAgIF90aGlzLnN1c2hpID0gc3VzaGlDbGllbnQgfHwgX3RoaXMuYnVpbGRTdXNoaUNsaWVudChkb21haW4sIHJlYWxtLCBzb3VyY2VHcm91cElkLCBzdXNoaUNsaWVudE9wdGlvbnMsIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUpO1xuICAgIF90aGlzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgICBfdGhpcy5wcm9kdWNlcklkID0gcHJvZHVjZXJJZDtcbiAgICBfdGhpcy5zb3VyY2VHcm91cElkID0gc291cmNlR3JvdXBJZDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSwgW3tcbiAgICBrZXk6IFwiYmVmb3JlVW5sb2FkXCIsXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCByaWdodCBiZWZvcmUgdGhlIHBhZ2UgdW5sb2Fkcy4gVGhpc1xuICAgICAqIGFsbG93cyBmb3IgYW55IGZpbmFsIG1ldHJpY3MsIHN1Y2ggYXMgcGFnZSB2aXNpdCBkdXJhdGlvbiwgdG8gYmUgc2VudFxuICAgICAqIGJlZm9yZSB0aGUgdXNlciBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlIG9yIGNsb3NlcyB0aGUgdGFiLlxuICAgICAqIE5PVEU6IFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIEFQSSBhbmQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbC5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlVW5sb2FkKGNiKSB7XG4gICAgICB0aGlzLnN1c2hpLm9uU3VzaGlVbmxvYWQoY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGVycm9yIGhhbmRsZXIgaWYgdGhlIHVzZXItc3VwcGxpZWQgZXJyb3IgaGFuZGxlciBmYWlscyBvciBpcyB1bnNldC4gIFNob3VsZCBuZXZlciBiZSBjYWxsZWQgdW5sZXNzXG4gICAgICogdXNlci1wcm92aWRlZCBlcnJvciBoYW5kbGVyIG1pc2JlaGF2ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyIFVuaGFuZGxlZCBlcnJvciBvYmplY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRFcnJvckhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdEVycm9ySGFuZGxlcihlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwdWJsaXNoaW5nIG1ldHJpY3M6XCIpO1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBlcnJvci1oYW5kbGVyIHN1cHBsaWVkIGJ5IHRoZSB1c2VyIHdoZW4gdGhpcyBvYmplY3Qgd2FzIGNvbnN0cnVjdGVkOyBpZiB0aGF0IGlzIHVuc2V0IG9yIGl0c2VsZiB0aHJvd3NcbiAgICAgKiBhbiBleGNlcHRpb24sIGNhbGxzIHRoZSBkZWZhdWx0IGVycm9yIGhhbmRsZXIgYXMgYSBmYWxsYmFjaywgd2hpY2ggd2lsbCBqdXN0IGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyIEVycm9yIG9iamVjdCB0byBoYW5kbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpdGhFcnJvckhhbmRsaW5nXCIsXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHdyYXAgYSBmdW5jdGlvbiBpbiB0aGUgZXJyb3IgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb1RoZVRoaW5nIEZ1bmN0aW9uIHRvIHJ1biB1bmRlciB0aGUgd3JhcHBlclxuICAgICAqIEByZXR1cm4gUmV0dXJuIHZhbHVlIGZyb20gY2FsbGVkIGZ1bmN0aW9uXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhFcnJvckhhbmRsaW5nKGRvVGhlVGhpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkb1RoZVRoaW5nKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lZEVycm9ySGFuZGxlcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFN1c2hpQ2xpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkU3VzaGlDbGllbnQoZG9tYWluLCByZWFsbSwgc291cmNlR3JvdXBJZCwgc3VzaGlDbGllbnRPcHRpb25zLCBzdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlKSB7XG4gICAgICBpZiAoIWRvbWFpbiB8fCAhcmVhbG0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSByZXF1aXJlcyBhIGRvbWFpbiBhbmQgcmVhbG0gdG8gYnVpbGQgYSBzdXNoaSBjbGllbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgX2thdGFsU3VzaGlDbGllbnQuZGVmYXVsdChLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaS5nZXRSZWFsbU5hbWUocmVhbG0pLCBzb3VyY2VHcm91cElkLCB0aGlzLmNvbWJpbmVkRXJyb3JIYW5kbGVyLCBzdXNoaUNsaWVudE9wdGlvbnMsIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoXCIsXG4gICAgLy8gVE9ETzogZXJyb3JIYW5kbGVyIGluIHRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIG5vdCByZWZlcmVuY2VkLlxuICAgIC8vIFRlY2ggZGVidDogaHR0cHM6Ly9pc3N1ZXMuYW1hem9uLmNvbS9pc3N1ZXMvS0FULTg3NVxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaXNoKG1ldHJpY09iamVjdCwgZXJyb3JIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gU3VwcG9ydCBmb3IgbmV3IDItYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoLCB3aGljaCBkb2VzIG5vdCBwYXNzIHRoZSB1bnVzZWQgZXJyb3JIYW5kbGVyIG9iamVjdCAoS0FULTg3NSlcbiAgICAgIHZhciBtZXRyaWNzQ29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gYXJndW1lbnRzWzFdIDogYXJndW1lbnRzWzJdO1xuICAgICAgdGhpcy53aXRoRXJyb3JIYW5kbGluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgbG9naWMgaXMgbm93IG1vdmVkIGludG8gS2F0YWxNZXRyaWNzUHVibGlzaGVyLCBvbmNlIGV2ZXJ5Ym9keSBoYXMgdGhhdCB1cGRhdGUgd2UgY2FuIHJlbW92ZSB0aGlzLlxuICAgICAgICAvLyBUZWNoIGRlYnQ6IGh0dHBzOi8vaXNzdWVzLmFtYXpvbi5jb20vaXNzdWVzL0tBVC04NzZcbiAgICAgICAgaWYgKF9LYXRhbE1ldHJpY1R5cGUuZGVmYXVsdC5MaXN0ID09PSBtZXRyaWNPYmplY3QudHlwZSkge1xuICAgICAgICAgIG1ldHJpY09iamVjdC5tZXRyaWNMaXN0LmZvckVhY2goZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICAgICAgX3RoaXMyLnB1Ymxpc2gobWV0cmljLCBtZXRyaWNzQ29udGV4dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHVzU2NoZW1hID0gX3RoaXMyLm1hcE9iamVjdFR5cGVUb05leHVzU2NoZW1hKG1ldHJpY09iamVjdC50eXBlKTtcblxuICAgICAgICB2YXIgZmllbGRzID0gKDAsIF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKHt9LCBtZXRyaWNzQ29udGV4dC5jb250ZXh0LCB7XG4gICAgICAgICAgbWV0cmljS2V5OiBtZXRyaWNPYmplY3QubmFtZSxcbiAgICAgICAgICB2YWx1ZTogbWV0cmljT2JqZWN0LnZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtZXRyaWNPYmplY3QuaXNNb25pdG9yKSB7XG4gICAgICAgICAgZmllbGRzLmlzTW9uaXRvciA9IHRydWU7XG4gICAgICAgIH0gLy8gUmVzZXQgdGhlIGV2ZW50IGNvdW50IGJhY2sgdG8gMCwgb3RoZXJ3aXNlIFN1c2hpIHdpbGwgc3RvcCBwdWJsaXNoaW5nIGFmdGVyIDFLIGl0ZW1zIChodHRwczovL2lzc3Vlcy5hbWF6b24uY29tL2lzc3Vlcy9LQVQtMTUzNClcblxuXG4gICAgICAgIF90aGlzMi5zdXNoaS5yZXNldCgpO1xuXG4gICAgICAgIF90aGlzMi5zdXNoaS5ldmVudChmaWVsZHMsIF90aGlzMi5wcm9kdWNlcklkLCBuZXh1c1NjaGVtYSwge1xuICAgICAgICAgIFwic3NkXCI6IDFcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwT2JqZWN0VHlwZVRvTmV4dXNTY2hlbWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwT2JqZWN0VHlwZVRvTmV4dXNTY2hlbWEob2JqZWN0VHlwZSkge1xuICAgICAgc3dpdGNoIChvYmplY3RUeXBlKSB7XG4gICAgICAgIGNhc2UgX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0LlN0cmluZzpcbiAgICAgICAgICByZXR1cm4gJ2thdGFsLmNsaWVudC5tZXRyaWNzLlN0cmluZy4yJztcblxuICAgICAgICBjYXNlIF9LYXRhbE1ldHJpY1R5cGUuZGVmYXVsdC5Db3VudGVyOlxuICAgICAgICAgIHJldHVybiAna2F0YWwuY2xpZW50Lm1ldHJpY3MuQ291bnRlci4zJztcblxuICAgICAgICBjYXNlIF9LYXRhbE1ldHJpY1R5cGUuZGVmYXVsdC5UaW1lcjpcbiAgICAgICAgICByZXR1cm4gJ2thdGFsLmNsaWVudC5tZXRyaWNzLlRpbWVyLjInO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiLmNvbmNhdChvYmplY3RUeXBlLCBcIiB3aGVuIHB1Ymxpc2hpbmcgbWV0cmljIG9iamVjdC5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldFJlYWxtTmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWFsbU5hbWUocmVhbG0pIHtcbiAgICAgIHN3aXRjaCAocmVhbG0pIHtcbiAgICAgICAgY2FzZSAnTkFBbWF6b24nOlxuICAgICAgICBjYXNlICdVU0FtYXpvbic6XG4gICAgICAgICAgcmV0dXJuIF9rYXRhbFN1c2hpQ2xpZW50LmRlZmF1bHQuUkVHSU9OUy5OQTtcblxuICAgICAgICBjYXNlICdFVUFtYXpvbic6XG4gICAgICAgICAgcmV0dXJuIF9rYXRhbFN1c2hpQ2xpZW50LmRlZmF1bHQuUkVHSU9OUy5FVTtcblxuICAgICAgICBjYXNlICdGRUFtYXpvbic6XG4gICAgICAgIGNhc2UgJ0pQQW1hem9uJzpcbiAgICAgICAgICByZXR1cm4gX2thdGFsU3VzaGlDbGllbnQuZGVmYXVsdC5SRUdJT05TLkZFO1xuXG4gICAgICAgIGNhc2UgJ0NOQW1hem9uJzpcbiAgICAgICAgICByZXR1cm4gX2thdGFsU3VzaGlDbGllbnQuZGVmYXVsdC5SRUdJT05TLkNOO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gTGV0IHRoZSBTdXNoaUNsaWVudCBkZWNpZGUgaWYgdGhpcyBpcyBib2d1cyBvciBub3QuXG4gICAgICAgICAgcmV0dXJuIHJlYWxtO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGk7XG59KF9LYXRhbE1ldHJpY3NEcml2ZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLkthdGFsTWV0cmljc0RyaXZlclN1c2hpID0gS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGk7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSwgXCJCdWlsZGVyXCIsIChfdGVtcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF90ZW1wKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIF90ZW1wKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImNvbnRleHRcIiwge30pO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoX3RlbXAsIFt7XG4gICAga2V5OiBcIndpdGhTdXNoaUNsaWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU3VzaGlDbGllbnQoc3VzaGlDbGllbnQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zdXNoaUNsaWVudCA9IHN1c2hpQ2xpZW50O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhEb21haW5SZWFsbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoRG9tYWluUmVhbG0oZG9tYWluLCByZWFsbSkge1xuICAgICAgdGhpcy5jb250ZXh0LmRvbWFpbiA9IGRvbWFpbjtcbiAgICAgIHRoaXMuY29udGV4dC5yZWFsbSA9IHJlYWxtO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDdXN0b21Qcm9kdWNlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ3VzdG9tUHJvZHVjZXIoc3VzaGlQcm9kdWNlcklkKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc3VzaGlQcm9kdWNlciA9IHN1c2hpUHJvZHVjZXJJZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoQ3VzdG9tU291cmNlR3JvdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEN1c3RvbVNvdXJjZUdyb3VwKHNvdXJjZUdyb3VwSWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zb3VyY2VHcm91cElkID0gc291cmNlR3JvdXBJZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoRXJyb3JIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhTdXNoaUNsaWVudE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFN1c2hpQ2xpZW50T3B0aW9ucyhzdXNoaUNsaWVudE9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zdXNoaUNsaWVudE9wdGlvbnMgPSBzdXNoaUNsaWVudE9wdGlvbnM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUoc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSkge1xuICAgICAgdGhpcy5jb250ZXh0LnN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUgPSBzdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSh0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gX3RlbXA7XG59KCksIF90ZW1wKSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnJlcXVpcmUoXCIuL25vZGVqc1NoaW1zXCIpO1xuXG52YXIgX0thdGFsTWV0cmljc0RyaXZlclN1c2hpID0gcmVxdWlyZShcIi4vS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGlcIik7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG52YXIgX2RlZmF1bHQgPSBfS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkuS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfb2JqZWN0U3ByZWFkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9WYWxpZGF0ZVNpbXBsZVN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaGVscGVyL1ZhbGlkYXRlU2ltcGxlU3RyaW5nXCIpKTtcblxudmFyIF9GaXJzdE1hcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaGVscGVyL0ZpcnN0TWFwXCIpKTtcblxudmFyIF9tZXJnZUxpc3RzID0gcmVxdWlyZShcIi4vaGVscGVyL21lcmdlTGlzdHNcIik7XG5cbnZhciBfZW1iZWRSZXF1ZXN0SWQgPSByZXF1aXJlKFwiLi9oZWxwZXIvZW1iZWRSZXF1ZXN0SWRcIik7XG5cbnZhciBfdGVtcDtcblxudmFyIFJFUVVJUkVEX0ZJRUxEUyA9IFsnc2l0ZScsICdzZXJ2aWNlTmFtZScsICdtZXRob2ROYW1lJ107XG5cbnZhciBLYXRhbE1ldHJpY3NDb250ZXh0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBtZXRyaWNzIGNvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gZmllbGRzLlxuICAgKlxuICAgKiBAcGFyYW0gY29udGV4dEZpZWxkcyBDb250ZXh0IGZpZWxkcyB2YWx1ZSAoZGVmYXVsdCBlbXB0eSlcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljc0NvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHRGaWVsZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljc0NvbnRleHQpO1xuICAgIC8vIENvcHkgZmllbGRzIHNvIHRoaXMgaXMgaW1tdXRhYmxlXG4gICAgdGhpcy5jb250ZXh0ID0gKDAsIF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKHt9LCBjb250ZXh0RmllbGRzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IEthdGFsTWV0cmljc0NvbnRleHQgd2hpY2ggaXMgYSBjb3B5IG9mIHRoaXMgY29udGV4dCwgd2l0aCB2YWx1ZXMgYWRkZWQgb3Igb3ZlcnJpZGRlbiBmcm9tXG4gICAqIHRoZSBnaXZlbiBjb250ZXh0LlxuICAgKlxuICAgKiBJZiB0aGUgZ2l2ZW4gY29udGV4dCBpcyBudWxsIG9yIGVtcHR5LCB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvcmlnaW5hbCBvYmplY3QgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gdGhhdENvbnRleHQgQ29udGV4dCB0byBtZXJnZSB2YWx1ZXMgZnJvbVxuICAgKiBAcmV0dXJuIE5ldyBjb250ZXh0IHdpdGggZGVmYXVsdCB2YWx1ZXMgZnJvbSB0aGlzIGNvbnRleHQsIGFuZCB2YWx1ZXMgb3ZlcnJpZGRlbiBvciBhZGRlZCBieSB0aGUgZ2l2ZW4gY29udGV4dC5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NDb250ZXh0LCBbe1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZSh0aGF0Q29udGV4dCkge1xuICAgICAgaWYgKCF0aGF0Q29udGV4dCkgcmV0dXJuIHRoaXM7IC8vIENoZWNrIGZvciBhIGNvbW1vbiBlcnJvclxuXG4gICAgICBpZiAodGhhdENvbnRleHQgaW5zdGFuY2VvZiBLYXRhbE1ldHJpY3NDb250ZXh0LkJ1aWxkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2F0YWxNZXRyaWNzQ29udGV4dC5CdWlsZGVyIG9iamVjdCBwYXNzZWQgaW5zdGVhZCBvZiBLYXRhbE1ldHJpY3NDb250ZXh0LiAgVHJ5IGNhbGxpbmcgLmJ1aWxkKCkgbWV0aG9kLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGF0Q29udGV4dCBpbnN0YW5jZW9mIEthdGFsTWV0cmljc0NvbnRleHQgPyB0aGF0Q29udGV4dC5jb250ZXh0IDogdGhhdENvbnRleHQ7XG4gICAgICB2YXIgbmV3Q29udGV4dCA9ICgwLCBfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgdGhpcy5jb250ZXh0LCBjb250ZXh0LCB7XG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzOiAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzLCBjb250ZXh0LnJlbGF0ZWRNZXRyaWNzKSxcbiAgICAgICAgcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb246ICgwLCBfbWVyZ2VMaXN0cy5tZXJnZUxpc3RzKSh0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24sIGNvbnRleHQucmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dChuZXdDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IGNvbnRleHQgd2hpY2ggaXMgYSBjb3B5IG9mIHRoaXMgY29udGV4dCB3aXRoIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNoaWxkIHB1Ymxpc2hlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQ29weSBvZiB0aGlzIGNvbnRleHQsIHdpdGggcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gcmVtb3ZlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aG91dFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhvdXRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dCgoMCwgX29iamVjdFNwcmVhZDIuZGVmYXVsdCkoe30sIHRoaXMuY29udGV4dCwge1xuICAgICAgICByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbjogdW5kZWZpbmVkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGNvbnRleHQgc3VpdGFibGUgZm9yIHB1YmxpY2F0aW9uIHRvIHRoZSBkcml2ZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBzdHJpcHMgb3V0IGFueSBwcml2YXRlIGZpZWxkcywgYW5kIGxlYXZlcyBvbmx5IGZpZWxkcyBmcm9tIHRoZSBzY2hlbWEgdGhhdCB0aGUgZHJpdmVyIHNob3VsZCBwdWJsaXNoLlxuICAgICAqXG4gICAgICogQHJldHVybiBDb250ZXh0IHN1aXRhYmxlIGZvciBkcml2ZXIgcHVibGljYXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyaXZlckNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJpdmVyQ29udGV4dCgpIHtcbiAgICAgIC8vIERvbid0IHB1Ymxpc2ggcmVsYXRlZE1ldHJpY3MgdG8gdGhlIGRyaXZlclxuICAgICAgdmFyIG5ld0NvbnRleHRGaWVsZHMgPSAoMCwgX29iamVjdFNwcmVhZDIuZGVmYXVsdCkoe30sIHRoaXMuY29udGV4dCk7XG4gICAgICBkZWxldGUgbmV3Q29udGV4dEZpZWxkc1tcInJlbGF0ZWRNZXRyaWNzXCJdO1xuICAgICAgZGVsZXRlIG5ld0NvbnRleHRGaWVsZHNbXCJyZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvblwiXTtcbiAgICAgIGRlbGV0ZSBuZXdDb250ZXh0RmllbGRzW1wicmVxdWVzdElkXCJdO1xuXG4gICAgICBpZiAodGhpcy5jb250ZXh0LnJlcXVlc3RJZCkge1xuICAgICAgICBuZXdDb250ZXh0RmllbGRzLmFjdGlvbklkID0gKDAsIF9lbWJlZFJlcXVlc3RJZC5lbWJlZFJlcXVlc3RJZCkobmV3Q29udGV4dEZpZWxkcy5hY3Rpb25JZCwgdGhpcy5jb250ZXh0LnJlcXVlc3RJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dChuZXdDb250ZXh0RmllbGRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc2ltcGxlIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggYSBjb3B5IG9mIHRoZSBmaWVsZHMgZm9yIHRoaXMgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gU2ltcGxlIEphdmFzY3JpcHQgb2JqZWN0IHdpdGggYSBjb3B5IG9mIHRoZSBmaWVsZHMgZm9yIHRoaXMgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpZWxkcygpIHtcbiAgICAgIC8vIENvcHkgZmllbGRzIHNvIHRoaXMgcmVtYWlucyBpbW11dGFibGVcbiAgICAgIHJldHVybiAoMCwgX29iamVjdFNwcmVhZDIuZGVmYXVsdCkoe30sIHRoaXMuY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBhIHZhbGlkYXRpb24gZXJyb3Igb24gdGhpcyBjb250ZXh0LlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsaWRhdGlvbiBlcnJvciBlbmNvdW50ZXJlZCBpZiBvbmUgaXMgZm91bmQsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBFcnJvcnMgZm91bmQgd2l0aCB0aGlzIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRpb25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZXJyOyAvLyBGaWVsZHMg4oCcc2l0ZeKAnSwg4oCcc2VydmljZU5hbWXigJ0sIOKAnG1ldGhvZE5hbWXigJ0sIGFuZCDigJxtZXRyaWNLZXnigJ0gYXJlIHJlcXVpcmVkLlxuXG4gICAgICBlcnIgPSAoMCwgX0ZpcnN0TWFwLmRlZmF1bHQpKFJFUVVJUkVEX0ZJRUxEUywgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGlmIChfdGhpcy5jb250ZXh0W2ZpZWxkXSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRmllbGQgXCIuY29uY2F0KGZpZWxkLCBcIiBpcyByZXF1aXJlZCwgYnV0IGl0IGlzIFwiKS5jb25jYXQoX3RoaXMuY29udGV4dFtmaWVsZF0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZXJyO1xuICAgICAgcmV0dXJuICgwLCBfRmlyc3RNYXAuZGVmYXVsdCkoT2JqZWN0LmtleXModGhpcy5jb250ZXh0KSwgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy52YWxpZGF0ZUZpZWxkKGZpZWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhbiBpbmRpdmlkdWFsIGNvbnRleHQgZmllbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGQgTmFtZSBvZiBmaWVsZCB0byB2YWxpZGF0ZVxuICAgICAqIEByZXR1cm5zIEVycm9yIGZvdW5kIHdpdGggdGhpcyBmaWVsZCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZUZpZWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICAgIHZhciB2YWwgPSB0aGlzLmNvbnRleHRbZmllbGRdO1xuICAgICAgdmFyIG5hbWVGb3JFcnJvciA9IFwiZmllbGQgXCIuY29uY2F0KGZpZWxkKTtcblxuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICAvLyBTdHJpbmdzIHdoaWNoIGNvdWxkIGJlIHVzZWQgYXMgcGFydGl0aW9uIGtleXMgKFwic2l0ZVwiIGFuZCBcInNlcnZpY2VOYW1lXCIpIGNhbm5vdCBjb250YWluIHNsYXNoZXMsIGluXG4gICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBvdGhlciByZXN0aWN0aW9ucyBiZWxvdy5cbiAgICAgICAgY2FzZSAnc2l0ZSc6XG4gICAgICAgIGNhc2UgJ3NlcnZpY2VOYW1lJzpcbiAgICAgICAgICBpZiAodmFsLmluZGV4T2YoJy8nKSA+IC0xKSByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gY29udGFpbiBvbmx5IHZhbGlkIGNoYXJhY3RlcnMsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWwsIFwiLiAgSXQgY2Fubm90IGNvbnRhaW4gYSBzbGFzaC5cIikpO1xuICAgICAgICAvLyBFbHNlIGZhbGwgdGhyb3VnaFxuICAgICAgICAvLyBTdHJpbmdzIGZvciBmaWVsZHMg4oCcc2l0ZeKAnSwg4oCcc2VydmljZU5hbWXigJ0sIOKAnG1ldGhvZE5hbWXigJ0sIOKAnG1ldHJpY0tleeKAnSBtdXN0IG1hdGNoIGJlIHZhbGlkIFBNRVQgZmllbGQgbmFtZXM6XG4gICAgICAgIC8vIG1heGltdW0gbGVuZ3RoIG9mIDI1Niwgb25seSBsZXR0ZXJzLCBudW1iZXJzLCBhbmQgdGhlIGRvdCwgY29sb24sIGF0LXNpZ24sIHVuZGVyc2NvcmUsIGZvcndhcmQtc2xhc2gsXG4gICAgICAgIC8vIGFuZCBzbGFzaCBjaGFyYWN0ZXJzIChpbiBzaG9ydCB0aGUgcmVnZXggXltBLVphLXowLTkuOkBfLy1dKyQpLlxuXG4gICAgICAgIGNhc2UgJ21ldGhvZE5hbWUnOlxuICAgICAgICBjYXNlICdhY3Rpb25JZCc6XG4gICAgICAgICAgcmV0dXJuICgwLCBfVmFsaWRhdGVTaW1wbGVTdHJpbmcuZGVmYXVsdCkodmFsLCBuYW1lRm9yRXJyb3IpO1xuICAgICAgfSAvLyBObyBlcnJvciBmb3VuZCwgaW1wbGljaXRseSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRlciBjbGFzcyBmb3IgS2F0YWxNZXRyaWNzQ29udGV4dFxuICAgICAqL1xuXG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljc0NvbnRleHQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljc0NvbnRleHQ7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY3NDb250ZXh0LCBcIkJ1aWxkZXJcIiwgKF90ZW1wID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX3RlbXAoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgX3RlbXApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29udGV4dFwiLCB7fSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShfdGVtcCwgW3tcbiAgICBrZXk6IFwid2l0aFNpdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFNpdGUoc2l0ZSkge1xuICAgICAgdGhpcy5jb250ZXh0LnNpdGUgPSBzaXRlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhTZXJ2aWNlTmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU2VydmljZU5hbWUoc2VydmljZU5hbWUpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhNZXRob2ROYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhNZXRob2ROYW1lKG1ldGhvZE5hbWUpIHtcbiAgICAgIHRoaXMuY29udGV4dC5tZXRob2ROYW1lID0gbWV0aG9kTmFtZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoQWN0aW9uSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEFjdGlvbklkKGFjdGlvbklkKSB7XG4gICAgICB0aGlzLmNvbnRleHQuYWN0aW9uSWQgPSBhY3Rpb25JZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoUmVxdWVzdElkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhSZXF1ZXN0SWQocmVxdWVzdElkKSB7XG4gICAgICB0aGlzLmNvbnRleHQucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgYW55IHJlbGF0ZWQgbWV0cmljcyB3aXRoIHRoZSBnaXZlbiBsaXN0IChzZWUgYWRkUmVsYXRlZE1ldHJpY3MgdG8gYWRkIGluc3RlYWQgb2YgcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBSZWxhdGVkIG1ldHJpY3MgYXJlIG1ldHJpY3MgdGhhdCBhcmUgcHVibGlzaGVkIHdoZW5ldmVyIGEgbmV3IGFjdGlvbiBpcyBzdGFydGVkLiAgVGhleSBhcmUgdXNlZCB0byByZWxhdGUgdGhlXG4gICAgICogYWN0aW9uIGJhY2sgdG8gdGhlIGNvbnRleHQgd2hlcmUgaXQgaXMgaGFwcGVuaW5nLCBmb3IgZXhhbXBsZSBhIHJlcXVlc3QgSUQgb3IgYSB1c2VyIGlkZW50aXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbGF0ZWRNZXRyaWNzIFJlbGF0ZWQgbWV0cmljcyB0byBwdWJsaXNoIHdoZW4gYSBuZXcgYWN0aW9uIGlzIHN0YXJ0ZWQgZm9yIHRoaXMgY29udGV4dFxuICAgICAqIEByZXR1cm5zIFRoaXMgYnVpbGRlciBvYmplY3QgdG8gY29udGludWUgYnVpbGRpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpdGhSZWxhdGVkTWV0cmljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoUmVsYXRlZE1ldHJpY3MoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVsYXRlZE1ldHJpY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MgPSByZWxhdGVkTWV0cmljcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYWRkaXRpb25hbCByZWxhdGVkIG1ldHJpY3MgdG8gdGhpcyBidWlsZGVyLiAgU2VlIHdpdGhSZWxhdGVkTWV0cmljcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxhdGVkTWV0cmljcyBBZGRpdGlvbmFsIHJlbGF0ZWQgbWV0cmljcyB0byBwdWJsaXNoIHdoZW4gYSBuZXcgYWN0aW9uIGlzIHN0YXJ0ZWQgZm9yIHRoaXMgY29udGV4dFxuICAgICAqIEByZXR1cm5zIFRoaXMgYnVpbGRlciBvYmplY3QgdG8gY29udGludWUgYnVpbGRpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFJlbGF0ZWRNZXRyaWNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJlbGF0ZWRNZXRyaWNzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCByZWxhdGVkTWV0cmljcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICByZWxhdGVkTWV0cmljc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MgPSAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzLCByZWxhdGVkTWV0cmljcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBzaW5nbGUtYWN0aW9uIHJlbGF0ZWQgbWV0cmljcyB3aXRoIHRoZSBnaXZlbiBsaXN0IChzZWUgYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gdG8gYWRkIGluc3RlYWQgb2YgcmVwbGFjZSxcbiAgICAgKiBhbmQgd2l0aFJlbGF0ZWRNZXRyaWNzIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHJlbGF0ZWQgbWV0cmljcykuXG4gICAgICpcbiAgICAgKiBTaW5nbGUtYWN0aW9uIHJlbGF0ZWQgbWV0cmljcyBhcmUgcHVibGlzaGVkIHdoZW4gYSBuZXcgY2hpbGQgbWV0cmljIHB1Ymxpc2hlciBpcyBjcmVhdGVkLCBidXQgbm90IGluY2x1ZGVkIGFzXG4gICAgICogcmVsYXRlZCBtZXRyaWNzIGZvciB0aGUgbmV3IGNoaWxkIG1ldHJpYyBwdWJsaXNoZXIsIHNvIGFyZSBub3QgcHVibGlzaGVkIGFnYWluIGlmIHRoZSBjaGlsZCBtZXRyaWMgcHVibGlzaGVyXG4gICAgICogY3JlYXRlcyBncmFuZGNoaWxkIHB1Ymxpc2hlZCBtZXRyaWNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldHJpY3MgUmVsYXRlZCBtZXRyaWNzXG4gICAgICogQHJldHVybnMgVGhpcyBidWlsZGVyIG9iamVjdCB0byBjb250aW51ZSBidWlsZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgbWV0cmljcyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBtZXRyaWNzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiA9IG1ldHJpY3M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFkZGl0aW9uYWwgc2luZ2xlLWFjdGlvbiByZWxhdGVkIG1ldHJpY3MgdG8gdGhpcyBidWlsZGVyLiAgU2VlIGFkZFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldHJpY3MgUmVsYXRlZCBtZXRyaWNzXG4gICAgICogQHJldHVybnMgVGhpcyBidWlsZGVyIG9iamVjdCB0byBjb250aW51ZSBidWlsZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIG1ldHJpY3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgbWV0cmljc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gPSAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uLCBtZXRyaWNzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlIHRoZSBmaWVsZHMgc2V0IGluIHRoaXMgYnVpbGRlciBhbmQgdXNlIHRoZW0gdG8gY3JlYXRlIGEgbmV3IEthdGFsTWV0cmljc0NvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEthdGFsTWV0cmljc0NvbnRleHQgb2JqZWN0IGJ1aWx0IHdpdGggdGhlIHBhcmFtZXRlcnMgZ2l2ZW4gdG8gdGhpcyBidWlsZGVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gX3RlbXA7XG59KCksIF90ZW1wKSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ1dWlkL3Y0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY3NDb250ZXh0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY3NDb250ZXh0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY09iamVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbWV0cmljT2JqZWN0L0thdGFsTWV0cmljT2JqZWN0XCIpKTtcblxudmFyIEthdGFsTWV0cmljcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1N0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbWV0cmljT2JqZWN0L0thdGFsTWV0cmljU3RyaW5nXCIpKTtcblxudmFyIF9tZXJnZUxpc3RzID0gcmVxdWlyZShcIi4vaGVscGVyL21lcmdlTGlzdHNcIik7XG5cbnZhciBfbWV0cmljc0V4dGVuc2lvbiA9IHJlcXVpcmUoXCIuL2hlbHBlci9tZXRyaWNzRXh0ZW5zaW9uXCIpO1xuXG52YXIgX2VtYmVkUmVxdWVzdElkID0gcmVxdWlyZShcIi4vaGVscGVyL2VtYmVkUmVxdWVzdElkXCIpO1xuXG52YXIgSU5JVElBTElaQVRJT05fTUVUSE9EX05BTUUgPSAnSW5pdGlhbGl6YXRpb24nO1xuXG4vKipcbiAqIERlZmF1bHQgZXJyb3IgaGFuZGxlciBpZiB0aGUgdXNlci1zdXBwbGllZCBlcnJvciBoYW5kbGVyIGZhaWxzIG9yIGlzIHVuc2V0LlxuICogU2hvdWxkIG5ldmVyIGJlIGNhbGxlZCB1bmxlc3MgdXNlci1wcm92aWRlZCBlcnJvciBoYW5kbGVyIG1pc2JlaGF2ZXMuXG4gKi9cbnZhciBERUZBVUxUX0VSUk9SX0hBTkRMRVIgPSBmdW5jdGlvbiBERUZBVUxUX0VSUk9SX0hBTkRMRVIoZXJyKSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwdWJsaXNoaW5nIG1ldHJpY3M6XCIpO1xuICBjb25zb2xlLmVycm9yKGVycik7XG59O1xuXG52YXIgUEFSRU5UX0FDVElPTl9JRF9OQU1FID0gJ3BhcmVudEFjdGlvbklkJztcblxudmFyIGdldENvbnRleHRGaWVsZHMgPSBmdW5jdGlvbiBnZXRDb250ZXh0RmllbGRzKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQuY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0LmNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbn07XG4vKipcbiAqIENsYXNzIHVzZWQgZm9yIHB1Ymxpc2hpbmcgbWV0cmljcyB0byBLYXRhbC4gIENvbnRhaW5zIGEgZHJpdmVyIGFuZCBhIGNvbnRleHQuXG4gKlxuICogVGhpcyBjbGFzcyBrbm93cyBob3cgdG8gcHVibGlzaCBtZXRyaWNzLCBhbmQgaG93IHRvIGNyZWF0ZSBuZXcgcHVibGlzaGVycyB3aXRoIGEgbW9kaWZpZWQgY29udGV4dC5cbiAqL1xuXG5cbnZhciBLYXRhbE1ldHJpY3NQdWJsaXNoZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG1ldHJpY3MgcHVibGlzaGVyIHdpdGggdGhlIGdpdmVuIGRyaXZlciBhbmQgY29udGV4dFxuICAgKlxuICAgKiBAcGFyYW0gZHJpdmVyIFN1YmNsYXNzIG9mIEthdGFsTWV0cmljc0RyaXZlciB1c2VkIHRvIHB1Ymxpc2ggdGhlIG1ldHJpY3NcbiAgICogQHBhcmFtIGVycm9ySGFuZGxlciBIYW5kbGVyIGZvciBlcnJvcnMgdGhhdCBvY2N1ciB3aGlsZSB1c2luZyB0aGlzIHB1Ymxpc2hlclxuICAgKiBAcGFyYW0gY29udGV4dCBDb250ZXh0IGZvciB0aGlzIG1ldHJpY3MgcHVibGlzaGVyOyBjb250YWlucyBkYXRhIHRvIGJlIGluY2x1ZGVkIHdpdGggZXZlcnlcbiAgICogICAgIG1ldHJpYyBwdWJsaXNoZWQgdXNpbmcgdGhpcyBwdWJsaXNoZXIgb2JqZWN0LiAgRGVmYXVsdCBpcyBhbiBlbXB0eSBjb250ZXh0LlxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNzUHVibGlzaGVyKGRyaXZlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZXJyb3JIYW5kbGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX0VSUk9SX0hBTkRMRVI7XG4gICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG5ldyBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0KCk7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzUHVibGlzaGVyKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImNvbWJpbmVkRXJyb3JIYW5kbGVyXCIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIF90aGlzLmVycm9ySGFuZGxlcihlcnIpO1xuICAgICAgfSBjYXRjaCAobmV4dEVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaGFuZGxpbmcgZXJyb3IgcHVibGlzaGluZyBtZXRyaWNzOlwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihuZXh0RXJyKTtcbiAgICAgICAgREVGQVVMVF9FUlJPUl9IQU5ETEVSKGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDaGVjayBmb3IgYSBjb21tb24gZXJyb3JcbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQuQnVpbGRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2F0YWxNZXRyaWNzQ29udGV4dC5CdWlsZGVyIG9iamVjdCBwYXNzZWQgaW5zdGVhZCBvZiBLYXRhbE1ldHJpY3NDb250ZXh0LiAgVHJ5IGNhbGxpbmcgLmJ1aWxkKCkgbWV0aG9kLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmRyaXZlciA9IGRyaXZlcjtcbiAgICB0aGlzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgICB0aGlzLmNvbnRleHQgPSAhKGNvbnRleHQgaW5zdGFuY2VvZiBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0KSA/IG5ldyBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0KGNvbnRleHQpIDogY29udGV4dDtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGUgZXJyb3ItaGFuZGxlciBzdXBwbGllZCBieSB0aGUgdXNlciB3aGVuIHRoaXMgb2JqZWN0IHdhcyBjb25zdHJ1Y3RlZDsgaWYgdGhhdCBpcyB1bnNldCBvciBpdHNlbGYgdGhyb3dzXG4gICAqIGFuIGV4Y2VwdGlvbiwgY2FsbHMgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBhcyBhIGZhbGxiYWNrLCB3aGljaCB3aWxsIGp1c3QgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZS5cbiAgICpcbiAgICogQHBhcmFtIGVyciBFcnJvciBvYmplY3QgdG8gaGFuZGxlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNzUHVibGlzaGVyLCBbe1xuICAgIGtleTogXCJ3aXRoRXJyb3JIYW5kbGluZ1wiLFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byB3cmFwIGEgZnVuY3Rpb24gaW4gdGhlIGVycm9yIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9UaGVUaGluZyBGdW5jdGlvbiB0byBydW4gdW5kZXIgdGhlIHdyYXBwZXJcbiAgICAgKiBAcmV0dXJuIFJldHVybiB2YWx1ZSBmcm9tIGNhbGxlZCBmdW5jdGlvblxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoRXJyb3JIYW5kbGluZyhkb1RoZVRoaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZG9UaGVUaGluZygpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuY29tYmluZWRFcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byByZXR1cm4gYWxsIHRoZSByZWxhdGVkIG1ldHJpY3Mgb2YgYmFzZSBwdWJsaXNoZXIgYW5kIGFkZGl0aW9uYWxDb250ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm4gUmV0dXJuIGFsbCByZWxhdGVkIG1ldHJpY3MgZnJvbSBiYXNlIHB1Ymxpc2hlciBhbmQgYWRkaXRpb25hbENvbnRleHQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRBZGRpdGlvbmFsUmVsYXRlZE1ldHJpY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWRkaXRpb25hbFJlbGF0ZWRNZXRyaWNzKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICB2YXIgbmV3Q29udGV4dCA9IGFkZGl0aW9uYWxDb250ZXh0IGluc3RhbmNlb2YgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdCA/IGFkZGl0aW9uYWxDb250ZXh0LmNvbnRleHQgOiBhZGRpdGlvbmFsQ29udGV4dDtcbiAgICAgIHZhciBiYXNlUmVsYXRlZE1ldHJpY3MgPSB0aGlzLmdldEJhc2VSZWxhdGVkTWV0cmljcygpO1xuICAgICAgcmV0dXJuICgwLCBfbWVyZ2VMaXN0cy5tZXJnZUxpc3RzKShiYXNlUmVsYXRlZE1ldHJpY3MsIG5ld0NvbnRleHQucmVsYXRlZE1ldHJpY3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHJldHVybiBhbGwgdGhlIHJlbGF0ZWQgbWV0cmljcyBvZiBiYXNlIHB1Ymxpc2hlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gUmV0dXJuIGFsbCByZWxhdGVkIG1ldHJpY3MgZnJvbSB0aGUgYmFzZSBwdWJsaXNoZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXNlUmVsYXRlZE1ldHJpY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZVJlbGF0ZWRNZXRyaWNzKCkge1xuICAgICAgcmV0dXJuICgwLCBfbWVyZ2VMaXN0cy5tZXJnZUxpc3RzKSh0aGlzLmNvbnRleHQuY29udGV4dC5yZWxhdGVkTWV0cmljcywgdGhpcy5jb250ZXh0LmNvbnRleHQucmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIHRoZSBnaXZlbiBtZXRyaWMgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgZ3VhcmFudGVlZCBuZXZlciB0byB0aHJvdyBhbiBleGNlcHRpb24uICBJZiB0aGUgbWV0cmljIG9iamVjdCBvciBjb250ZXh0IGFyZSBpbnZhbGlkLFxuICAgICAqIG9yIGFueSBvdGhlciBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIHB1Ymxpc2hpbmcsIHRoZSBwdWJsaXNoZXIncyBlcnJvciBoYW5kbGVyIGlzIGNhbGxlZC4gIElmIHRoZVxuICAgICAqIHB1Ymxpc2hlcidzIGVycm9yIGhhbmRsZXIgaXMgdW5zZXQgb3IgZmFpbHMsIHRoZSBkZWZhdWx0IGVycm9yIGhhbmRsZXIgaXMgY2FsbGVkIChzZWUgZGVmYXVsdEVycm9ySGFuZGxlcikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2F0YWxNZXRyaWNPYmplY3QgTWV0cmljIG9iamVjdCB0byBwdWJsaXNoXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2goa2F0YWxNZXRyaWNPYmplY3QpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLndpdGhFcnJvckhhbmRsaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFrYXRhbE1ldHJpY09iamVjdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwdWJsaXNoIHVuZGVmaW5lZC9udWxsIG1ldHJpYyBvYmplY3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX0thdGFsTWV0cmljT2JqZWN0LmRlZmF1bHQuVHlwZXMuTGlzdCA9PT0ga2F0YWxNZXRyaWNPYmplY3QudHlwZSkge1xuICAgICAgICAgIGthdGFsTWV0cmljT2JqZWN0Lm1ldHJpY0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobWV0cmljKSB7XG4gICAgICAgICAgICBfdGhpczIucHVibGlzaChtZXRyaWMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkcml2ZXJDb250ZXh0ID0gX3RoaXMyLmNvbnRleHQuZHJpdmVyQ29udGV4dCgpO1xuXG4gICAgICAgICAgdmFyIGNvbnRleHRFcnJvciA9IGRyaXZlckNvbnRleHQudmFsaWRhdGlvbkVycm9yKCk7XG4gICAgICAgICAgaWYgKGNvbnRleHRFcnJvcikgdGhyb3cgY29udGV4dEVycm9yO1xuICAgICAgICAgIHZhciBvYmplY3RFcnJvciA9IGthdGFsTWV0cmljT2JqZWN0LnZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgICAgIGlmIChvYmplY3RFcnJvcikgdGhyb3cgb2JqZWN0RXJyb3I7XG4gICAgICAgICAgKDAsIF9tZXRyaWNzRXh0ZW5zaW9uLmRpc3BhdGNoTWV0cmljRXZlbnQpKGthdGFsTWV0cmljT2JqZWN0LCBkcml2ZXJDb250ZXh0KTtcblxuICAgICAgICAgIF90aGlzMi5kcml2ZXIucHVibGlzaChrYXRhbE1ldHJpY09iamVjdCwgX3RoaXMyLmNvbWJpbmVkRXJyb3JIYW5kbGVyLCBkcml2ZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBwdWJsaXNoZXIgd2hpY2ggaXMgaWRlbnRpY2FsIHRvIHRoaXMgcHVibGlzaGVyLCBidXQgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBmaWVsZHMgbWVyZ2VkIGludG9cbiAgICAgKiB0aGUgbmV3IHB1Ymxpc2hlcidzIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgcHVibGlzaGVyXG4gICAgICogQHJldHVybnMgTmV3IHB1Ymxpc2hlciBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIHVwZGF0ZWQgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3Q2hpbGRQdWJsaXNoZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRQdWJsaXNoZXIoYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzUHVibGlzaGVyKHRoaXMuZHJpdmVyLCB0aGlzLmVycm9ySGFuZGxlciwgdGhpcy5jb250ZXh0Lm1lcmdlKGFkZGl0aW9uYWxDb250ZXh0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJlZ2luIGEgbmV3IGFjdGlvbiwgYW5kIHJldHVybiBhIG5ldyBwdWJsaXNoZXIgZm9yIG1ldHJpY3MgcmVsYXRlZCB0byB0aGF0IGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEJlZ2lubmluZyBhIG5ldyBhY3Rpb24gaW52b2x2ZXMgdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgICAgKiAgIDEuIEdlbmVyYXRlIGEgbmV3IGFjdGlvbklkIGZvciB0aGUgYWN0aW9uLCByYW5kb21seSBpbiB0aGUgYnJvd3NlclxuICAgICAqICAgMi4gSWYgdGhlcmUgYXJlIGFueSByZWxhdGVkIG1ldHJpY3MgaW4gdGhlIGNvbnRleHQsIHB1Ymxpc2ggdGhlbVxuICAgICAqICAgMy4gQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgcHVibGlzaGVyIHdpdGggdGhpcyBvYmplY3QncyBjb250ZXh0LCBtZXJnZWQgd2l0aCBhbnkgYWRkaXRpb25hbCBjb250ZXh0IGdpdmVuLFxuICAgICAqICAgICAgbWVyZ2VkIHdpdGggdGhlIGFjdGlvbklkIGdlbmVyYXRlZCBhYm92ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBwdWJsaXNoZXJcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlcihhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgdmFyIGFjdGlvbklkID0gdGhpcy5fZ2VuZXJhdGVBY3Rpb25pZChhZGRpdGlvbmFsQ29udGV4dCk7XG5cbiAgICAgIHZhciBuZXdDb250ZXh0ID0gdGhpcy5jb250ZXh0LndpdGhvdXRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbigpLm1lcmdlKHtcbiAgICAgICAgYWN0aW9uSWQ6IGFjdGlvbklkXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCk7XG4gICAgICB2YXIgbmV3UHVibGlzaGVyID0gbmV3IEthdGFsTWV0cmljc1B1Ymxpc2hlcih0aGlzLmRyaXZlciwgdGhpcy5lcnJvckhhbmRsZXIsIG5ld0NvbnRleHQpO1xuICAgICAgdmFyIGFsbFJlbGF0ZWRNZXRyaWNzID0gYWRkaXRpb25hbENvbnRleHQgJiYgIShhZGRpdGlvbmFsQ29udGV4dCBpbnN0YW5jZW9mIF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQuQnVpbGRlcikgPyB0aGlzLmdldEFkZGl0aW9uYWxSZWxhdGVkTWV0cmljcyhhZGRpdGlvbmFsQ29udGV4dCkgOiB0aGlzLmdldEJhc2VSZWxhdGVkTWV0cmljcygpO1xuXG4gICAgICBpZiAoYWxsUmVsYXRlZE1ldHJpY3MpIHtcbiAgICAgICAgYWxsUmVsYXRlZE1ldHJpY3MuZm9yRWFjaChmdW5jdGlvbiAobWV0cmljKSB7XG4gICAgICAgICAgbmV3UHVibGlzaGVyLnB1Ymxpc2gobWV0cmljKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdQdWJsaXNoZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJlZ2luIGEgbmV3IGNoYWluZWQgY2hpbGQgYWN0aW9uLCBhbmQgcmV0dXJuIGEgbmV3IHB1Ymxpc2hlciBmb3IgbWV0cmljcyByZWxhdGVkIHRvIHRoYXQgYWN0aW9uLlxuICAgICAqXG4gICAgICogQSBjaGFpbmVkIGFjdGlvbiBpcyBoYW5kbGVkIHRoZSBzYW1lIHdheSBhcyBpbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlciwgYnV0IGFkZGl0aW9uYWxseSxcbiAgICAgKiB0aGUgcmV0dXJuZWQgcHVibGlzaGVyIGhhcyBhIHJlbGF0ZWRNZXRyaWNOb0luaGVyaXQgbmFtZWQgXCJwYXJlbnRBY3Rpb25JZFwiLCB3aXRoIHRoZSBuZXdseVxuICAgICAqIGdlbmVyYXRlZCBhY3Rpb25JZCBhcyBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGUgZWZmZWN0IG9mIHRoaXMgaXMgdGhhdCBhbnkgZnVydGhlciBjaGFpbmVkIGNoaWxkIGFjdGlvbnMgY2FuIGJlIGNvbm5lY3RlZCBiYWNrIHRvIHRoaXNcbiAgICAgKiBhY3Rpb24gdGhyb3VnaCB0aGUgcGFyZW50QWN0aW9uSWQsIGFuZCBzbyBvbiByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBwdWJsaXNoZXJcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICB2YXIgYWN0aW9uSWQgPSB0aGlzLl9nZW5lcmF0ZUFjdGlvbmlkKGFkZGl0aW9uYWxDb250ZXh0KTtcblxuICAgICAgdmFyIHBhcmVudEFjdGlvbklkID0gKDAsIF9lbWJlZFJlcXVlc3RJZC5lbWJlZFJlcXVlc3RJZCkoYWN0aW9uSWQsIHRoaXMuY29udGV4dC5jb250ZXh0LnJlcXVlc3RJZCk7XG4gICAgICB2YXIgcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gPSBbbmV3IF9LYXRhbE1ldHJpY1N0cmluZy5kZWZhdWx0KFBBUkVOVF9BQ1RJT05fSURfTkFNRSwgcGFyZW50QWN0aW9uSWQpXTtcbiAgICAgIHZhciBuZXdDb250ZXh0ID0gbmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoe1xuICAgICAgICBhY3Rpb25JZDogYWN0aW9uSWQsXG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uOiByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvblxuICAgICAgfSkubWVyZ2UoYWRkaXRpb25hbENvbnRleHQpO1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXIobmV3Q29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IGNoYWluZWQgY2hpbGQgYWN0aW9uIHB1Ymxpc2hlciB3aXRoIHRoZSBnaXZlbiB2YWx1ZSBmb3IgbWV0aG9kTmFtZS5cbiAgICAgKlxuICAgICAqIEFwYXJ0IGZyb20gc2V0dGluZyB0aGUgbWV0aG9kTmFtZSBpbiB0aGUgY2hpbGQgY29udGV4dCwgdGhpcyBtZXRob2QgaXMgaWRlbnRpY2FsIHRvIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyQ2hhaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRob2ROYW1lIE1ldGhvZCBuYW1lIGZvciBuZXcgcHVibGlzaGVyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIHN1cHBseSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybnMgTmV3IHB1Ymxpc2hlciBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIHVwZGF0ZWQgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkRm9yTWV0aG9kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyQ2hhaW5lZEZvck1ldGhvZChtZXRob2ROYW1lLCBhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkKG5ldyBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0KHtcbiAgICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZVxuICAgICAgfSkubWVyZ2UoYWRkaXRpb25hbENvbnRleHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgYWN0aW9uIHB1Ymxpc2hlciB3aXRoIHRoZSBnaXZlbiB2YWx1ZSBmb3IgbWV0aG9kTmFtZS5cbiAgICAgKlxuICAgICAqIEFwYXJ0IGZyb20gc2V0dGluZyB0aGUgbWV0aG9kTmFtZSBpbiB0aGUgY2hpbGQgY29udGV4dCwgdGhpcyBtZXRob2QgaXMgaWRlbnRpY2FsIHRvIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyRm9yTWV0aG9kLlxuICAgICAqIEBwYXJhbSBtZXRob2ROYW1lIE1ldGhvZCBuYW1lIGZvciBuZXcgcHVibGlzaGVyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIHN1cHBseSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybnMgTmV3IHB1Ymxpc2hlciBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIHVwZGF0ZWQgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QobWV0aG9kTmFtZSwgYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyKG5ldyBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0KHtcbiAgICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZVxuICAgICAgfSkubWVyZ2UoYWRkaXRpb25hbENvbnRleHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgYWN0aW9uIGZvciBhcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvbi4gIEl0IHdpbGwgYWx3YXlzIGhhdmUgYSBtZXRob2ROYW1lXG4gICAgICogb2YgXCJJbml0aWFsaXphdGlvblwiOyBvdGhlcndpc2UgdGhpcyBtZXRob2QgaXMgaWRlbnRpY2FsIHRvIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyRm9yTWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm5zIE5ldyBwdWJsaXNoZXIgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2l0aCBhbiB1cGRhdGVkIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyRm9ySW5pdGlhbGl6YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JJbml0aWFsaXphdGlvbihhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QoSU5JVElBTElaQVRJT05fTUVUSE9EX05BTUUsIGFkZGl0aW9uYWxDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgc3RyaW5nIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTWV0cmljIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgU3RyaW5nIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hTdHJpbmcobmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMucHVibGlzaChuZXcgS2F0YWxNZXRyaWNzLk1ldHJpYy5TdHJpbmcobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgc3RyaW5nIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLCB0cnVuY2F0ZWQgdG8gdGhlIG1heGltdW0gc2l6ZSBhbGxvd2VkIGJ5IHRoZVxuICAgICAqIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIFN0cmluZyB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGlzaFN0cmluZ1RydW5jYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hTdHJpbmdUcnVuY2F0ZShuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG9iamVjdCA9IG5ldyBLYXRhbE1ldHJpY3MuTWV0cmljLlN0cmluZyhuYW1lLCB2YWx1ZSk7XG4gICAgICBvYmplY3QudHJ1bmNhdGUgPSB0cnVlO1xuICAgICAgdGhpcy5wdWJsaXNoKG9iamVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcHVibGlzaCBhIGNvdW50ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBDb3VudGVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoQ291bnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaXNoQ291bnRlcihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5ldyBLYXRhbE1ldHJpY3MuTWV0cmljLkNvdW50ZXIobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgdGltZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaW1lciB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGlzaFRpbWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hUaW1lcihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5ldyBLYXRhbE1ldHJpY3MuTWV0cmljLlRpbWVyKG5hbWUsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcHVibGlzaCBhIGNvdW50ZXIgd2l0aCB0aGUgaXNNb25pdG9yIGZsYWcgc2V0LCBhbmQgdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTWV0cmljIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgQ291bnRlciB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGlzaENvdW50ZXJNb25pdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hDb3VudGVyTW9uaXRvcihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5ldyBLYXRhbE1ldHJpY3MuTWV0cmljLkNvdW50ZXIobmFtZSwgdmFsdWUpLndpdGhNb25pdG9yKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSB0aW1lciB3aXRoIHRoZSBpc01vbml0b3IgZmxhZyBzZXQsIGFuZCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaW1lciB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGlzaFRpbWVyTW9uaXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaXNoVGltZXJNb25pdG9yKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IEthdGFsTWV0cmljcy5NZXRyaWMuVGltZXIobmFtZSwgdmFsdWUpLndpdGhNb25pdG9yKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGhlbHBlciBtZXRob2QgdG8gZXh0cmFjdCBhbiBhY3Rpb25JZCBmcm9tIGEgY29udGV4dCBpZiBvbmUgaXMgcHJvdmlkZWQsIGFuZCBvdGhlcndpc2UgZ2VuZXJhdGUgYSBuZXcgb25lLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQWN0aW9uIElEIHN0cmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbmVyYXRlQWN0aW9uaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlQWN0aW9uaWQoY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IGdldENvbnRleHRGaWVsZHMoY29udGV4dCk7XG5cbiAgICAgICAgaWYgKGZpZWxkcy5hY3Rpb25JZCkge1xuICAgICAgICAgIHJldHVybiBmaWVsZHMuYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfdi5kZWZhdWx0KSgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNzUHVibGlzaGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY3NQdWJsaXNoZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRFRkFVTFRfRVJST1JfSEFORExFUiA9IHZvaWQgMDtcblxudmFyIERFRkFVTFRfRVJST1JfSEFORExFUiA9IGZ1bmN0aW9uIERFRkFVTFRfRVJST1JfSEFORExFUihlcnIpIHtcbiAgdGhyb3cgZXJyO1xufTtcblxuZXhwb3J0cy5ERUZBVUxUX0VSUk9SX0hBTkRMRVIgPSBERUZBVUxUX0VSUk9SX0hBTkRMRVI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGEgS2F0YWwgbWV0cmljcyBkcml2ZXIuXG4gKi9cbnZhciBLYXRhbE1ldHJpY3NEcml2ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY3NEcml2ZXIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzRHJpdmVyKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlciwgW3tcbiAgICBrZXk6IFwicHVibGlzaFwiLFxuXG4gICAgLyoqXG4gICAgICogUHVibGlzaCB0aGUgZ2l2ZW4gbWV0cmljIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBlcnJvciBoYW5kbGVyIGFuZCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldHJpY09iamVjdCBNZXRyaWMgb2JqZWN0IHRvIHB1Ymxpc2guICBDb250YWlucyBtZXRyaWNLZXksIGlzTW9uaXRvciwgdHlwZSwgYW5kIHZhbHVlLlxuICAgICAqIEBwYXJhbSBlcnJvckhhbmRsZXIgQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIGFueSBhc3luY2hyb25vdXMgZXJyb3JzIHRoYXQgb2NjdXIgaW4gdGhlIGRyaXZlclxuICAgICAqICAgICAodGhlIGRyaXZlciBzaG91bGQganVzdCB0aHJvdyBhbiBleGNlcHRpb24gZm9yIGEgc3luY2hyb25vdXMgZXJyb3IpLlxuICAgICAqIEBwYXJhbSBjb250ZXh0IENvbnRleHQgZm9yIHB1Ymxpc2hpbmcgdGhpcyBtZXRyaWMuICBDb250YWlucyBhbGwgb3RoZXIgZmllbGRzIHRvIGJlIHB1Ymxpc2hlZC5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaChtZXRyaWNPYmplY3QsIGVycm9ySGFuZGxlciwgY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLYXRhbE1ldHJpY3NEcml2ZXIgaXMgYW4gYWJzdHJhY3QgY2xhc3MsIHBsZWFzZSBjaG9vc2UgYSBkcml2ZXIgYW5kIHVzZSB0aGF0IGluc3RlYWQnKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljc0RyaXZlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNzRHJpdmVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmlyc3RNYXA7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3Qgbm9uLXVuZGVmaW5lZCB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSBydW5uaW5nIGVhY2ggdmFsdWVcbiAqIGluIHRoZSBnaXZlbiBhcnJheSB0aHJvdWdoIHRoZSBtYXBwZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0gYXJyYXkgQW4gYXJyYXkgb2YgdmFsdWVzLlxuICogQHBhcmFtIG1hcHBlciBBIG1hcHBlciBmdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gYSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyBUaGUgZmlyc3Qgbm9uLXVuZGVmaW5lZCB2YWx1ZSBmcm9tIHRoZSBtYXBwZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZpcnN0TWFwKGFycmF5LCBtYXBwZXIpIHtcbiAgdmFyIHRvUmV0dXJuID0gdW5kZWZpbmVkO1xuICBhcnJheS5zb21lKGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0b1JldHVybiA9IG1hcHBlcih2YWwpO1xuICAgIHJldHVybiB0b1JldHVybiAhPSBudWxsO1xuICB9KTtcbiAgcmV0dXJuIHRvUmV0dXJuO1xufVxuXG47IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgb2JqZWN0VmFsdWVzID0gT2JqZWN0LnZhbHVlcyA/IE9iamVjdC52YWx1ZXMgOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn07XG52YXIgX2RlZmF1bHQgPSBvYmplY3RWYWx1ZXM7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZVNpbXBsZUludDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG4vKipcbiAqIE51bWJlci5pc0ludGVnZXIgaXMgbm90IGluIElFMTEsIGFuZCBsZXR0aW5nIEJhYmVsIHBvbHlmaWxsIGl0IGFkZGVkIHRvbyBtdWNoIHdlaWdodC5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNJbnRlZ2VyXG4gKi9cbnZhciBpc0ludGVnZXIgPSBmdW5jdGlvbiBpc0ludGVnZXIodmFsKSB7XG4gIHJldHVybiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHZhbGlkIHRvIGJlIHB1Ymxpc2hlZCB0byBLYXRhbE1ldHJpY3MgYXMgYW4gaW50ZWdlciAoQ291bnRlciBvciBUaW1lciksXG4gKiBhbmQgcmV0dXJuIGVpdGhlciB1bmRlZmluZWQgKG5vIGVycm9yKSwgb3IgYW4gRXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHByb2JsZW0uXG4gKlxuICogQHBhcmFtIHZhbCBWYWx1ZSB0byBjaGVja1xuICogQHBhcmFtIG5hbWVGb3JFcnJvciBOYW1lIHRvIHVzZSB3aGVuIGNvbnN0cnVjdGluZyB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgbmVjZXNzYXJ5XG4gKiBAcmV0dXJucyBFcnJvciwgb3IgdW5kZWZpbmVkIGlmIG5vIGVycm9yXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVNpbXBsZUludCh2YWwsIG5hbWVGb3JFcnJvcikge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gaGF2ZSB0eXBlICdudW1iZXInLCBidXQgaXQgd2FzIHR5cGUgJ1wiKS5jb25jYXQoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbCksIFwiJ1wiKSk7XG4gIH1cblxuICBpZiAodmFsIDwgMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBiZSBwb3NpdGl2ZSwgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCkpO1xuICB9IC8vIFRoaXMgd2lsbCBhbHNvIGNhdGNoIE5hTiBhbmQgSW5maW5pdHlcblxuXG4gIGlmICghaXNJbnRlZ2VyKHZhbCkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gYmUgYW4gaW50ZWdlciwgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCkpO1xuICB9IC8vIENvdWxkbid0IGZpbmQgYW55dGhpbmcgd3JvbmcsIGltcGxpY2l0bHkgcmV0dXJuIHVuZGVmaW5lZFxuXG59XG5cbjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZVNpbXBsZVN0cmluZztcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgU0lNUExFX1NUUklOR19QQVQgPSAvXltBLVphLXowLTkuOkBfLy1dKyQvO1xudmFyIFNJTVBMRV9TVFJJTkdfTUFYX0xFTiA9IDEyNztcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHZhbGlkIHRvIGJlIHB1Ymxpc2hlZCB0byBLYXRhbE1ldHJpY3MgYXMgYSBmaWVsZCB2YWx1ZSxcbiAqIHN1Y2ggYXMgc2l0ZSwgc2VydmljZU5hbWUsIG1ldGhvZE5hbWUsIG9yIGFjdGlvbklkIChub3RlIHRoaXMgaXMgbm90IHVzZWQgdG8gY2hlY2sgdmFsdWVzIGZvciBzdHJpbmcgbWV0cmljcykuXG4gKiBJdCByZXR1cm5zIGVpdGhlciB1bmRlZmluZWQgKG5vIGVycm9yKSwgb3IgYW4gRXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHByb2JsZW0uXG4gKlxuICogVG8gYmUgcHVibGlzaGVkLCBpdCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZywgbGVzcyB0aGFuIDI1NiBjaGFyYWN0ZXJzLCBjb250YWluaW5nIG9ubHkgQVNDSUlcbiAqIGxldHRlcnMsIG51bWJlcnMsIG9yIHRoZXNlIGNoYXJhY3RlcnM6IC46QF8vLSAodGhvc2UgYXJlIHRoZSBQTUVUIGZpZWxkIHZhbHVlIHJlcXVpcmVtZW50cykuXG4gKlxuICogQHBhcmFtIHZhbCBTdHJpbmcgdmFsdWUgdG8gY2hlY2tcbiAqIEBwYXJhbSBuYW1lRm9yRXJyb3IgTmFtZSB0byB1c2UgaW4gdGhlIGVycm9yIG1lc3NhZ2UsIGlmIG9uZSBpcyBnZW5lcmF0ZWRcbiAqIEByZXR1cm5zIEVycm9yLCBvciB1bmRlZmluZWQgaWYgbm8gZXJyb3JcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVNpbXBsZVN0cmluZyh2YWwsIG5hbWVGb3JFcnJvcikge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBiZSBhIHN0cmluZywgYnV0IGl0IHdhcyBhIFwiKS5jb25jYXQoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbCkpKTtcbiAgfVxuXG4gIGlmICh2YWwubGVuZ3RoID4gU0lNUExFX1NUUklOR19NQVhfTEVOKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIGxlc3MgdGhhbiBcIikuY29uY2F0KFNJTVBMRV9TVFJJTkdfTUFYX0xFTiwgXCIgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbC5sZW5ndGgsIFwiIGNoYXJhY3RlcnNcIikpO1xuICB9XG5cbiAgaWYgKHZhbC5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIG5vbi1ibGFua1wiKSk7XG4gIH1cblxuICBpZiAoIVNJTVBMRV9TVFJJTkdfUEFULnRlc3QodmFsKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBjb250YWluIG9ubHkgdmFsaWQgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCwgXCIuICBJdCBjYW4gb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIGFuZCB0aGVzZSBzeW1ib2xzOiAuOkBfLy1cIikpO1xuICB9IC8vIENvdWxkbid0IGZpbmQgYW55dGhpbmcgd3JvbmcsIGltcGxpY2l0bHkgcmV0dXJuIHVuZGVmaW5lZFxuXG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmVtYmVkUmVxdWVzdElkID0gZW1iZWRSZXF1ZXN0SWQ7XG5cbi8vIHVudGlsIHdlIGNhbiBhZGQgYSByZXF1ZXN0SWQgZmllbGQgdG8gdGhlIGFuZGVzIHNjaGVtYSB3ZSB3aWxsIGVtYmVkIGl0IGluIHRoZSBhY3Rpb25JZFxuZnVuY3Rpb24gZW1iZWRSZXF1ZXN0SWQoYWN0aW9uSWQsIHJlcXVlc3RJZCkge1xuICBpZiAocmVxdWVzdElkKSB7XG4gICAgcmV0dXJuIFtyZXF1ZXN0SWQsIGFjdGlvbklkXS5qb2luKFwiOjpcIik7XG4gIH1cblxuICByZXR1cm4gYWN0aW9uSWQ7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tZXJnZUxpc3RzID0gbWVyZ2VMaXN0cztcblxudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5XCIpKTtcblxuLy8gSGVscGVyIG1ldGhvZCB0byBtZXJnZSB0d28gbGlzdHMgd2hpY2ggY291bGQgYmUgdW5kZWZpbmVkXG4vLyBSZXR1cm5zIG1lcmdlZCBsaXN0cyBpZiBlaXRoZXIgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkXG5mdW5jdGlvbiBtZXJnZUxpc3RzKGxpc3QxLCBsaXN0Mikge1xuICBpZiAobGlzdDEgfHwgbGlzdDIpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKGxpc3QxIHx8IFtdKSwgKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkobGlzdDIgfHwgW10pKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlzcGF0Y2hNZXRyaWNFdmVudCA9IGRpc3BhdGNoTWV0cmljRXZlbnQ7XG5cbi8qKlxuICogUHVibGlzaCB0byBleHRlcm5hbCBwYXJ0aWVzIHRoYXQgYXJlIFxuICogbGlzdGVuaW5nIGZvciBrYXRhbC5tZXRyaWNzLnB1Ymxpc2ggQ3VzdG9tIEV2ZW50c1xuICovXG5mdW5jdGlvbiBkaXNwYXRjaE1ldHJpY0V2ZW50KG1ldHJpYywgY29udGV4dCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXNwYXRjaEN1c3RvbUV2ZW50KG1ldHJpYywgY29udGV4dCk7IC8vIGZvciBsZWdhY3kgcHVycG9zZXMsIGFsc28gcHVibGlzaCB0byBfX0tBVEFMX01FVFJJQ1NfRVhURU5TSU9OX19cblxuICBwdWJsaXNoVG9NZXRyaWNzRXh0ZW5zaW9uKG1ldHJpYywgY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQ3VzdG9tRXZlbnQobWV0cmljLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgna2F0YWwubWV0cmljcy5wdWJsaXNoJywge1xuICAgIGRldGFpbDoge1xuICAgICAgbWV0cmljOiBtZXRyaWMsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LmdldEZpZWxkcygpXG4gICAgfVxuICB9KTtcbiAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuLyoqXG4gKiBARGVwcmVjYXRlZFxuICogUHVibGlzaCB0byBodHRwczovL2NvZGUuYW1hem9uLmNvbS9wYWNrYWdlcy9LYXRhbE1ldHJpY3NFeHRlbnNpb25cbiAqIFRoZSBleHRlbnNpb24gaW5qZWN0cyBhIGdsb2JhbCBfX0tBVEFMX01FVFJJQ1NfRVhURU5TSU9OX18gb2JqZWN0IHdpdGggYVxuICogYHB1Ymxpc2hgIG1ldGhvZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHB1Ymxpc2hUb01ldHJpY3NFeHRlbnNpb24obWV0cmljLCBjb250ZXh0KSB7XG4gIHZhciBleHRlbnNpb24gPSB3aW5kb3cuX19LQVRBTF9NRVRSSUNTX0VYVEVOU0lPTl9fO1xuXG4gIGlmIChleHRlbnNpb24pIHtcbiAgICBleHRlbnNpb24ucHVibGlzaChtZXRyaWMsIGNvbnRleHQuZ2V0RmllbGRzKCkpO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHVibGlzaGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY3NQdWJsaXNoZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250ZXh0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWV0cmljc0RyaXZlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNzRHJpdmVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JIYW5kbGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9FcnJvckhhbmRsZXIuRXJyb3JIYW5kbGVyO1xuICB9XG59KTtcbmV4cG9ydHMuTWV0cmljID0gdm9pZCAwO1xuXG52YXIgTWV0cmljID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWV0cmljT2JqZWN0XCIpKTtcblxuZXhwb3J0cy5NZXRyaWMgPSBNZXRyaWM7XG5cbnZhciBfS2F0YWxNZXRyaWNzUHVibGlzaGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY3NQdWJsaXNoZXJcIikpO1xuXG52YXIgX0thdGFsTWV0cmljc0NvbnRleHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljc0NvbnRleHRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljc0RyaXZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZHJpdmVyL0thdGFsTWV0cmljc0RyaXZlclwiKSk7XG5cbnZhciBfRXJyb3JIYW5kbGVyID0gcmVxdWlyZShcIi4vZHJpdmVyL0Vycm9ySGFuZGxlclwiKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbnZhciBfVmFsaWRhdGVTaW1wbGVJbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVJbnRcIikpO1xuXG4vKipcbiAqIENvdW50ZXIgdHlwZS5cbiAqXG4gKiBDYW4gYmUgdXNlZCB0byBjb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIGFuIGV2ZW50IGhhcHBlbmVkIG9uIGEgcGFnZSwgb3IgYXMgYSBzaW1wbGUgMS8wIGNvdW50ZXIgdG8gdHJhY2tcbiAqIHN1Y2Nlc3MgYW5kIGZhaWx1cmUuXG4gKi9cbnZhciBLYXRhbE1ldHJpY0NvdW50ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY0NvdW50ZXIsIF9LYXRhbE1ldHJpY09iamVjdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjb3VudGVyIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBDb3VudGVyIG5hbWVcbiAgICogQHBhcmFtIHZhbHVlIENvdW50ZXIgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljQ291bnRlcihuYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljQ291bnRlcik7XG4gICAgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlcikuY2FsbCh0aGlzLCBuYW1lKSk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoaXMgY291bnRlclxuICAgKlxuICAgKiBAcmV0dXJuIENvdW50ZXIgdmFsdWVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY0NvdW50ZXIsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbnVtYmVyIHRvIHRoaXMgY291bnRlci5cbiAgICAgKlxuICAgICAqIENhbiBhbHNvIGJlIG5lZ2F0aXZlIHRvIHN1YnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZFZhbHVlIEFtb3VudCB0byBhZGQgdG8gdGhpcyBjb3VudGVyXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChhZGRWYWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSArPSBhZGRWYWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGlvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIHZhciBzdXBlckVycm9yID0gKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlci5wcm90b3R5cGUpLCBcInZhbGlkYXRpb25FcnJvclwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHN1cGVyRXJyb3IpIHJldHVybiBzdXBlckVycm9yO1xuICAgICAgcmV0dXJuICgwLCBfVmFsaWRhdGVTaW1wbGVJbnQuZGVmYXVsdCkodGhpcy52YWx1ZSwgXCJmaWVsZCB2YWx1ZSBpbiBDb3VudGVyIG1ldHJpY3Mgb2JqZWN0ICdcIi5jb25jYXQodGhpcy5uYW1lLCBcIidcIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBuZXcgdmFsdWUgZm9yIHRoaXMgY291bnRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB2YWx1ZSBmb3IgdGhpcyBjb3VudGVyXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAvLyBNYXRoLnJvdW5kIHdpbGwgYWxzbyBjb2VyY2UgZnJvbSBhIHN0cmluZyBpZiBuZWNlc3NhcnksIGFuZCByZXR1cm4gTmFOIGlmIGludmFsaWRcbiAgICAgIHRoaXMuX3ZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHR5cGUgZm9yIHRoaXMgY291bnRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQWx3YXlzIHJldHVybnMgXCJDb3VudGVyXCIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0LlR5cGVzLkNvdW50ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNDb3VudGVyO1xufShfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY0NvdW50ZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1N0cmluZ1wiKSk7XG5cbi8qKlxuICogU3RhbmRhcmRpemVkIG1ldHJpYyBmb3IgaW5zdHJ1bWVudGluZyBIVFRQIHJlcXVlc3RzLlxuICpcbiAqIFVuZGVyIHRoZSBob29kIGl0IGlzIGEgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgd2l0aCB0aGUgbmFtZSB5b3UgcHJvdmlkZSBwcmVmaXhlZCB3aXRoIFwiSFRUUFJlcXVlc3QuXCIuXG4gKiBUaGF0IG9iamVjdCB3aWxsIGNvbnRhaW4gYSBtZXRyaWMgc3VmZml4ZWQgd2l0aCBcIi5MYXRlbmN5XCIgZm9yIHRoZSBsYXRlbmN5IG9mIHRoaXMgcmVxdWVzdCwgYW5kIGEgbWV0cmljIHN1ZmZpeGVkXG4gKiB3aXRoIFwiLkZhaWx1cmVcIiB0byByZWNvcmQgdGhlIGZhaWx1cmUgb3Igc3VjY2VzcyBvZiB0aGlzIHJlcXVlc3QuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgcmVxdWVzdCB3aWxsIGJlIHRyYWNrZWQgYXMgYSBmYWlsdXJlOyB0byBtYXJrIGl0IGFzIGEgc3VjY2VzcyBjYWxsIHRoZSBcInNldFN1Y2Nlc3MoKVwiIG1ldGhvZC5cbiAqXG4gKiBJdCBoYXMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHdoaWNoIHdpbGwgYmUgZW1pdHRlZCBpZiBzZXQ7IHNlZSB1cmwsIHN0YXR1c0NvZGUsIGFuZCBzdGF0dXNUZXh0LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgZ2F2ZSB0aGUgbmFtZSBcIlNlYXJjaFwiLCB0aGVzZSBtZXRyaWNzIHdpbGwgYmUgY3JlYXRlZDpcbiAqICAgSFRUUFJlcXVlc3QuU2VhcmNoLkxhdGVuY3kgLSBMYXRlbmN5IGZvciB0aGlzIHJlcXVlc3RcbiAqICAgSFRUUFJlcXVlc3QuU2VhcmNoLkZhaWx1cmUgLSBGYWlsdXJlIGZvciB0aGlzIHJlcXVlc3QgKDEgZm9yIGZhaWx1cmUsIDAgZm9yIHN1Y2Nlc3MpXG4gKi9cbnZhciBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNUaW1lZEF0dGUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgX0thdGFsTWV0cmljVGltZWRBdHRlKTtcblxuICAvKiogVGhlIHByZWZpeCBmb3IgdGhpcyBtZXRyaWMuICovXG5cbiAgLyoqIFRoZSBzdWZmaXggZm9yIFVSTCBtZXRyaWNzIG9mIHRoaXMgY2xhc3MuICovXG5cbiAgLyoqIFRoZSBzdWZmaXggZm9yIEhUVFAgcmVzcG9uc2UgY29kZSBtZXRyaWNzIG9mIHRoaXMgY2xhc3MuICovXG5cbiAgLyoqIFRoZSBzdWZmaXggZm9yIEhUVFAgcmVzcG9uc2UgdGV4dCBtZXRyaWNzIG9mIHRoaXMgY2xhc3MuICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBIVFRQIFJlcXVlc3QgdGltZWQgYXR0ZW1wdCBtZXRyaWMgaW5jb3Jwb3JhdGluZyB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogVGhlIG5hbWUgeW91IGdpdmUgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIEthdGFsTWV0cmljVGltZWRBdHRlbXB0IHdpdGggdGhlIHByb3ZpZGVkIG5hbWUgcHJlZml4ZWQgd2l0aCBcIkhUVFBSZXF1ZXN0LlwiLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoaXMgbWV0cmljOyByZXN1bHRpbmcgbWV0cmljcyB3aWxsIHByZWZpeCB0aGlzIG5hbWUgd2l0aCBcIkhUVFBSZXF1ZXN0LlwiXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0KG5hbWUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0KTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0KS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KEthdGFsTWV0cmljSHR0cFJlcXVlc3QuSFRUUF9SRVFVRVNUX1BSRUZJWCwgXCIuXCIpLmNvbmNhdChuYW1lKSkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHVybCBmb3IgdGhpcyBtZXRyaWMuXG4gICAqXG4gICAqIEEgc3RyaW5nIG1ldHJpYyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBsaXN0IG9mIG9iamVjdHMgdGhhdCB3aWxsIGJlIHB1Ymxpc2hlZCBmb3IgdGhpcyBtZXRyaWMuICBJdHMgbmFtZSB3aWxsXG4gICAqIGJlIHRoaXMgbWV0cmljcyBuYW1lIHN1ZmZpeGVkIHdpdGggJy5VUkwnLCBhbmQgaXRzIHZhbHVlIHdpbGwgYmUgdGhlIFVSTCB2YWx1ZSBnaXZlbiBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgVVJMIGZvciB0aGlzIG1ldHJpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIFt7XG4gICAga2V5OiBcInVybFwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlVSTF9TVUZGSVgsIF9LYXRhbE1ldHJpY1N0cmluZy5kZWZhdWx0LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgVVJMIGZvciB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIFVSTCBmb3IgdGhpcyBtZXRyaWMsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljVmFsdWUoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5VUkxfU1VGRklYKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBVUkwgbWV0cmljIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBtZXRyaWMsIGlmIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFzc29jaWF0ZWQgVVJMIG1ldHJpYyBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXJsTWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlVSTF9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQSBzdHJpbmcgbWV0cmljIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyB0aGF0IHdpbGwgYmUgcHVibGlzaGVkIGZvciB0aGlzIG1ldHJpYy4gIEl0cyBuYW1lIHdpbGxcbiAgICAgKiBiZSB0aGlzIG1ldHJpY3MgbmFtZSBzdWZmaXhlZCB3aXRoICcuU3RhdHVzQ29kZScsIGFuZCBpdHMgdmFsdWUgd2lsbCBiZSB0aGUgc3RhdHVzIGNvZGUgdmFsdWUgZ2l2ZW4gaGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGZvciB0aGlzIG1ldHJpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdHVzQ29kZVwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19DT0RFX1NVRkZJWCwgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGZvciB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlIG1ldHJpYyBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljVmFsdWUoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfQ09ERV9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgbWV0cmljIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBtZXRyaWMsIGlmIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGF0dXNDb2RlTWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19DT0RFX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgdGV4dCBmb3IgdGhpcyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBBIHN0cmluZyBtZXRyaWMgd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlzdCBvZiBvYmplY3RzIHRoYXQgd2lsbCBiZSBwdWJsaXNoZWQgZm9yIHRoaXMgbWV0cmljLiAgSXRzIG5hbWUgd2lsbFxuICAgICAqIGJlIHRoaXMgbWV0cmljcyBuYW1lIHN1ZmZpeGVkIHdpdGggJy5TdGF0dXNUZXh0JywgYW5kIGl0cyB2YWx1ZSB3aWxsIGJlIHRoZSBzdGF0dXMgdGV4dCB2YWx1ZSBnaXZlbiBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXR1c1RleHQgSFRUUCByZXNwb25zZSBzdGF0dXMgdGV4dCBmb3IgdGhpcyBtZXRyaWMsIG9yIHVuZGVmaW5lZCB0byByZW1vdmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXR1c1RleHRcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRPckRlbGV0ZU5hbWVkTWV0cmljVmFsdWUoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfVEVYVF9TVUZGSVgsIF9LYXRhbE1ldHJpY1N0cmluZy5kZWZhdWx0LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgdGV4dCBmb3IgdGhpcyBtZXRyaWMsIGlmIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFzc29jaWF0ZWQgSFRUUCByZXNwb25zZSBzdGF0dXMgdGV4dCBtZXRyaWMgb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICAgKi9cbiAgICAsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuU1RBVFVTX1RFWFRfU1VGRklYKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGZvciB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IG1ldHJpYyBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdHVzVGV4dE1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfVEVYVF9TVUZGSVgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNIdHRwUmVxdWVzdDtcbn0oX0thdGFsTWV0cmljVGltZWRBdHRlbXB0LmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0O1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgXCJIVFRQX1JFUVVFU1RfUFJFRklYXCIsICdIVFRQUmVxdWVzdCcpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgXCJVUkxfU1VGRklYXCIsICdVUkwnKTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIFwiU1RBVFVTX0NPREVfU1VGRklYXCIsICdTdGF0dXNDb2RlJyk7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBcIlNUQVRVU19URVhUX1NVRkZJWFwiLCAnU3RhdHVzVGV4dCcpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZWRBdHRlbXB0XCIpKTtcblxuLyoqXG4gKiBTdGFuZGFyZGl6ZWQgbWV0cmljIGZvciBpbnN0cnVtZW50aW5nIGFwcGxpY2F0aW9uIGluaXRpYWxpemF0aW9uLlxuICpcbiAqIFVuZGVyIHRoZSBob29kIGl0IGlzIGEgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgd2l0aCB0aGUgbmFtZSBcIkluaXRpYWxpemF0aW9uXCIuXG4gKiBUaGF0IG9iamVjdCB3aWxsIGNvbnRhaW4gYSBtZXRyaWMgc3VmZml4ZWQgd2l0aCBcIi5MYXRlbmN5XCIgZm9yIHRoZSBsYXRlbmN5IG9mIHRoaXMgcmVxdWVzdCwgYW5kIGEgbWV0cmljIHN1ZmZpeGVkXG4gKiB3aXRoIFwiLkZhaWx1cmVcIiB0byByZWNvcmQgdGhlIGZhaWx1cmUgb3Igc3VjY2VzcyBvZiB0aGlzIHJlcXVlc3QuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgcmVxdWVzdCB3aWxsIGJlIHRyYWNrZWQgYXMgYSBmYWlsdXJlOyB0byBtYXJrIGl0IGFzIGEgc3VjY2VzcyBjYWxsIHRoZSBcInNldFN1Y2Nlc3MoKVwiIG1ldGhvZC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGVzZSBtZXRyaWNzIHdpbGwgYmUgY3JlYXRlZDpcbiAqICAgSW5pdGlhbGl6YXRpb24uTGF0ZW5jeSAtIExhdGVuY3kgZm9yIGFwcGxpY2F0aW9uIGluaXRpYWxpemF0aW9uXG4gKiAgIEluaXRpYWxpemF0aW9uLkZhaWx1cmUgLSBGYWlsdXJlIGZvciB0aGlzIGFwcGxpY2F0aW9uIGluaXRpYWxpemF0aW9uICgxIGZvciBmYWlsdXJlLCAwIGZvciBzdWNjZXNzKVxuICovXG52YXIgS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0thdGFsTWV0cmljVGltZWRBdHRlKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24sIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZSk7XG5cbiAgLyoqIFRoZSBuYW1lIGZvciB0aGlzIG1ldHJpYy4gKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRpbWVkIGF0dGVtcHQgbWV0cmljIG5hbWVkIFwiSW5pdGlhbGl6YXRpb25cIiwgZm9yIHJlY29yZGluZyBsYXRlbmN5IGFuZCBmYWlsdXJlIGluZm9ybWF0aW9uIGFib3V0XG4gICAqIHlvdXIgYXBwbGljYXRpb24ncyBpbml0aWFsaXphdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24oKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbik7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbikuY2FsbCh0aGlzLCBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLklOSVRJQUxJWkVfTUVUUklDX05BTUUpKTtcbiAgfVxuXG4gIHJldHVybiBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uO1xufShfS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb247XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLCBcIklOSVRJQUxJWkVfTUVUUklDX05BTUVcIiwgJ0luaXRpYWxpemF0aW9uJyk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY09iamVjdExpc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljT2JqZWN0TGlzdFwiKSk7XG5cbnZhciBfT2JqZWN0VmFsdWVzUG9ueWZpbGwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9oZWxwZXIvT2JqZWN0VmFsdWVzUG9ueWZpbGxcIikpO1xuXG4vKipcbiAqIE1ldHJpYyBvYmplY3QgbGlzdCB0aGF0IHRyYWNrcyBtZXRyaWNzIGJ5IG5hbWUsIGFuZCBnZW5lcmF0ZXMgbWV0cmljcyBwcmVmaXhlZCB3aXRoIHRoZSBuYW1lIG9mIHRoaXMgb2JqZWN0LlxuICovXG52YXIgS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdExpcykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCwgX0thdGFsTWV0cmljT2JqZWN0TGlzKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG5hbWVkIG9iamVjdCBsaXN0LlxuICAgKlxuICAgKiBUaGUgbmFtZSBnaXZlbiBoZXJlIHdpbGwgYmUgdXNlZCB0byBwcmVmaXggYWxsIG1ldHJpY3MuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhpcyBtZXRyaWNcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0KG5hbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCk7XG4gICAgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0KS5jYWxsKHRoaXMsIG5hbWUpKTtcbiAgICBfdGhpcy5uYW1lZE1ldHJpY3MgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCwgW3tcbiAgICBrZXk6IFwic2V0TmFtZWRNZXRyaWNcIixcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIG1ldHJpYyB3aXRoIHRoZSBnaXZlbiBuYW1lIHdpdGggYSBuZXcgbWV0cmljIGdlbmVyYXRlZCBieSB0aGUgZ2l2ZW4gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXRyaWMgc3VwcG9ydHMgbW9uaXRvcmluZywgaXRzIGlzTW9uaXRvciBmbGFnIHdpbGwgYmUgc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgKiBpc01vbml0b3IgZmxhZyBmb3IgdGhpcyBjb250YWluaW5nIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICogQHBhcmFtIG1ldHJpY0NyZWF0b3IgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIGZ1bGwgbmFtZSBmb3IgdGhpcyBtZXRyaWNcbiAgICAgKiAgICAgICAgYW5kIHJldHVybnMgYSBuZXdseSBjb25zdHJ1Y3RlZCBLYXRhbE1ldHJpY09iamVjdCB3aXRoIHRoaXMgbmFtZSBhbmQgYW4gYXBwcm9wcmlhdGUgdmFsdWVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TmFtZWRNZXRyaWMoc3ViTmFtZSwgbWV0cmljQ3JlYXRvcikge1xuICAgICAgdmFyIGZ1bGxOYW1lID0gdGhpcy5nZXROYW1lRm9yU3ViTWV0cmljKHN1Yk5hbWUpO1xuICAgICAgdmFyIG1ldHJpYyA9IG1ldHJpY0NyZWF0b3IoZnVsbE5hbWUpO1xuXG4gICAgICBpZiAobWV0cmljLmNhbk1vbml0b3IpIHtcbiAgICAgICAgbWV0cmljLmlzTW9uaXRvciA9IHRoaXMuaXNNb25pdG9yO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5hbWVkTWV0cmljc1tzdWJOYW1lXSA9IG1ldHJpYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGdpdmVuIHZhbHVlIGlzIHVuZGVmaW5lZCBvciBudWxsLCBkZWxldGUgdGhlIG1ldHJpYyB3aXRoIHRoZSBnaXZlIG5hbWU7IG90aGVyd2lzZSBpZiB0aGUgZ2l2ZW4gbmFtZWRcbiAgICAgKiBtZXRyaWMgYWxyZWFkeSBleGlzdHMgdXBkYXRlIGl0cyB2YWx1ZTsgb3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBtZXRyaWMgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIHNldCBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIHNwZWNpYWxpemVkIGhlbHBlciBtZXRob2QgaXMgZGVzaWduZWQgdG8gZGVhbCB3aXRoIHRoZSBjb21tb24gY2FzZSBvZiBhIHZhbHVlIHNldHRlciBpbiBhIG1vcmUgY29tcGxleFxuICAgICAqIG1ldHJpYy4gIE91dHNpZGUgb2Ygc3ViY2xhc3Nlcywgb3RoZXIgbWV0aG9kcyB3aWxsIHByb2JhYmx5IHByb3ZlIG1vcmUgdXNlZnVsLlxuICAgICAqXG4gICAgICogSWYgdGhlIHZhbHVlIGlzIG51bGwgdGhlIG1ldHJpYyB3aWxsIGFsc28gYmUgZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgbWV0cmljIHRvIGNyZWF0ZSBvciBkZWxldGVcbiAgICAgKiBAcGFyYW0gbmV3VmFsdWVDbGFzcyBDbGFzcyBvZiBuZXcgbWV0cmljIHRvIGNyZWF0ZVxuICAgICAqIEBwYXJhbSBuZXdWYWx1ZSBOZXcgdmFsdWUgZm9yIHRoaXMgbWV0cmljIChvciB1bmRlZmluZWQgdG8gZGVsZXRlIHRoZSBtZXRyaWMpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPckRlbGV0ZU5hbWVkTWV0cmljVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlKHN1Yk5hbWUsIG5ld1ZhbHVlQ2xhc3MsIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAobmV3VmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlTmFtZWRNZXRyaWMoc3ViTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWV0cmljID0gdGhpcy5nZXRPckNyZWF0ZU5hbWVkTWV0cmljKHN1Yk5hbWUsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBuZXdWYWx1ZUNsYXNzKG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldHJpYy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN1Yi1tZXRyaWMgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB1c2UgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBtZXRyaWMgYW5kXG4gICAgICogc3RvcmUgYW5kIHJldHVybiB0aGF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcGFyYW0gbWV0cmljQ3JlYXRvciBGdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgZnVsbCBuYW1lIGZvciB0aGlzIG1ldHJpY1xuICAgICAqICAgICAgICBhbmQgcmV0dXJucyBhIG5ld2x5IGNvbnN0cnVjdGVkIEthdGFsTWV0cmljT2JqZWN0IHdpdGggdGhpcyBuYW1lIGFuZCBhbiBhcHByb3ByaWF0ZSB2YWx1ZVxuICAgICAqIEByZXR1cm4gTWV0cmljIG9iamVjdCB3aGljaCB3YXMgcmV0cmlldmVkIG9yIGNyZWF0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE9yQ3JlYXRlTmFtZWRNZXRyaWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JDcmVhdGVOYW1lZE1ldHJpYyhzdWJOYW1lLCBtZXRyaWNDcmVhdG9yKSB7XG4gICAgICBpZiAoIXRoaXMubmFtZWRNZXRyaWNzW3N1Yk5hbWVdKSB7XG4gICAgICAgIHRoaXMuc2V0TmFtZWRNZXRyaWMoc3ViTmFtZSwgbWV0cmljQ3JlYXRvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm5hbWVkTWV0cmljc1tzdWJOYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBnaXZlbiBuYW1lZCBzdWItbWV0cmljLCBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViTmFtZSBOYW1lIG9mIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqIEByZXR1cm4ge0thdGFsTWV0cmljT2JqZWN0IHwgdW5kZWZpbmVkfSBNZXRyaWMgb2JqZWN0IHdpdGggdGhpcyBuYW1lIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHVuZGVmaW5lZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmFtZWRNZXRyaWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmFtZWRNZXRyaWMoc3ViTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZWRNZXRyaWNzW3N1Yk5hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGhlIGdpdmVuIG5hbWVkIHN1Yi1tZXRyaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlTmFtZWRNZXRyaWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlTmFtZWRNZXRyaWMoc3ViTmFtZSkge1xuICAgICAgZGVsZXRlIHRoaXMubmFtZWRNZXRyaWNzW3N1Yk5hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gbWV0cmljLCBvciB1bmRlZmluZWQgaWYgdGhlIG1ldHJpYyBkb2VzIG5vdCBleGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICogQHJldHVybiBWYWx1ZSBmb3IgdGhlIGdpdmVuIG1ldHJpYywgb3IgdW5kZWZpbmVkIGlmIHRoZSBtZXRyaWMgZG9lcyBub3QgZXhpc3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5hbWVkTWV0cmljVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmFtZWRNZXRyaWNWYWx1ZShzdWJOYW1lKSB7XG4gICAgICB2YXIgbWV0cmljID0gdGhpcy5nZXROYW1lZE1ldHJpYyhzdWJOYW1lKTtcbiAgICAgIGlmICghbWV0cmljKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG1ldHJpYy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBuYW1lIGZvciB0aGUgZ2l2ZW4gc3ViLW1ldHJpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICogQHJldHVybiBGdWxsIG5hbWUgZm9yIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmFtZUZvclN1Yk1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lRm9yU3ViTWV0cmljKHN1Yk5hbWUpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiLlwiKS5jb25jYXQoc3ViTmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ldHJpY0xpc3RcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAoMCwgX09iamVjdFZhbHVlc1BvbnlmaWxsLmRlZmF1bHQpKHRoaXMubmFtZWRNZXRyaWNzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0O1xufShfS2F0YWxNZXRyaWNPYmplY3RMaXN0LmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9WYWxpZGF0ZVNpbXBsZVN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlci9WYWxpZGF0ZVNpbXBsZVN0cmluZ1wiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1R5cGVcIikpO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGEgc2luZ2xlIG1ldHJpYyBpbiBLYXRhbC5cbiAqXG4gKiBBIHNpbmdsZSBtZXRyaWMgY29udGFpbnMgdGhlIG5hbWUgKG1ldHJpY0tleSksIHZhbHVlLCB0eXBlLCBhbmQgdGhlIGlzTW9uaXRvciBmbGFnOyBldmVyeXRoaW5nIGVsc2UgaXMgaW4gdGhlXG4gKiBLYXRhbE1ldHJpY3NDb250ZXh0IGl0IGlzIHB1Ymxpc2hlZCB0by5cbiAqL1xudmFyIEthdGFsTWV0cmljT2JqZWN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIE1ldHJpYyB0eXBlcy5cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBLYXRhbE1ldHJpY09iamVjdCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGlzIG1ldHJpYzsgcHVibGlzaGVkIGFzIG1ldHJpY0tleSBmaWVsZFxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNPYmplY3QobmFtZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljT2JqZWN0KTtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLl9pc01vbml0b3IgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lIGZvciB0aGlzIG1ldHJpYy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBuYW1lIGlzIGltbXV0YWJsZSwgYW5kIHRoaXMgY2Fubm90IGJlIHNldC5cbiAgICpcbiAgICogQHJldHVybnMgTmFtZSBmb3IgdGhpcyBtZXRyaWNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdCwgW3tcbiAgICBrZXk6IFwid2l0aE1vbml0b3JcIixcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLCBhbmQgcmV0dXJucyB0aGlzIG9iamVjdCBmb3IgY29udGludWVkIHVzZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZmxhZyBkZXRlcm1pbmVzIGlmIHRoZSBtZXRyaWMgY2FuIGJlIHVzZWQgZm9yIGRhc2hib2FyZHMgYW5kIGFsYXJtcyAoaS5lLiBpZiBpdCB3aWxsIGJlIHB1Ymxpc2hlZCB0byBQTUVUKVxuICAgICAqIEBwYXJhbSBpc01vbml0b3IgTmV3IHZhbHVlIGZvciB0aGUgaXNNb25pdG9yIGZsYWc7IGRlZmF1bHRzIHRvIHRydWVcbiAgICAgKiBAcmV0dXJucyBUaGlzIG9iamVjdFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoTW9uaXRvcigpIHtcbiAgICAgIHZhciBpc01vbml0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICB0aGlzLmlzTW9uaXRvciA9IGlzTW9uaXRvcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGlzTW9uaXRvciBmbGFnIGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBmb3JjZWQgdG8gYSBib29sZWFuIGJhc2VkIG9uIGl0cyB0cnV0aGluZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzTW9uaXRvciBOZXcgdmFsdWUgZm9yIHRoZSBpc01vbml0b3IgZmxhZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGlvbkVycm9yXCIsXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgYSB2YWxpZGF0aW9uIGVycm9yIG9uIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsaWRhdGlvbiBlcnJvciBlbmNvdW50ZXJlZCBpZiBvbmUgaXMgZm91bmQsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RXJyb3IgfCB1bmRlZmluZWR9IEVycm9yIGZvdW5kIHdpdGggdGhpcyBvYmplY3QsIG9yIHVuZGVmaW5lZCBpZiBubyBlcnJvciBpcyBmb3VuZFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICBpZiAodGhpcy5pc01vbml0b3IgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdGhpcy5pc01vbml0b3IgIT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRmllbGQgaXNNb25pdG9yIHNob3VsZCBiZSBhIGJvb2xlYW4sIGJ1dCBpdCB3YXMgYSBcIi5jb25jYXQoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHRoaXMuaXNNb25pdG9yKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF9WYWxpZGF0ZVNpbXBsZVN0cmluZy5kZWZhdWx0KSh0aGlzLm5hbWUsICdmaWVsZCBuYW1lJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgbmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIE5hbWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtZXRyaWNLZXlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc01vbml0b3JcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChpc01vbml0b3IpIHtcbiAgICAgIHRoaXMuX2lzTW9uaXRvciA9ICEhaXNNb25pdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlzTW9uaXRvciBmbGFnIGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGlzTW9uaXRvciBmbGFnIGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKi9cbiAgICAsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNNb25pdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG1ldHJpYyBjYW4gYmUgbWVhbmluZ2Z1bGx5IG1vbml0b3JlZC5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzLlxuICAgICAqXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoaXMgbWV0cmljIGNhbiBiZSBtZWFuaW5nZnVsbHkgbW9uaXRvcmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYW5Nb25pdG9yXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzIG9mIEthdGFsTWV0cmljT2JqZWN0IG11c3QgaW1wbGVtZW50IGNhbk1vbml0b3InKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0eXBlIG9mIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQHJldHVybiBUeXBlIG9mIHRoaXMgbWV0cmljIChvbmUgb2Y6IFN0cmluZywgQ291bnRlciwgVGltZXIsIExpc3QpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzIG9mIEthdGFsTWV0cmljT2JqZWN0IG11c3QgaW1wbGVtZW50IHR5cGUgZ2V0dGVyJyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY09iamVjdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNPYmplY3Q7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdCwgXCJUeXBlc1wiLCBfS2F0YWxNZXRyaWNUeXBlLmRlZmF1bHQpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9zZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG52YXIgX0ZpcnN0TWFwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL0ZpcnN0TWFwXCIpKTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRyaWMgdGhhdCBjb250YWlucyBhIGxpc3Qgb2Ygb3RoZXIgbWV0cmljczsgd2hlbiBpdCBpcyBwdWJsaXNoZWQsIHRoZSBsaXN0IG9mIG1ldHJpY3MgaXMgcmV0cmlldmVkLCBhbmQgYWxsXG4gKiBhcmUgcHVibGlzaGVkLlxuICovXG52YXIgS2F0YWxNZXRyaWNPYmplY3RMaXN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNPYmplY3QpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNPYmplY3RMaXN0LCBfS2F0YWxNZXRyaWNPYmplY3QpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgS2F0YWxNZXRyaWNPYmplY3RMaXN0LlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGlzIG1ldHJpYy4gIE5vdCByZWFsbHkgdXNlZCwgYnV0IHByZXNlbnQgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgbWV0cmljcy5cbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljT2JqZWN0TGlzdChuYW1lKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNPYmplY3RMaXN0KTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdExpc3QpLmNhbGwodGhpcywgbmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgZm9yIHRoaXMgb2JqZWN0XG4gICAqXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIG1ldHJpY3MgZm9yIHRoaXMgb2JqZWN0XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNPYmplY3RMaXN0LCBbe1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcblxuICAgIC8qKlxuICAgICAqIElmIGFueSBvZiB0aGUgY29udGFpbmVkIG1ldHJpY3MgYXJlIGludmFsaWQsIHJldHVybiB0aGUgZmlyc3QgdmFsaWRhdGlvbiBlcnJvciBlbmNvdW50ZXJlZDsgb3RoZXJ3aXNlIHJldHVyblxuICAgICAqIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGlzbid0IGNhbGxlZCBieSB0aGUgcHVibGlzaGVyOyBpdCB2YWxpZGF0ZXMgZWFjaCBzdWItbWV0cmljIG9uIGl0cyBvd24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBFcnJvciBmb3VuZCB3aXRoIHN1Ym1ldHJpYywgaWYgYW55OyBlbHNlIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICAvLyBEb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gY2hlY2sgc3VwZXJjbGFzcyBlcnJvciBoZXJlLCBzaW5jZSBpdCBpcyB0aGUgY29udGFpbmVkIG1ldHJpY3MgdGhhdCBtYXR0ZXIuXG4gICAgICByZXR1cm4gKDAsIF9GaXJzdE1hcC5kZWZhdWx0KSh0aGlzLm1ldHJpY0xpc3QsIGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgcmV0dXJuIG1ldHJpYy52YWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXRyaWNMaXN0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzIG9mIEthdGFsTWV0cmljT2JqZWN0TGlzdCBtdXN0IGltcGxlbWVudCBtZXRyaWNMaXN0IGdldHRlcicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc01vbml0b3JcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChpc01vbml0b3IpIHtcbiAgICAgICgwLCBfc2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdExpc3QucHJvdG90eXBlKSwgXCJpc01vbml0b3JcIiwgaXNNb25pdG9yLCB0aGlzLCB0cnVlKTtcbiAgICAgIHRoaXMubWV0cmljTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgaWYgKG1ldHJpYy5jYW5Nb25pdG9yKSB7XG4gICAgICAgICAgbWV0cmljLmlzTW9uaXRvciA9IGlzTW9uaXRvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBUaGlzIGp1c3QgZGVsZWdhdGVzIHRvIHRoZSBzdXBlcmNsYXNzLCBidXQgaWYgd2Ugb3ZlcnJpZGUgdGhlIHNldHRlciB3aXRob3V0IG92ZXJyaWRpbmcgdGhlIGdldHRlclxuICAgIC8vIGdldHRpbmcgdGhlIHByb3BlcnR5IHdpbGwgYWx3YXlzIHJldHVybiB1bmRlZmluZWQuXG4gICAgLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdExpc3QucHJvdG90eXBlKSwgXCJpc01vbml0b3JcIiwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0LlR5cGVzLkxpc3Q7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY09iamVjdExpc3Q7XG59KF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljT2JqZWN0TGlzdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG4vKipcbiAqIFN0cmluZyB0eXBlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIHN0b3JlIGFyYml0cmFyeSBzdHJpbmdzIG9mIGRhdGEuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1N0cmluZyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljU3RyaW5nLCBfS2F0YWxNZXRyaWNPYmplY3QpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFN0cmluZyBuYW1lXG4gICAqIEBwYXJhbSB2YWx1ZSBTdHJpbmcgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljU3RyaW5nKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNTdHJpbmcpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1N0cmluZykuY2FsbCh0aGlzLCBuYW1lKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJ0cnVuY2F0ZVwiLCBmYWxzZSk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoaXMgc3RyaW5nIG1ldHJpYy5cbiAgICpcbiAgICogQHJldHVybiBWYWx1ZSBmb3IgdGhpcyBtZXRyaWNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1N0cmluZywgW3tcbiAgICBrZXk6IFwidmFsaWRhdGlvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIHZhciBzdXBlckVycm9yID0gKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljU3RyaW5nLnByb3RvdHlwZSksIFwidmFsaWRhdGlvbkVycm9yXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpZiAoc3VwZXJFcnJvcikgcmV0dXJuIHN1cGVyRXJyb3I7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIGZpZWxkIHZhbHVlIGluIFN0cmluZyBtZXRyaWNzIG9iamVjdCAnXCIuY29uY2F0KHRoaXMubmFtZSwgXCInIHRvIGJlIHR5cGUgc3RyaW5nLCBidXQgaXQgd2FzIFwiKS5jb25jYXQoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHRoaXMudmFsdWUpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA+IEthdGFsTWV0cmljU3RyaW5nLk1BWF9TSVpFKSB7XG4gICAgICAgIGlmICh0aGlzLnRydW5jYXRlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc3Vic3RyaW5nKDAsIEthdGFsTWV0cmljU3RyaW5nLk1BWF9TSVpFKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgZmllbGQgdmFsdWUgaW4gU3RyaW5nIG1ldHJpY3Mgb2JqZWN0ICdcIi5jb25jYXQodGhpcy5uYW1lLCBcIicgdG8gYmUgXCIpLmNvbmNhdChLYXRhbE1ldHJpY1N0cmluZy5NQVhfU0laRSwgXCIgY2hhcmFjdGVycyBvciBsZXNzLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodGhpcy52YWx1ZS5sZW5ndGgsIFwiIGNoYXJhY3RlcnMuXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBEaWRuJ3QgZmluZCBhbnl0aGluZyB3cm9uZywgaW1wbGljaXRseSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBzdHJpbmcgbWV0cmljLlxuICAgICAqXG4gICAgICogVGhlIG5ldyB2YWx1ZSBzaG91bGQgYmUgYSBzdHJpbmcsIGJ1dCBudW1iZXIgYW5kIGJvb2xlYW4gdHlwZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBzdHJpbmdzLlxuICAgICAqIEZvciBvdGhlciB0eXBlcywgaW5jbHVkaW5nIHVuZGVmaW5lZCBhbmQgbnVsbCwgdGhlIHZhbHVlIHdpbGwgYmUgYWNjZXB0ZWQsIGJ1dCB3aWxsIGZhaWwgdmFsaWRhdGlvbiB3aGVuIHB1Ymxpc2hpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGlzIG1ldHJpY1xuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGlvbiBmbGFnIGZvciB0aGlzIHN0cmluZyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBJZiBzZXQsIHRoZSB2YWx1ZSBoZXJlIHdpbGwgYmUgYXV0b21hdGljYWxseSB0cnVuY2F0ZWQgdG8gdGhlIG1heGltdW0gc2l6ZSBhbGxvd2VkIGJ5IHRoZSBjdXJyZW50IHNjaGVtYS5cbiAgICAgKiBPdGhlcndpc2UsIHNlbmRpbmcgYSB2YWx1ZSBsYXJnZXIgdGhhbiBhbGxvd2VkIHdpbGwgcmVzdWx0IGluIGEgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUcnVlIHRvIGF1dG9tYXRpY2FsbHkgdHJ1bmNhdGUgbWV0cmljcywgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0eXBlIGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQWx3YXlzIHJldHVybnMgXCJTdHJpbmdcIi5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuU3RyaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5Nb25pdG9yXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY1N0cmluZztcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNTdHJpbmc7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY1N0cmluZywgXCJNQVhfU0laRVwiLCAyNTYpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY0NvdW50ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljQ291bnRlclwiKSk7XG5cbi8qKlxuICogTWV0cmljIHRoYXQgcGFpcnMgYSB0aW1lciBhbmQgYSBmYWlsdXJlIGNvdW50ZXIgdG8gcmVjb3JkIHRoZSB0aW1lIGFuZCBzdGF0dXMgb2YgYW4gYXR0ZW1wdCB0byBkbyBzb21ldGhpbmcuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0thdGFsTWV0cmljTmFtZWRPYmplKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LCBfS2F0YWxNZXRyaWNOYW1lZE9iamUpO1xuXG4gIC8qKiBUaGUgc3ViLW1ldHJpYyBuYW1lIGZvciBsYXRlbmN5LiAqL1xuXG4gIC8qKiBUaGUgc3ViLW1ldHJpYyBuYW1lIGZvciBmYWlsdXJlIGNvdW50LiAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdGltZWQgYXR0ZW1wdCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIFRoaXMgd2lsbCBjcmVhdGUgdHdvIGlubmVyIG1ldHJpY3MsIGEgS2F0YWxNZXRyaWNDb3VudGVyIHRoYXQgaGFzIHRoZSBnaXZlbiBuYW1lIHdpdGggXCIuRmFpbHVyZVwiIGFwcGVuZGVkLFxuICAgKiBhbmQgYSBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoIHRoYXQgaGFzIHRoZSBnaXZlbiBuYW1lIHdpdGggXCIuTGF0ZW5jeVwiIGFwcGVuZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoaXMgYXR0ZW1wdFxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQobmFtZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljVGltZWRBdHRlbXB0KTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQpLmNhbGwodGhpcywgbmFtZSkpO1xuXG4gICAgX3RoaXMuc2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuTEFURU5DWV9TVUZGSVgsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmV3IF9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLmRlZmF1bHQobmFtZSk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5zZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5GQUlMVVJFX1NVRkZJWCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBuZXcgX0thdGFsTWV0cmljQ291bnRlci5kZWZhdWx0KG5hbWUsIDEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGZhaWx1cmUgY291bnRlciBtZXRyaWMgYmFzZWQgb24gdGhlIGdpdmVuIGZhaWx1cmUgc3RhdHVzLlxuICAgKlxuICAgKiBJZiBmYWlsdXJlIGlzIHRydWUgdGhlIGNvdW50ZXIgd2lsbCBoYXZlIGEgdmFsdWUgb2YgMTsgaWYgaXQgaXMgZmFsc2UgdGhlIGNvdW50ZXIgd2lsbCBoYXZlIGEgdmFsdWUgb2YgMC5cbiAgICpcbiAgICogQHBhcmFtIGZhaWx1cmUgV2hldGhlciB0aGlzIGlzIGEgZmFpbHVyZSBvciBub3Q7IGRlZmF1bHQgdHJ1ZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LCBbe1xuICAgIGtleTogXCJzZXRGYWlsdXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZhaWx1cmUoKSB7XG4gICAgICB2YXIgZmFpbHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHZhciBmYWlsdXJlQ291bnQgPSBmYWlsdXJlID8gMSA6IDA7XG4gICAgICB2YXIgbWV0cmljID0gdGhpcy5mYWlsdXJlTWV0cmljO1xuICAgICAgbWV0cmljLnZhbHVlID0gZmFpbHVyZUNvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZhaWx1cmUgc3RhdHVzIHRvIGZhbHNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U3VjY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdWNjZXNzKCkge1xuICAgICAgdGhpcy5zZXRGYWlsdXJlKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsYXRlbmN5IG1ldHJpYyB0byB0aGUgZ2l2ZW4gdmFsdWUsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIE5vdGUgeW91IGRvbid0IG5vcm1hbGx5IGhhdmUgdG8gc2V0IHRoaXMsIHRoZSB1bmRlcmx5aW5nIG1ldHJpYyBpcyBhIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2ggdGhhdCB3aWxsIHN0YXJ0XG4gICAgICogYW5kIHN0b3AgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXRlbmN5TXMgTGF0ZW5jeSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldExhdGVuY3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGF0ZW5jeShsYXRlbmN5TXMpIHtcbiAgICAgIHZhciBtZXRyaWMgPSB0aGlzLmxhdGVuY3lNZXRyaWM7XG4gICAgICBtZXRyaWMudmFsdWUgPSBsYXRlbmN5TXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGltZXIgc3RvcHdhdGNoIG1ldHJpYyBmb3IgdGhpcyBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQHJldHVybiBUaW1lciBzdG9wd2F0Y2ggbWV0cmljIGZvciB0aGlzIGF0dGVtcHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxhdGVuY3lNZXRyaWNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LkxBVEVOQ1lfU1VGRklYKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmYWlsdXJlIGNvdW50ZXIgbWV0cmljIGZvciB0aGlzIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEZhaWx1cmUgY291bnRlciBtZXRyaWMgZm9yIHRoaXMgZXZlbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZhaWx1cmVNZXRyaWNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LkZBSUxVUkVfU1VGRklYKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljVGltZWRBdHRlbXB0O1xufShfS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljVGltZWRBdHRlbXB0O1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQsIFwiTEFURU5DWV9TVUZGSVhcIiwgJ0xhdGVuY3knKTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LCBcIkZBSUxVUkVfU1VGRklYXCIsICdGYWlsdXJlJyk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlSW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL1ZhbGlkYXRlU2ltcGxlSW50XCIpKTtcblxuLyoqXG4gKiBUaW1lciB0eXBlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIHJlY29yZCBhIHRpbWUuICBUaGlzIGNsYXNzIHJlcXVpcmVzIGV4cGxpY2l0IHZhbHVlOyBzZWUgS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCBmb3IgYXV0b21hdGljXG4gKiB0aW1pbmcuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1RpbWVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNPYmplY3QpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lciwgX0thdGFsTWV0cmljT2JqZWN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRpbWVyIG1ldHJpYy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBmb3IgdGhlIG1ldHJpY1xuICAgKiBAcGFyYW0gdmFsdWUgVGltZXIgdmFsdWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY1RpbWVyKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNUaW1lcik7XG4gICAgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXIpLmNhbGwodGhpcywgbmFtZSkpO1xuICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIGZvciB0aGlzIHRpbWVyXG4gICAqXG4gICAqIEByZXR1cm4gVGltZXIgdmFsdWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lciwgW3tcbiAgICBrZXk6IFwidmFsaWRhdGlvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIHZhciBzdXBlckVycm9yID0gKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXIucHJvdG90eXBlKSwgXCJ2YWxpZGF0aW9uRXJyb3JcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGlmIChzdXBlckVycm9yKSByZXR1cm4gc3VwZXJFcnJvcjtcbiAgICAgIHJldHVybiAoMCwgX1ZhbGlkYXRlU2ltcGxlSW50LmRlZmF1bHQpKHRoaXMudmFsdWUsIFwiZmllbGQgdmFsdWUgaW4gVGltZXIgbWV0cmljcyBvYmplY3QgJ1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiJ1wiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgZm9yIHRoaXMgdGltZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgdGltZXIgdmFsdWUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gTWF0aC5yb3VuZCB3aWxsIGFsc28gY29lcmNlIGZyb20gYSBzdHJpbmcgaWYgbmVjZXNzYXJ5LCBhbmQgcmV0dXJuIE5hTiBpZiBpbnZhbGlkXG5cblxuICAgICAgdGhpcy5fdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0eXBlIGZvciB0aGlzIHRpbWVyLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBcIlRpbWVyXCIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0LlR5cGVzLlRpbWVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5Nb25pdG9yXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljVGltZXI7XG59KF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljVGltZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9zZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRcIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUaW1lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZXJcIikpO1xuXG4vKipcbiAqIFN1YmNsYXNzIG9mIEthdGFsTWV0cmljVGltZXIgdGhhdCBjYW4gYmUgc3RhcnRlZCBhbmQgc3RvcHBlZCwgYW5kIHdpbGwgcmVjb3JkIHRoZSBlbGFwc2VkIHRpbWUgYmV0d2VlbiBzdGFydGluZyBhbmRcbiAqIHN0b3BwaW5nLiAgQnkgZGVmYXVsdCBpdCB3aWxsIHN0YXJ0IHdoZW4gdGhlIG9iamVjdCBpcyBjcmVhdGVkLCBhbmQgc3RvcHBlZCB3aGVuIHRoZSB2YWx1ZSBpcyByZXRyaWV2ZWQgd2l0aFxuICogdGhlIGdldHRlciBcInZhbHVlXCIuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNUaW1lcikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLCBfS2F0YWxNZXRyaWNUaW1lcik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0aW1lciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCBzdGFydGluZyB0aW1lLiAgSWYgbm8gc3RhcnRpbmcgdGltZSBpcyBnaXZlbiwgdGhlIGN1cnJlbnQgdGltZSBpcyB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGlzIHRpbWVyXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgTWlsbGlzZWNvbmQgZXBvY2ggdGltZSBmb3IgdGhlIHN0YXJ0IHRpbWU7IGRlZmF1bHRzIHRvIG5vd1xuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaChuYW1lLCBzdGFydFRpbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoKTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCkuY2FsbCh0aGlzLCBuYW1lLCB1bmRlZmluZWQpKTtcblxuICAgIF90aGlzLnN0YXJ0KHN0YXJ0VGltZSk7XG5cbiAgICBfdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZS1zdGFydCB0aW1lciB3aXRoIHRoZSBnaXZlbiBzdGFydCB0aW1lLCBvciB0aGUgY3VycmVudCB0aW1lIGlmIG5vbmUgaXMgZ2l2ZW4uXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgV2hlbiB0aGUgdGltZXIgd2FzIHN0YXJ0ZWQsIGluIGVwb2NoIG1pbGxpc2Vjb25kczsgZGVmYXVsdHMgdG8gbm93XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCwgW3tcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoc3RhcnRUaW1lKSB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBzdGFydFRpbWUgfHwgdGhpcy5ub3coKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgdGltZXIgYW5kIHJlY29yZCB0aGUgZWxhcHNlZCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3BUaW1lIFdoZW4gdGhlIHRpbWVyIHdhcyBzdG9wcGVkLCBpbiBlcG9jaCBtaWxsaXNlY29uZHM7IGRlZmF1bHRzIHRvIG5vd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKHN0b3BUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcFRpbWUgPSBzdG9wVGltZSB8fCB0aGlzLm5vdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgdGltZXIgaGFzIGJlZW4gc3RvcHBlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRpbWVyIGhhcyBiZWVuIHN0b3BwZWQgeWV0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJub3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm93KCkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1N0b3BwZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHdoZW4gdGhlIHRpbWVyIHdhcyBzdGFydGVkIGFuZCBzdG9wcGVkOyBpZiB0aGUgdGltZXIgaGFzIG5vdCB5ZXQgYmVlbiBzdG9wcGVkLFxuICAgICAqIHN0b3AgaXQgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBFbGFwc2VkIHRpbWUgYmV0d2VlbiB3aGVuIHRpbWVyIHdhcyBzdGFydGVkIGFuZCBzdG9wcGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdGhpcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH0gLy8gUmVseSBvbiBzdXBlci52YWx1ZSBzZXR0ZXIgdG8gcm91bmRcblxuXG4gICAgICAgICgwLCBfc2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdGhpcy5zdG9wVGltZSAtIHRoaXMuc3RhcnRUaW1lLCB0aGlzLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB3aGVuIHRoaXMgdGltZXIgd2FzIHN0YXJ0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFN0YXJ0IHRpbWUsIGluIGVwb2NoIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgICxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgZm9yIHRoaXMgbWV0cmljLiAgTm90ZSB0aGlzIHdpbGwgb3ZlcnJpZGUgdGhlIHN0b3B3YXRjaCBiZWhhdmlvciBhbmQganVzdCB1c2UgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIGZvciB0aGlzIG1ldHJpY1xuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAoMCwgX3NldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5wcm90b3R5cGUpLCBcInZhbHVlXCIsIHZhbHVlLCB0aGlzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRUaW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgd2hlbiB0aGlzIHRpbWVyIHdhcyBzdG9wcGVkIChvciB1bmRlZmluZWQgaWYgaXQgaXMgc3RpbGwgcnVubmluZylcbiAgICAgKlxuICAgICAqIEByZXR1cm4gU3RvcCB0aW1lLCBpbiBlcG9jaCBtaWxsc2Vjb25kcywgb3IgdW5kZWZpbmVkIGlmIHRoZSBzdG9wd2F0Y2ggaXMgc3RpbGwgcnVubmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFRpbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2g7XG59KF9LYXRhbE1ldHJpY1RpbWVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLyoqXG4gKiBNZXRyaWMgdHlwZXMuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1R5cGU7XG5cbihmdW5jdGlvbiAoS2F0YWxNZXRyaWNUeXBlKSB7XG4gIEthdGFsTWV0cmljVHlwZVtcIlN0cmluZ1wiXSA9IFwiU3RyaW5nXCI7XG4gIEthdGFsTWV0cmljVHlwZVtcIkNvdW50ZXJcIl0gPSBcIkNvdW50ZXJcIjtcbiAgS2F0YWxNZXRyaWNUeXBlW1wiVGltZXJcIl0gPSBcIlRpbWVyXCI7XG4gIEthdGFsTWV0cmljVHlwZVtcIkxpc3RcIl0gPSBcIkxpc3RcIjtcbn0pKEthdGFsTWV0cmljVHlwZSB8fCAoS2F0YWxNZXRyaWNUeXBlID0ge30pKTtcblxuO1xudmFyIF9kZWZhdWx0ID0gS2F0YWxNZXRyaWNUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT2JqZWN0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY09iamVjdC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cmluZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNTdHJpbmcuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb3VudGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY0NvdW50ZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNUaW1lci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVyU3RvcHdhdGNoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZWRBdHRlbXB0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluaXRpYWxpemF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSHR0cFJlcXVlc3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljSHR0cFJlcXVlc3QuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljT2JqZWN0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1N0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNTdHJpbmdcIikpO1xuXG52YXIgX0thdGFsTWV0cmljQ291bnRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNDb3VudGVyXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVyXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljSW5pdGlhbGl6YXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljSW5pdGlhbGl6YXRpb25cIikpO1xuXG52YXIgX0thdGFsTWV0cmljSHR0cFJlcXVlc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljSHR0cFJlcXVlc3RcIikpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIHR3byBJSUZFcyB0aGF0IHRoZSBTdXNoaSBsaWJyYXJ5IGNvbnRhaW5zLiBBIGZha2UgQ1NNIGFuZCBXaW5kb3cgb2JqZWN0IGFyZSBjcmVhdGVkIGFuZCBwcm92aWRlZFxuICogdG8gdGhlIGZ1bmN0aW9ucyBzbyB0aGF0IHRoZXkgYWN0dWFsbHkgZXhlY3V0ZSBpbiBhIGNvbnRyb2xsZWQgZW52aXJvbm1lbnQgYXdheSBmcm9tIGFueSBDU00gY29kZSB0aGF0IG1pZ2h0IGJlIGV4ZWN1dGluZ1xuICogYXQgdGhlIHBsYXRmb3JtIGxldmVsIHdpdGhpbiB0aGUgcGFnZS5cbiAqXG4gKiBUaGUgYmFzaWMgcnVuIG9yZGVyIGlzIHRoZSBmb2xsb3dpbmc6XG4gKiAxLiBCdWlsZCB0aGUgbW9jayBDU00gb2JqZWN0LCB0aGVuIGJ1aWxkIGEgbW9jayBXaW5kb3cgb2JqZWN0IHRoYXQgcmVmZXJlbmNlcyB0aGUgQ1NNIG9iamVjdCBhcyB1ZV9jc21cbiAqIDIuIFJ1biB0aGUgdHJhbnNwb3J0YXRpb24tY2xpZW50cy5qcyBTY3JpcHQgZnJvbSBTdXNoaUphdmFzY3JpcHRDbGllbnQgcHJvdmlkaW5nIHRoZSBtb2Nrcy4gSXQgd2lsbCBtb2RpZnkgZ2xvYmFscyBvbiB0aGUgbW9jayBvYmplY3RzLlxuICogMy4gUnVuIHRoZSBzdXNoaS1jbGllbnQuanMgc2NyaXB0IGZyb20gU3VzaGlKYXZhU2NyaXB0Q2xpZW50IHByb3ZpZGluZyB0aGUgbW9ja3MuIEl0IHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBzdXNoaSBjbGllbnQgYW5kIGluamVjdCBpdCBpbnRvIHRoZSBDU00gZ2xvYmFscyBpbiB0aGUgbW9ja3MuXG4gKiA0LiB3aGVuZXZlciBldmVudCgpIGlzIGNhbGxlZCwgcmVmZXIgdG8gdGhlIGVuY2Fwc3VsYXRlZCBjc20gb2JqZWN0IHRvIGFkZCB0aGUgZXZlbnQgdG8gdGhlIHF1ZXVlLlxuICovXG52YXIgU3VzaGlDbGllbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTdXNoaUNsaWVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiY3JlYXRlU3VzaGlVcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU3VzaGlVcmwocmVnaW9uLCBzb3VyY2VHcm91cCkge1xuICAgICAgaWYgKCFzb3VyY2VHcm91cCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXNoaSBEcml2ZXIgd2FzIG5vdCBwcm92aWRlZCB3aXRoIGEgc291cmNlIGdyb3VwLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRvbWFpbjtcblxuICAgICAgc3dpdGNoIChyZWdpb24pIHtcbiAgICAgICAgY2FzZSBTdXNoaUNsaWVudC5SRUdJT05TLk5BOlxuICAgICAgICAgIGRvbWFpbiA9IFwidW5hZ2ktbmFcIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN1c2hpQ2xpZW50LlJFR0lPTlMuRVU6XG4gICAgICAgICAgZG9tYWluID0gXCJ1bmFnaS1ldVwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3VzaGlDbGllbnQuUkVHSU9OUy5GRTpcbiAgICAgICAgICBkb21haW4gPSBcInVuYWdpLWZlXCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdXNoaUNsaWVudC5SRUdJT05TLkNOOlxuICAgICAgICAgIGRvbWFpbiA9IFwidW5hZ2ktY25cIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCByZWdpb24gJ1wiLmNvbmNhdChyZWdpb24sIFwiJyBwcm92aWRlZCB0byBTdXNoaUNsaWVudC5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJodHRwczovL1wiLmNvbmNhdChkb21haW4sIFwiLmFtYXpvbi5jb20vMS9ldmVudHMvXCIpLmNvbmNhdChzb3VyY2VHcm91cCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUNzbVVzZXJDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNzbVVzZXJDb250ZXh0KHN1c2hpVXJsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGhpUHJpRmx1c2hJbnRlcnZhbDogMTAwMCxcbiAgICAgICAgbG93UHJpRmx1c2hJbnRlcnZhbDogMTAwMDAsXG4gICAgICAgIHJlcXVlc3RJZDogXCIxXCIsXG4gICAgICAgIGVycm9yQ2hhbm5lbDogXCJqc2VyclwiLFxuICAgICAgICBzZXNzaW9uU3RvcmFnZVdyYXBwZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3JIYW5kbGVyRnVuY3Rpb246IGNvbnNvbGUubG9nLFxuICAgICAgICBzdXNoaVVybDogc3VzaGlVcmxcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTdXNoaSBDbGllbnQgZm9yIGEgcmVnaW9uIGFuZCBzb3VyY2UgZ3JvdXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWdpb24gUmVnaW9uIGluIFN1c2hpQ2xpZW50LlJFR0lPTlNcbiAgICAgKiBAcGFyYW0gc291cmNlR3JvdXAgU3VzaGkgRWVsIHNvdXJjZSBncm91cFxuICAgICAqIEBwYXJhbSBlcnJvckhhbmRsZXIgRXJyb3IgaGFuZGxlciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgQ1NNIGNvbnRleHQgb3ZlcnJpZGVzXG4gICAgICogQHBhcmFtIGNsaWVudE92ZXJyaWRlIEFuIG9wdGlvbmFsIHRyYW5zcG9ydGF0aW9uIGNsaWVudCBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBjbGllbnRzIChuYXZpZ2F0b3Iuc2VuZEJlYWNvbiBhbmQgWERvbWFpblJlcXVlc3Qgb3IgWE1MSHR0cFJlcXVlc3QpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJSRUdJT05TXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBOQTogXCJOQVwiLFxuICAgICAgICBFVTogXCJFVVwiLFxuICAgICAgICBGRTogXCJGRVwiLFxuICAgICAgICBDTjogXCJDTlwiXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFN1c2hpQ2xpZW50KCkge1xuICAgIHZhciByZWdpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFN1c2hpQ2xpZW50LlJFR0lPTlMuTkE7XG4gICAgdmFyIHNvdXJjZUdyb3VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGVycm9ySGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICB2YXIgY2xpZW50T3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBTdXNoaUNsaWVudCk7XG4gICAgdmFyIHN1c2hpVXJsID0gU3VzaGlDbGllbnQuY3JlYXRlU3VzaGlVcmwocmVnaW9uLCBzb3VyY2VHcm91cCk7XG4gICAgdmFyIGNzbVVzZXJDb250ZXh0ID0gU3VzaGlDbGllbnQuY3JlYXRlQ3NtVXNlckNvbnRleHQoc3VzaGlVcmwsIG9wdGlvbnMpO1xuICAgIHRoaXMudWVfY3NtID0gdGhpcy5zZXR1cE1vY2tDU01PYmplY3QoY3NtVXNlckNvbnRleHQpO1xuICAgIHRoaXMuZW5jYXBzdWxhdGVkV2luZG93ID0gdGhpcy5zZXR1cE1vY2tXaW5kb3codGhpcy51ZV9jc20pO1xuICAgIHRoaXMudHJhbnNwb3J0YXRpb25DbGllbnRDb2RlKHRoaXMudWVfY3NtLCB3aW5kb3cpO1xuXG4gICAgaWYgKGNsaWVudE92ZXJyaWRlKSB7XG4gICAgICB0aGlzLnVlX2NzbS51ZS5fc0JjbiA9IHtcbiAgICAgICAgaXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZW5kcG9pbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICBjbGllbnRPdmVycmlkZShlbmRwb2ludCwgcGF5bG9hZCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5jbGllbnRDb2RlKHRoaXMudWVfY3NtLCB0aGlzLmVuY2Fwc3VsYXRlZFdpbmRvdyk7XG4gICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTdXNoaUNsaWVudCwgW3tcbiAgICBrZXk6IFwiZXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZlbnQoZGF0YSwgcHJvZHVjZXJJZCwgc2NoZW1hSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlN1c2hpQ2xpZW50IHdyYXBwZXIgcHVibGlzaGluZyB0aGUgZm9sbG93aW5nOlwiLCB7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBwcm9kdWNlcklkOiBwcm9kdWNlcklkLFxuICAgICAgICAgIHNjaGVtYUlkOiBzY2hlbWFJZCxcbiAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy51ZV9jc20udWUuZXZlbnQoZGF0YSwgcHJvZHVjZXJJZCwgc2NoZW1hSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgcGxhbiB0byBlbWl0IDEwMDAgb3IgbW9yZSBldmVudHMgcGVyIGluc3RhbnRpYXRlZCBjbGllbnQsXG4gICAgICogY2FsbCByZXNldCBhZnRlciBjYWxsaW5nIGV2ZW50IHRvIGFsbG93IHRoZSBDU00gY2xpZW50IHRvIGNvbnRpbnVlIHNlbmRpbmcgZXZlbnRzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnVlX2NzbS51ZS5ldmVudC5yZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQganVzdCBiZWZvcmUgZWFjaCB0aW1lIG1ldHJpY3MgYXJlXG4gICAgICogZmx1c2hlZCB0byB0aGUgbmV0d29yay5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IHN1c2hpIHdpbGwgY2FsbCBiZWZvcmUgZmx1c2hlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uU3VzaGlGbHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN1c2hpRmx1c2goY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudWVfY3NtLnVlLm9uU3VzaGlGbHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFnZSB1bmxvYWRzLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gc2VuZCBhbnkgZmluYWwgbWV0cmljcyB0byBzdXNoaSwgc3VjaCBhcyBwYWdlIHZpc2l0XG4gICAgICogZHVyYXRpb24gb3IgYmF0Y2hlZCBjb3VudGVycy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IHN1c2hpIHdpbGwgY2FsbCBiZWZvcmUgdW5sb2FkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25TdXNoaVVubG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN1c2hpVW5sb2FkKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVlX2NzbS51ZS5vblN1c2hpVW5sb2FkKGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBNb2NrQ1NNT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwTW9ja0NTTU9iamVjdChjc21Vc2VyQ29udGV4dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGV4ZWNTdHViID0gZnVuY3Rpb24gZXhlY1N0dWIoY2FsbGJhY2ssIGF0dHJpYnV0aW9uKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgIH07XG5cbiAgICAgIHZhciBldmVudFN0dWIgPSBmdW5jdGlvbiBldmVudFN0dWIobG9nLCBwcm9kdWNlciwgZXZlbnRUeXBlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlN1c2hpQ2xpZW50IENTTSBzdHViIGNhbGxlZCBpbiB1bnN1cHBvcnRlZCBtYW5uZXI6IGV2ZW50KClcIik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gZXJyb3JIYW5kbGVyKGxvZ0V2ZW50LCBjaGFubmVsKSB7XG4gICAgICAgIGlmIChfdGhpcy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICBfdGhpcy5lcnJvckhhbmRsZXIobG9nRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQW4gZXJyb3IgaGFzIG9jY3VycmVkIGluIFN1c2hpQ2xpZW50IGNoYW5uZWwgXCIgKyBjaGFubmVsLCBsb2dFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBhdHRhY2hIYW5kbGVyID0gZnVuY3Rpb24gYXR0YWNoSGFuZGxlcihldnQsIGhhbmRsZXIsIGNvbnRhaW5lcikge1xuICAgICAgICAvL1RPRE8gbWlnaHQgYmUgYWJsZSB0byBqdXN0IHVzZSB3aW5kb3cudWUuYXR0YWNoP1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgd2luZG93OyAvL29rIHRvIHVzZSByZWFsIHdpbmRvdyBnbG9iYWwgaGVyZS5cblxuICAgICAgICBpZiAod2luZG93LkV2ZW50VGFyZ2V0ICYmIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUgJiYgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyLmNhbGwoY29udGFpbmVyLCBldnQsIGhhbmRsZXIsICEhd2luZG93LnVlX2NsZik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsICEhd2luZG93LnVlX2NsZik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgY29udGFpbmVyLmF0dGFjaEV2ZW50KFwib25cIiArIGV2dCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVlX2hwc2k6IGNzbVVzZXJDb250ZXh0LmhpUHJpRmx1c2hJbnRlcnZhbCxcbiAgICAgICAgdWVfbHBzaTogY3NtVXNlckNvbnRleHQubG93UHJpRmx1c2hJbnRlcnZhbCxcbiAgICAgICAgdWU6IHtcbiAgICAgICAgICBzc3c6IGNzbVVzZXJDb250ZXh0LnNlc3Npb25TdG9yYWdlV3JhcHBlcixcbiAgICAgICAgICBsb2c6IGVycm9ySGFuZGxlcixcbiAgICAgICAgICBleGVjOiBleGVjU3R1YixcbiAgICAgICAgICBldmVudDogZXZlbnRTdHViLFxuICAgICAgICAgIGF0dGFjaDogYXR0YWNoSGFuZGxlclxuICAgICAgICB9LFxuICAgICAgICB1ZUxvZ0Vycm9yOiBjc21Vc2VyQ29udGV4dC5lcnJvckhhbmRsZXJGdW5jdGlvbixcbiAgICAgICAgdWVfc3VybDogY3NtVXNlckNvbnRleHQuc3VzaGlVcmwsXG4gICAgICAgIHVlX2lkOiBjc21Vc2VyQ29udGV4dC5yZXF1ZXN0SWQsXG4gICAgICAgIHVlX2Vycl9jaGFuOiBjc21Vc2VyQ29udGV4dC5lcnJvckNoYW5uZWxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwTW9ja1dpbmRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cE1vY2tXaW5kb3codWVfY3NtKSB7XG4gICAgICAvL2FwcGFyZW50bHkgY2Fubm90IHJlZiB0aGUgc2V0VGltZW91dCBmdW5jdGlvbiBkaXJlY3RseSBpbiBzb21lIGJyb3dzZXJzIHNvIHdlIGhhdmUgdG8gd3JhcCBpdC5cbiAgICAgIHZhciB0aW1lb3V0V3JhcHBlciA9IGZ1bmN0aW9uIHRpbWVvdXRXcmFwcGVyKGZuLCB0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZW91dCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1ZV9jc206IHVlX2NzbSxcbiAgICAgICAgdWVMb2dFcnJvcjogdWVfY3NtLnVlTG9nRXJyb3IsXG4gICAgICAgIHVlOiB1ZV9jc20udWUsXG4gICAgICAgIHNldFRpbWVvdXQ6IHRpbWVvdXRXcmFwcGVyXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2RlIHdpdGhpbiBmdW5jdGlvbiBwdWxsZWQgZGlyZWN0bHkgZnJvbVxuICAgICAqIGh0dHBzOi8vY29kZS5hbWF6b24uY29tL3BhY2thZ2VzL1N1c2hpSmF2YVNjcmlwdENsaWVudC9ibG9icy9tYWlubGluZS8tLS9qYXZhc2NyaXB0L3N1c2hpLWNsaWVudC5qc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xpZW50Q29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGllbnRDb2RlKHVlX2NzbSwgd2luZG93KSB7XG4gICAgICB1ZV9jc20udWUuZXhlYyhmdW5jdGlvbiAoYiwgaykge1xuICAgICAgICBmdW5jdGlvbiBBKCkge1xuICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1thXTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGg7XG5cbiAgICAgICAgICAgICAgaWYgKGMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHQuYnVpbGRQYXlsb2FkKGwsIGUpO1xuICAgICAgICAgICAgICAgIGggPSBjLnNlbmQoSiwgYik7XG4gICAgICAgICAgICAgIH0gZWxzZSB0aHJvdyBkdW1teUV4Y2VwdGlvbjtcblxuICAgICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGQpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQih7XG4gICAgICAgICAgICBtOiBcIkFsbCBzdXBwb3J0ZWQgY2xpZW50cyBmYWlsZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uOiBcIkNTTVN1c2hpQ2xpZW50X1RSQU5TUE9SVEFUSU9OX0ZBSUxcIixcbiAgICAgICAgICAgIGY6IFwic3VzaGktY2xpZW50LmpzXCIsXG4gICAgICAgICAgICBsb2dMZXZlbDogXCJFUlJPUlwiXG4gICAgICAgICAgfSwgay51ZV9lcnJfY2hhbiB8fCBcImpzZXJyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbSgpIHtcbiAgICAgICAgICBpZiAoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbi5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICBuW2FdKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEEoZC5fc0JjbiB8fCB7fSwgZC5fYWp4IHx8IHt9KTtcbiAgICAgICAgICAgIGUgPSBbXTtcbiAgICAgICAgICAgIGYgPSB7fTtcbiAgICAgICAgICAgIGwgPSB7fTtcbiAgICAgICAgICAgIHUgPSB2ID0gcSA9IHcgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEsoKSB7XG4gICAgICAgICAgdmFyIGEgPSBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICBjID0gZnVuY3Rpb24gYyhhKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAgPiBhID8gXCIwXCIgKyBhIDogYTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nID8gYS50b0lTT1N0cmluZygpIDogYS5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgKyBjKGEuZ2V0VVRDTW9udGgoKSArIDEpICsgXCItXCIgKyBjKGEuZ2V0VVRDRGF0ZSgpKSArIFwiVFwiICsgYyhhLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgKyBjKGEuZ2V0VVRDTWludXRlcygpKSArIFwiOlwiICsgYyhhLmdldFVUQ1NlY29uZHMoKSkgKyBcIi5cIiArIFN0cmluZygoYS5nZXRVVENNaWxsaXNlY29uZHMoKSAvIDFFMykudG9GaXhlZCgzKSkuc2xpY2UoMiwgNSkgKyBcIlpcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHgoYSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSk7XG4gICAgICAgICAgfSBjYXRjaCAoYykge31cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQyhhLCBjLCBoLCBnKSB7XG4gICAgICAgICAgdmFyIHAgPSAhMTtcbiAgICAgICAgICBnID0gZyB8fCB7fTtcbiAgICAgICAgICByKys7XG4gICAgICAgICAgciA9PSBEICYmIEIoe1xuICAgICAgICAgICAgbTogXCJNYXggbnVtYmVyIG9mIFN1c2hpIExvZ3MgZXhjZWVkZWRcIixcbiAgICAgICAgICAgIGY6IFwic3VzaGktY2xpZW50LmpzXCIsXG4gICAgICAgICAgICBsb2dMZXZlbDogXCJFUlJPUlwiLFxuICAgICAgICAgICAgYXR0cmlidXRpb246IFwiQ1NNU3VzaGlDbGllbnRfTUFYX0NBTExTXCJcbiAgICAgICAgICB9LCBrLnVlX2Vycl9jaGFuIHx8IFwianNlcnJcIik7XG4gICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgaWYgKGYgPSAhKHIgPj0gRCkpIChmID0gYSAmJiAtMSA8IGEuY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKFwiT2JqZWN0XCIpICYmIGMgJiYgLTEgPCBjLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZihcIlN0cmluZ1wiKSAmJiBoICYmIC0xIDwgaC5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluZGV4T2YoXCJTdHJpbmdcIikpIHx8IEwrKztcbiAgICAgICAgICBmICYmIChkLmNvdW50ICYmIGQuY291bnQoXCJFdmVudDpcIiArIGgsIDEpLCBhLnByb2R1Y2VySWQgPSBhLnByb2R1Y2VySWQgfHwgYywgYS5zY2hlbWFJZCA9IGEuc2NoZW1hSWQgfHwgaCwgYS50aW1lc3RhbXAgPSBLKCksIGMgPSBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKSwgaCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiwgMTIpLCBhLm1lc3NhZ2VJZCA9IGIudWVfaWQgKyBcIi1cIiArIGMgKyBcIi1cIiArIGgsIGcgJiYgIWcuc3NkICYmIChhLnNlc3Npb25JZCA9IGEuc2Vzc2lvbklkIHx8IGIudWVfc2lkLCBhLnJlcXVlc3RJZCA9IGEucmVxdWVzdElkIHx8IGIudWVfaWQsIGEub2JmdXNjYXRlZE1hcmtldHBsYWNlSWQgPSBhLm9iZnVzY2F0ZWRNYXJrZXRwbGFjZUlkIHx8IGIudWVfbWlkKSwgKGMgPSB4KGEpKSA/IChjID0gYy5sZW5ndGgsIChlLmxlbmd0aCA9PSBNIHx8IHEgKyBjID4gTikgJiYgbSgpLCBxICs9IGMsIGEgPSB7XG4gICAgICAgICAgICBkYXRhOiB0LmNvbXByZXNzRXZlbnQoYSlcbiAgICAgICAgICB9LCBlLnB1c2goYSksIChnIHx8IHt9KS5uID8gMCA9PT0gRSA/IG0oKSA6IHUgfHwgKHUgPSBrLnNldFRpbWVvdXQobSwgRSkpIDogdiB8fCAodiA9IGsuc2V0VGltZW91dChtLCBPKSksIHAgPSAhMCkgOiBwID0gITEpO1xuICAgICAgICAgICFwICYmIGIudWVfaW50ICYmIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTIE5leHVzIEFQSSBjYWxsXCIpO1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gRigpIHtcbiAgICAgICAgICBpZiAoIUcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgeS5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICB5W2FdKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoYSA9IDA7IGEgPCBuLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgIG5bYV0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5sZW5ndGggJiYgKGIudWVfc2J1aW1wICYmIGIudWUgJiYgYi51ZS5zc3cgJiYgKGEgPSB4KHtcbiAgICAgICAgICAgICAgZGN0OiBsLFxuICAgICAgICAgICAgICBldnQ6IGVcbiAgICAgICAgICAgIH0pLCBiLnVlLnNzdyhcImVlbGRhdGFcIiwgYSksIGIudWUuc3N3KFwiZWVsc3RzXCIsIFwidW5rXCIpKSwgQShkLl9zQmNuIHx8IHt9KSk7XG4gICAgICAgICAgICBHID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gSChhKSB7XG4gICAgICAgICAgeS5wdXNoKGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gSShhKSB7XG4gICAgICAgICAgbi5wdXNoKGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEQgPSAxRTMsXG4gICAgICAgICAgICBNID0gNDk5LFxuICAgICAgICAgICAgTiA9IDUyNDI4OCxcbiAgICAgICAgICAgIHMgPSBmdW5jdGlvbiBzKCkge30sXG4gICAgICAgICAgICBkID0gYi51ZSB8fCB7fSxcbiAgICAgICAgICAgIEIgPSBkLmxvZyB8fCBzLFxuICAgICAgICAgICAgUCA9IGIudWV4IHx8IHM7XG5cbiAgICAgICAgKGIudWV0IHx8IHMpKFwiYmJcIiwgXCJ1ZV9zdXNoaV92MVwiLCB7XG4gICAgICAgICAgd2I6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIEogPSBiLnVlX3N1cmwgfHwgXCJodHRwczovL3VuYWdpLW5hLmFtYXpvbi5jb20vMS9ldmVudHMvY29tLmFtYXpvbi5jc20ubmV4dXNjbGllbnQuZ2FtbWFcIixcbiAgICAgICAgICAgIFEgPSBbXCJtZXNzYWdlSWRcIiwgXCJ0aW1lc3RhbXBcIl0sXG4gICAgICAgICAgICB6ID0gXCIjXCIsXG4gICAgICAgICAgICBlID0gW10sXG4gICAgICAgICAgICBmID0ge30sXG4gICAgICAgICAgICBsID0ge30sXG4gICAgICAgICAgICBxID0gMCxcbiAgICAgICAgICAgIHcgPSAwLFxuICAgICAgICAgICAgTCA9IDAsXG4gICAgICAgICAgICByID0gMCxcbiAgICAgICAgICAgIHkgPSBbXSxcbiAgICAgICAgICAgIG4gPSBbXSxcbiAgICAgICAgICAgIEcgPSAhMSxcbiAgICAgICAgICAgIHUsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgRSA9IHZvaWQgMCA9PT0gYi51ZV9ocHNpID8gMUUzIDogYi51ZV9ocHNpLFxuICAgICAgICAgICAgTyA9IHZvaWQgMCA9PT0gYi51ZV9scHNpID8gMUU0IDogYi51ZV9scHNpLFxuICAgICAgICAgICAgdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jdGlvbiBhKGEpIHtcbiAgICAgICAgICAgIGZbYV0gPSB6ICsgdysrO1xuICAgICAgICAgICAgbFtmW2FdXSA9IGE7XG4gICAgICAgICAgICByZXR1cm4gZlthXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjKGIpIHtcbiAgICAgICAgICAgIGlmICghKGIgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGcgPSBbXSwgZCA9IGIubGVuZ3RoLCBlID0gMDsgZSA8IGQ7IGUrKykge1xuICAgICAgICAgICAgICAgICAgZ1tlXSA9IGMoYltlXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGcgPSB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAoZCBpbiBiKSB7XG4gICAgICAgICAgICAgICAgICBiLmhhc093blByb3BlcnR5KGQpICYmIChnW2ZbZF0gPyBmW2RdIDogYShkKV0gPSAtMSA9PT0gUS5pbmRleE9mKGQpID8gYyhiW2RdKSA6IGJbZF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiBiICYmIChiLmxlbmd0aCA+ICh6ICsgdykubGVuZ3RoIHx8IGIuY2hhckF0KDApID09PSB6KSA/IGZbYl0gPyBmW2JdIDogYShiKSA6IGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbXByZXNzRXZlbnQ6IGMsXG4gICAgICAgICAgICBidWlsZFBheWxvYWQ6IGZ1bmN0aW9uIGJ1aWxkUGF5bG9hZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHgoe1xuICAgICAgICAgICAgICAgIGNzOiB7XG4gICAgICAgICAgICAgICAgICBkY3Q6IGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV2ZW50czogZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZC5ldmVudCAmJiBkLmV2ZW50LmlzU3R1Yikge1xuICAgICAgICAgICAgaWYgKGIudWVfc2J1aW1wICYmIGIudWUgJiYgYi51ZS5zc3cpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBiLnVlLnNzdyhcImVlbHN0c1wiKS52YWw7XG5cbiAgICAgICAgICAgICAgaWYgKGEgJiYgXCJ1bmtcIiA9PT0gYSAmJiAoYSA9IGIudWUuc3N3KFwiZWVsZGF0YVwiKS52YWwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGM7XG5cbiAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjID0gSlNPTi5wYXJzZShhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGYpIHt9XG5cbiAgICAgICAgICAgICAgICAgIGMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMgJiYgYy5ldnQgaW5zdGFuY2VvZiBBcnJheSAmJiBjLmRjdCBpbnN0YW5jZW9mIE9iamVjdCAmJiAoZSA9IGMuZXZ0LCBsID0gYy5kY3QsIGUgJiYgbCAmJiAobSgpLCBiLnVlLnNzdyhcImVlbGRhdGFcIiwgXCJ7fVwiKSwgYi51ZS5zc3coXCJlZWxzdHNcIiwgXCJzY3NcIikpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkLmV2ZW50LnJlcGxheShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBhWzNdID0gYVszXSB8fCB7fTtcbiAgICAgICAgICAgICAgYVszXS5uID0gMTtcbiAgICAgICAgICAgICAgQy5hcHBseSh0aGlzLCBhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZC5vblN1c2hpVW5sb2FkLnJlcGxheShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBIKGFbMF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkLm9uU3VzaGlGbHVzaC5yZXBsYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgSShhWzBdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcblxuICAgICAgICBkLmF0dGFjaChcImJlZm9yZXVubG9hZFwiLCBGKTtcbiAgICAgICAgZC5hdHRhY2goXCJwYWdlaGlkZVwiLCBGKTtcbiAgICAgICAgZC5fY21wcyA9IHQ7XG4gICAgICAgIGQuZXZlbnQgPSBDO1xuXG4gICAgICAgIGQuZXZlbnQucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgciA9IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgZC5vblN1c2hpVW5sb2FkID0gSDtcbiAgICAgICAgZC5vblN1c2hpRmx1c2ggPSBJO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgay5QICYmIGsuUC5yZWdpc3RlciAmJiBrLlAucmVnaXN0ZXIoXCJzdXNoaS1jbGllbnRcIiwgcyk7XG4gICAgICAgIH0gY2F0Y2ggKFIpIHtcbiAgICAgICAgICBiLnVlTG9nRXJyb3IoUiwge1xuICAgICAgICAgICAgbG9nTGV2ZWw6IFwiV0FSTlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBQKFwibGRcIiwgXCJ1ZV9zdXNoaV92MVwiLCB7XG4gICAgICAgICAgd2I6IDFcbiAgICAgICAgfSk7XG4gICAgICB9LCBcIk54cy1KUy1DbGllbnRcIikodWVfY3NtLCB3aW5kb3cpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIGlzIHB1bGxlZCBkaXJlY3RseSBmcm9tOlxuICAgICAqIGh0dHBzOi8vY29kZS5hbWF6b24uY29tL3BhY2thZ2VzL1N1c2hpSmF2YVNjcmlwdENsaWVudC9ibG9icy9tYWlubGluZS8tLS9qYXZhc2NyaXB0L3RyYW5zcG9ydGF0aW9uLWNsaWVudHMuanNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zcG9ydGF0aW9uQ2xpZW50Q29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc3BvcnRhdGlvbkNsaWVudENvZGUodWVfY3NtLCB3aW5kb3cpIHtcbiAgICAgIHVlX2NzbS51ZS5leGVjKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICAgIHZhciBlID0gZnVuY3Rpb24gZSgpIHt9LFxuICAgICAgICAgICAgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gc2VuZChiLCBkKSB7XG4gICAgICAgICAgICAgIGlmIChkICYmIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgICAgICBpZiAoYy5YRG9tYWluUmVxdWVzdCkgYSA9IG5ldyBYRG9tYWluUmVxdWVzdCgpLCBhLm9uZXJyb3IgPSBlLCBhLm9udGltZW91dCA9IGUsIGEub25wcm9ncmVzcyA9IGUsIGEub25sb2FkID0gZSwgYS50aW1lb3V0ID0gMDtlbHNlIGlmIChjLlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCAhKFwid2l0aENyZWRlbnRpYWxzXCIgaW4gYSkpIHRocm93IFwiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKCFhKSB0aHJvdyBcIlwiO1xuICAgICAgICAgICAgICAgIGEub3BlbihcIlBPU1RcIiwgYiwgITApO1xuICAgICAgICAgICAgICAgIGEuc2V0UmVxdWVzdEhlYWRlciAmJiBhLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICAgICAgICAgIGEuc2VuZChkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU3VwcG9ydGVkOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgIH0oKSxcbiAgICAgICAgICAgIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoYywgZCkge1xuICAgICAgICAgICAgICBpZiAoYyAmJiBkKSBpZiAobmF2aWdhdG9yLnNlbmRCZWFjb24oYywgZCkpIGIudWVfc2J1aW1wICYmIGIudWUgJiYgYi51ZS5zc3cgJiYgYi51ZS5zc3coXCJlZWxzdHNcIiwgXCJzY3NcIik7ZWxzZSB0aHJvdyBcIlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU3VwcG9ydGVkOiAhIW5hdmlnYXRvci5zZW5kQmVhY29uICYmICEoYy5jb3Jkb3ZhICYmIGMuY29yZG92YS5wbGF0Zm9ybUlkICYmIFwiaW9zXCIgPT0gYy5jb3Jkb3ZhLnBsYXRmb3JtSWQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuXG4gICAgICAgIGIudWUuX2FqeCA9IGY7XG4gICAgICAgIGIudWUuX3NCY24gPSBnO1xuICAgICAgfSwgXCJUcmFuc3BvcnRhdGlvbi1jbGllbnRzXCIpKHVlX2NzbSwgd2luZG93KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN1c2hpQ2xpZW50O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdXNoaUNsaWVudDsiLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgc3VwZXJQcm9wQmFzZSA9IHJlcXVpcmUoXCIuL3N1cGVyUHJvcEJhc2UuanNcIik7XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0cztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpW1wiZGVmYXVsdFwiXTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkge1xuICAgIHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDtcbiAgfSkobm9kZUludGVyb3ApO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7XG4gIGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7XG5cbiAgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChvYmopO1xuICB9XG5cbiAgdmFyIG5ld09iaiA9IHt9O1xuICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4vZGVmaW5lUHJvcGVydHkuanNcIik7XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gT2JqZWN0KGFyZ3VtZW50c1tpXSkgOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMucHVzaC5hcHBseShvd25LZXlzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RTcHJlYWQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgc3VwZXJQcm9wQmFzZSA9IHJlcXVpcmUoXCIuL3N1cGVyUHJvcEJhc2UuanNcIik7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL2RlZmluZVByb3BlcnR5LmpzXCIpO1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LnNldCkge1xuICAgIHNldCA9IFJlZmxlY3Quc2V0O1xuICB9IGVsc2Uge1xuICAgIHNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIHZhciBkZXNjO1xuXG4gICAgICBpZiAoYmFzZSkge1xuICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgZGVzYy5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2MudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTtcbn1cblxuZnVuY3Rpb24gX3NldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIsIGlzU3RyaWN0KSB7XG4gIHZhciBzID0gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciB8fCB0YXJnZXQpO1xuXG4gIGlmICghcyAmJiBpc1N0cmljdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZi5qc1wiKTtcblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zdXBlclByb3BCYXNlO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdlcnJvci1zdGFjay1wYXJzZXInLCBbJ3N0YWNrZnJhbWUnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3N0YWNrZnJhbWUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5FcnJvclN0YWNrUGFyc2VyID0gZmFjdG9yeShyb290LlN0YWNrRnJhbWUpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlcihTdGFja0ZyYW1lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCA9IC8oXnxAKVxcUys6XFxkKy87XG4gICAgdmFyIENIUk9NRV9JRV9TVEFDS19SRUdFWFAgPSAvXlxccyphdCAuKihcXFMrOlxcZCt8XFwobmF0aXZlXFwpKS9tO1xuICAgIHZhciBTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQID0gL14oZXZhbEApPyhcXFtuYXRpdmUgY29kZV0pPyQvO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgZXh0cmFjdCB0aGUgbW9zdCBpbmZvcm1hdGlvbiBmcm9tIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IG9mIFN0YWNrRnJhbWVzXG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2UoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3Iuc3RhY2t0cmFjZSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGVycm9yWydvcGVyYSNzb3VyY2Vsb2MnXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhY2sgJiYgZXJyb3Iuc3RhY2subWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVY4T3JJRShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGRk9yU2FmYXJpKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgZ2l2ZW4gRXJyb3Igb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU2VwYXJhdGUgbGluZSBhbmQgY29sdW1uIG51bWJlcnMgZnJvbSBhIHN0cmluZyBvZiB0aGUgZm9ybTogKFVSSTpMaW5lOkNvbHVtbilcbiAgICAgICAgZXh0cmFjdExvY2F0aW9uOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRleHRyYWN0TG9jYXRpb24odXJsTGlrZSkge1xuICAgICAgICAgICAgLy8gRmFpbC1mYXN0IGJ1dCByZXR1cm4gbG9jYXRpb25zIGxpa2UgXCIobmF0aXZlKVwiXG4gICAgICAgICAgICBpZiAodXJsTGlrZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1cmxMaWtlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlZ0V4cCA9IC8oLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvO1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gcmVnRXhwLmV4ZWModXJsTGlrZS5yZXBsYWNlKC9bKCldL2csICcnKSk7XG4gICAgICAgICAgICByZXR1cm4gW3BhcnRzWzFdLCBwYXJ0c1syXSB8fCB1bmRlZmluZWQsIHBhcnRzWzNdIHx8IHVuZGVmaW5lZF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VWOE9ySUU6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlVjhPcklFKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFsaW5lLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyhldmFsICcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBldmFsIGluZm9ybWF0aW9uIHVudGlsIHdlIGltcGxlbWVudCBzdGFja3RyYWNlLmpzL3N0YWNrZnJhbWUjOFxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9ldmFsIGNvZGUvZywgJ2V2YWwnKS5yZXBsYWNlKC8oXFwoZXZhbCBhdCBbXigpXSopfChcXCksLiokKS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXChldmFsIGNvZGUvZywgJygnKTtcblxuICAgICAgICAgICAgICAgIC8vIGNhcHR1cmUgYW5kIHByZXNldmUgdGhlIHBhcmVudGhlc2l6ZWQgbG9jYXRpb24gXCIoL2Zvby9teSBiYXIuanM6MTI6ODcpXCIgaW5cbiAgICAgICAgICAgICAgICAvLyBjYXNlIGl0IGhhcyBzcGFjZXMgaW4gaXQsIGFzIHRoZSBzdHJpbmcgaXMgc3BsaXQgb24gXFxzKyBsYXRlciBvblxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHNhbml0aXplZExpbmUubWF0Y2goLyAoXFwoKC4rKTooXFxkKyk6KFxcZCspXFwpJCkvKTtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBmcm9tIHRoZSBsaW5lLCBpZiBpdCB3YXMgbWF0Y2hlZFxuICAgICAgICAgICAgICAgIHNhbml0aXplZExpbmUgPSBsb2NhdGlvbiA/IHNhbml0aXplZExpbmUucmVwbGFjZShsb2NhdGlvblswXSwgJycpIDogc2FuaXRpemVkTGluZTtcblxuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBzYW5pdGl6ZWRMaW5lLnNwbGl0KC9cXHMrLykuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgYSBsb2NhdGlvbiB3YXMgbWF0Y2hlZCwgcGFzcyBpdCB0byBleHRyYWN0TG9jYXRpb24oKSBvdGhlcndpc2UgcG9wIHRoZSBsYXN0IHRva2VuXG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsb2NhdGlvbiA/IGxvY2F0aW9uWzFdIDogdG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdG9rZW5zLmpvaW4oJyAnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gWydldmFsJywgJzxhbm9ueW1vdXM+J10uaW5kZXhPZihsb2NhdGlvblBhcnRzWzBdKSA+IC0xID8gdW5kZWZpbmVkIDogbG9jYXRpb25QYXJ0c1swXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZUZGT3JTYWZhcmk6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlRkZPclNhZmFyaShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFsaW5lLm1hdGNoKFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFApO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcgPiBldmFsJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbDpcXGQrOlxcZCsvZywgJzokMScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJ0AnKSA9PT0gLTEgJiYgbGluZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBldmFsIGZyYW1lcyBvbmx5IGhhdmUgZnVuY3Rpb24gbmFtZXMgYW5kIG5vdGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWVSZWdleCA9IC8oKC4qXCIuK1wiW15AXSopP1teQF0qKSg/OkApLztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBsaW5lLm1hdGNoKGZ1bmN0aW9uTmFtZVJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1sxXSA/IG1hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24obGluZS5yZXBsYWNlKGZ1bmN0aW9uTmFtZVJlZ2V4LCAnJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBsb2NhdGlvblBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhKGUpIHtcbiAgICAgICAgICAgIGlmICghZS5zdGFja3RyYWNlIHx8IChlLm1lc3NhZ2UuaW5kZXhPZignXFxuJykgPiAtMSAmJlxuICAgICAgICAgICAgICAgIGUubWVzc2FnZS5zcGxpdCgnXFxuJykubGVuZ3RoID4gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTkoZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFlLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTEwKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTEoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTk6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmE5KGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKS9pO1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gZS5tZXNzYWdlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhMTA6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmExMChlKSB7XG4gICAgICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykoPzo6IEluIGZ1bmN0aW9uIChcXFMrKSk/JC9pO1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IG1hdGNoWzNdIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3BlcmEgMTAuNjUrIEVycm9yLnN0YWNrIHZlcnkgc2ltaWxhciB0byBGRi9TYWZhcmlcbiAgICAgICAgcGFyc2VPcGVyYTExOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTEoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQKSAmJiAhbGluZS5tYXRjaCgvXkVycm9yIGNyZWF0ZWQgYXQvKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5zcGxpdCgnQCcpO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24odG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25DYWxsID0gKHRva2Vucy5zaGlmdCgpIHx8ICcnKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25DYWxsXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88YW5vbnltb3VzIGZ1bmN0aW9uKDogKFxcdyspKT8+LywgJyQyJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKFteKV0qXFwpL2csICcnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3NSYXc7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5tYXRjaCgvXFwoKFteKV0qKVxcKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NSYXcgPSBmdW5jdGlvbkNhbGwucmVwbGFjZSgvXlteKF0rXFwoKFteKV0qKVxcKSQvLCAnJDEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSAoYXJnc1JhdyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3NSYXcgPT09ICdbYXJndW1lbnRzIG5vdCBhdmFpbGFibGVdJykgP1xuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOiBhcmdzUmF3LnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG59KSk7XG4iLCIvKipcbiAqIEB0aGlzIHtQcm9taXNlfVxuICovXG5mdW5jdGlvbiBmaW5hbGx5Q29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmaW5hbGx5Q29uc3RydWN0b3I7XG4iLCJpbXBvcnQgcHJvbWlzZUZpbmFsbHkgZnJvbSAnLi9maW5hbGx5JztcblxuLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gcHJvbWlzZS1wb2x5ZmlsbCB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbi8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxudmFyIHNldFRpbWVvdXRGdW5jID0gc2V0VGltZW91dDtcblxuZnVuY3Rpb24gaXNBcnJheSh4KSB7XG4gIHJldHVybiBCb29sZWFuKHggJiYgdHlwZW9mIHgubGVuZ3RoICE9PSAndW5kZWZpbmVkJyk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vLyBQb2x5ZmlsbCBmb3IgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbmZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBQcm9taXNlKGZuKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKTtcbiAgLyoqIEB0eXBlIHshbnVtYmVyfSAqL1xuICB0aGlzLl9zdGF0ZSA9IDA7XG4gIC8qKiBAdHlwZSB7IWJvb2xlYW59ICovXG4gIHRoaXMuX2hhbmRsZWQgPSBmYWxzZTtcbiAgLyoqIEB0eXBlIHtQcm9taXNlfHVuZGVmaW5lZH0gKi9cbiAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gIC8qKiBAdHlwZSB7IUFycmF5PCFGdW5jdGlvbj59ICovXG4gIHRoaXMuX2RlZmVycmVkcyA9IFtdO1xuXG4gIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZShzZWxmLCBkZWZlcnJlZCkge1xuICB3aGlsZSAoc2VsZi5fc3RhdGUgPT09IDMpIHtcbiAgICBzZWxmID0gc2VsZi5fdmFsdWU7XG4gIH1cbiAgaWYgKHNlbGYuX3N0YXRlID09PSAwKSB7XG4gICAgc2VsZi5fZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICBzZWxmLl9oYW5kbGVkID0gdHJ1ZTtcbiAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNiID0gc2VsZi5fc3RhdGUgPT09IDEgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWQ7XG4gICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAoc2VsZi5fc3RhdGUgPT09IDEgPyByZXNvbHZlIDogcmVqZWN0KShkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl92YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHJldCA9IGNiKHNlbGYuX3ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgcmV0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoc2VsZiwgbmV3VmFsdWUpIHtcbiAgdHJ5IHtcbiAgICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICAgIGlmIChuZXdWYWx1ZSA9PT0gc2VsZilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgaWYgKFxuICAgICAgbmV3VmFsdWUgJiZcbiAgICAgICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICApIHtcbiAgICAgIHZhciB0aGVuID0gbmV3VmFsdWUudGhlbjtcbiAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgc2VsZi5fc3RhdGUgPSAzO1xuICAgICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICBmaW5hbGUoc2VsZik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZG9SZXNvbHZlKGJpbmQodGhlbiwgbmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLl9zdGF0ZSA9IDE7XG4gICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBmaW5hbGUoc2VsZik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3Qoc2VsZiwgZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHNlbGYsIG5ld1ZhbHVlKSB7XG4gIHNlbGYuX3N0YXRlID0gMjtcbiAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgZmluYWxlKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICBpZiAoc2VsZi5fc3RhdGUgPT09IDIgJiYgc2VsZi5fZGVmZXJyZWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFzZWxmLl9oYW5kbGVkKSB7XG4gICAgICAgIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuKHNlbGYuX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBoYW5kbGUoc2VsZiwgc2VsZi5fZGVmZXJyZWRzW2ldKTtcbiAgfVxuICBzZWxmLl9kZWZlcnJlZHMgPSBudWxsO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9taXNlKSB7XG4gIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG59XG5cbi8qKlxuICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiAqL1xuZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBzZWxmKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgZm4oXG4gICAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZShzZWxmLCB2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZWplY3Qoc2VsZiwgcmVhc29uKTtcbiAgICAgIH1cbiAgICApO1xuICB9IGNhdGNoIChleCkge1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHNlbGYsIGV4KTtcbiAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHZhciBwcm9tID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaGFuZGxlKHRoaXMsIG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9tKSk7XG4gIHJldHVybiBwcm9tO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGVbJ2ZpbmFsbHknXSA9IHByb21pc2VGaW5hbGx5O1xuXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uKGFycikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFpc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignUHJvbWlzZS5hbGwgYWNjZXB0cyBhbiBhcnJheScpKTtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJlamVjdChleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgfVxuICB9KTtcbn07XG5cblByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBQcm9taXNlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uKGFycikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFpc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignUHJvbWlzZS5yYWNlIGFjY2VwdHMgYW4gYXJyYXknKSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKGFycltpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBVc2UgcG9seWZpbGwgZm9yIHNldEltbWVkaWF0ZSBmb3IgcGVyZm9ybWFuY2UgZ2FpbnNcblByb21pc2UuX2ltbWVkaWF0ZUZuID1cbiAgLy8gQHRzLWlnbm9yZVxuICAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH0pIHx8XG4gIGZ1bmN0aW9uKGZuKSB7XG4gICAgc2V0VGltZW91dEZ1bmMoZm4sIDApO1xuICB9O1xuXG5Qcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF91bmhhbmRsZWRSZWplY3Rpb25GbihlcnIpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlKSB7XG4gICAgY29uc29sZS53YXJuKCdQb3NzaWJsZSBVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246JywgZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFByb21pc2U7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gIH1cbiAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgfVxufTtcblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICByZXR1cm4gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgaWYgKGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cikpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4vLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbi8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4vL1xuLy8gICBDb250aW51YXRpb25cbi8vICAgfCAgICBTaWduXG4vLyAgIHwgICAgfFxuLy8gICBWICAgIFZcbi8vICAgMTAxMDExXG5cbnZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4vLyBiaW5hcnk6IDAxMTExMVxudmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovXG5mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovXG5mdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICA/IC1zaGlmdGVkXG4gICAgOiBzaGlmdGVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICB2YXIgZGlnaXQ7XG5cbiAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICBpZiAodmxxID4gMCkge1xuICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICB9XG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgZG8ge1xuICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4vKipcbiAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgfVxuXG4gIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gIH1cblxuICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gIH1cblxuICAvLyA2MjogK1xuICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgIHJldHVybiA2MjtcbiAgfVxuXG4gIC8vIDYzOiAvXG4gIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgIHJldHVybiA2MztcbiAgfVxuXG4gIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICByZXR1cm4gLTE7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG5leHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbmV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICpcbiAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAvL1xuICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAvL1xuICAvLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIGluZGV4IG9mXG4gIC8vICAgICAgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50LlxuICAvL1xuICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAvLyAgICAgIGVsZW1lbnQgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZSByZXR1cm4gLTEuXG4gIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICB2YXIgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICBpZiAoY21wID09PSAwKSB7XG4gICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIHJldHVybiBtaWQ7XG4gIH1cbiAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgZ3JlYXRlciB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIGFIaWdoIDwgYUhheXN0YWNrLmxlbmd0aCA/IGFIaWdoIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgbGVzcyB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csIG1pZCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAqIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gKiBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3MganVzdCBtZWFuc1xuICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICpcbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKi9cbmV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIGlmIChhSGF5c3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gcmVjdXJzaXZlU2VhcmNoKC0xLCBhSGF5c3RhY2subGVuZ3RoLCBhTmVlZGxlLCBhSGF5c3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29tcGFyZSwgYUJpYXMgfHwgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBXZSBoYXZlIGZvdW5kIGVpdGhlciB0aGUgZXhhY3QgZWxlbWVudCwgb3IgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50IHRoYW5cbiAgLy8gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci4gSG93ZXZlciwgdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgc3VjaFxuICAvLyBlbGVtZW50LiBNYWtlIHN1cmUgd2UgYWx3YXlzIHJldHVybiB0aGUgc21hbGxlc3Qgb2YgdGhlc2UuXG4gIHdoaWxlIChpbmRleCAtIDEgPj0gMCkge1xuICAgIGlmIChhQ29tcGFyZShhSGF5c3RhY2tbaW5kZXhdLCBhSGF5c3RhY2tbaW5kZXggLSAxXSwgdHJ1ZSkgIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAtLWluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gIHZhciB0ZW1wID0gYXJ5W3hdO1xuICBhcnlbeF0gPSBhcnlbeV07XG4gIGFyeVt5XSA9IHRlbXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG59XG5cbi8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gIGlmIChwIDwgcikge1xuICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgdmFyIGkgPSBwIC0gMTtcblxuICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAvLyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cbmV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhuZWVkbGUuc291cmNlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG5lZWRsZS5zb3VyY2UpO1xuXG4gICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBzb3VyY2VzID0gc291cmNlc1xuICAgIC5tYXAoU3RyaW5nKVxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xuICAgIH0pO1xuXG4gIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLm1hcChTdHJpbmcpLCB0cnVlKTtcbiAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG59XG5cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ICE9IG51bGwgPyB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzKSA6IHM7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgIH1cblxuICAgIHZhciB1cmw7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VzLmluZGV4T2YodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIHNvdXJjZVJvb3Q6IEEgcm9vdCBmb3IgYWxsIHJlbGF0aXZlIFVSTHMgaW4gdGhpcyBzb3VyY2UgbWFwLlxuICovXG5mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgaWYgKCFhQXJncykge1xuICAgIGFBcmdzID0ge307XG4gIH1cbiAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xufVxuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9O1xuXG4vKipcbiAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuXG4gICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSBTdHJpbmcoc291cmNlKTtcbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICBpZiAoIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwcGluZ3MuYWRkKHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChhU291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgdmFyIHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICdvciB0aGUgc291cmNlIG1hcFxcJ3MgXCJmaWxlXCIgcHJvcGVydHkuIEJvdGggd2VyZSBvbWl0dGVkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZUZpbGUgPSBhU291cmNlTWFwQ29uc3VtZXIuZmlsZTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIC8vIE1ha2UgXCJzb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICB9XG4gICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgIHRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhbmV3U291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICpcbiAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICogICAgICB0b2tlbi5cbiAqXG4gKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbi8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuLyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1xuU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXksIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUNvbnRlbnRzID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKTtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgIHZhciBuZXdMaW5lID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG4gICAgfTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgaWYgKHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgfVxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG5cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChhQ2h1bmspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gIHZhciBjaHVuaztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgdmFyIG5ld0NoaWxkcmVuO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuID4gMCkge1xuICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBzdHIgKz0gY2h1bms7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gKiBtYXAuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xufTtcblxuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFOYW1lICsgJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7XG4gIH1cbn1cbmV4cG9ydHMuZ2V0QXJnID0gZ2V0QXJnO1xuXG52YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgISFhUGF0aC5tYXRjaCh1cmxSZWdleHApO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyA9IGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zO1xuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG5mdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2stZ2VuZXJhdG9yJywgWydzdGFja2ZyYW1lJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdzdGFja2ZyYW1lJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tHZW5lcmF0b3IgPSBmYWN0b3J5KHJvb3QuU3RhY2tGcmFtZSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbihTdGFja0ZyYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFja3RyYWNlOiBmdW5jdGlvbiBTdGFja0dlbmVyYXRvciQkYmFja3RyYWNlKG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICAgICAgdmFyIG1heFN0YWNrU2l6ZSA9IDEwO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRzLm1heFN0YWNrU2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBtYXhTdGFja1NpemUgPSBvcHRzLm1heFN0YWNrU2l6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnIgPSBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnIgJiYgc3RhY2subGVuZ3RoIDwgbWF4U3RhY2tTaXplICYmIGN1cnJbJ2FyZ3VtZW50cyddKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgVjggb3B0aW1pemF0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGN1cnJbJ2FyZ3VtZW50cyddLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBjdXJyWydhcmd1bWVudHMnXVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9mdW5jdGlvbig/OlxccysoW1xcdyRdKykpK1xccypcXCgvLnRlc3QoY3Vyci50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0ZyYW1lKHtmdW5jdGlvbk5hbWU6IFJlZ0V4cC4kMSB8fCB1bmRlZmluZWQsIGFyZ3M6IGFyZ3N9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXcgU3RhY2tGcmFtZSh7YXJnczogYXJnc30pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3Vyci5jYWxsZXI7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgIH1cbiAgICB9O1xufSkpO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2tmcmFtZScsIFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlN0YWNrRnJhbWUgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gX2lzTnVtYmVyKG4pIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldHRlcihwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3BdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBib29sZWFuUHJvcHMgPSBbJ2lzQ29uc3RydWN0b3InLCAnaXNFdmFsJywgJ2lzTmF0aXZlJywgJ2lzVG9wbGV2ZWwnXTtcbiAgICB2YXIgbnVtZXJpY1Byb3BzID0gWydjb2x1bW5OdW1iZXInLCAnbGluZU51bWJlciddO1xuICAgIHZhciBzdHJpbmdQcm9wcyA9IFsnZmlsZU5hbWUnLCAnZnVuY3Rpb25OYW1lJywgJ3NvdXJjZSddO1xuICAgIHZhciBhcnJheVByb3BzID0gWydhcmdzJ107XG4gICAgdmFyIG9iamVjdFByb3BzID0gWydldmFsT3JpZ2luJ107XG5cbiAgICB2YXIgcHJvcHMgPSBib29sZWFuUHJvcHMuY29uY2F0KG51bWVyaWNQcm9wcywgc3RyaW5nUHJvcHMsIGFycmF5UHJvcHMsIG9iamVjdFByb3BzKTtcblxuICAgIGZ1bmN0aW9uIFN0YWNrRnJhbWUob2JqKSB7XG4gICAgICAgIGlmICghb2JqKSByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvYmpbcHJvcHNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzWydzZXQnICsgX2NhcGl0YWxpemUocHJvcHNbaV0pXShvYmpbcHJvcHNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlID0ge1xuICAgICAgICBnZXRBcmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEFyZ3M6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmdzIG11c3QgYmUgYW4gQXJyYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXJncyA9IHY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RXZhbE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmFsT3JpZ2luO1xuICAgICAgICB9LFxuICAgICAgICBzZXRFdmFsT3JpZ2luOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIFN0YWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSB2O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsT3JpZ2luID0gbmV3IFN0YWNrRnJhbWUodik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V2YWwgT3JpZ2luIG11c3QgYmUgYW4gT2JqZWN0IG9yIFN0YWNrRnJhbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHRoaXMuZ2V0TGluZU51bWJlcigpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKSB8fCAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmdldElzRXZhbCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW2V2YWxdICgnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyICsgJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tldmFsXTonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICsgJyAoJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlciArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3RhY2tGcmFtZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gU3RhY2tGcmFtZSQkZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIGFyZ3NTdGFydEluZGV4ID0gc3RyLmluZGV4T2YoJygnKTtcbiAgICAgICAgdmFyIGFyZ3NFbmRJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignKScpO1xuXG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBzdHIuc3Vic3RyaW5nKDAsIGFyZ3NTdGFydEluZGV4KTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzdHIuc3Vic3RyaW5nKGFyZ3NTdGFydEluZGV4ICsgMSwgYXJnc0VuZEluZGV4KS5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgbG9jYXRpb25TdHJpbmcgPSBzdHIuc3Vic3RyaW5nKGFyZ3NFbmRJbmRleCArIDEpO1xuXG4gICAgICAgIGlmIChsb2NhdGlvblN0cmluZy5pbmRleE9mKCdAJykgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IC9AKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLy5leGVjKGxvY2F0aW9uU3RyaW5nLCAnJyk7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gcGFydHNbMl07XG4gICAgICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gcGFydHNbM107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBjb2x1bW5OdW1iZXIgfHwgdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xlYW5Qcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gX2dldHRlcihib29sZWFuUHJvcHNbaV0pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IEJvb2xlYW4odik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShib29sZWFuUHJvcHNbaV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtZXJpY1Byb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUobnVtZXJpY1Byb3BzW2pdKV0gPSBfZ2V0dGVyKG51bWVyaWNQcm9wc1tqXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUobnVtZXJpY1Byb3BzW2pdKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pc051bWJlcih2KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHAgKyAnIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IE51bWJlcih2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKG51bWVyaWNQcm9wc1tqXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJpbmdQcm9wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSBfZ2V0dGVyKHN0cmluZ1Byb3BzW2tdKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShzdHJpbmdQcm9wc1trXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IFN0cmluZyh2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHN0cmluZ1Byb3BzW2tdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RhY2tGcmFtZTtcbn0pKTtcbiIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3N0YWNrdHJhY2UtZ3BzJywgWydzb3VyY2UtbWFwJywgJ3N0YWNrZnJhbWUnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKSwgcmVxdWlyZSgnc3RhY2tmcmFtZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlN0YWNrVHJhY2VHUFMgPSBmYWN0b3J5KHJvb3QuU291cmNlTWFwIHx8IHJvb3Quc291cmNlTWFwLCByb290LlN0YWNrRnJhbWUpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24oU291cmNlTWFwLCBTdGFja0ZyYW1lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIFgtRG9tYWluIHJlcXVlc3QgdG8gdXJsIGFuZCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gd2l0aCByZXNwb25zZSB0ZXh0IGlmIGZ1bGZpbGxlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF94ZHIodXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcS5vcGVuKCdnZXQnLCB1cmwpO1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gb25yZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHJlcS5zdGF0dXMgPj0gMjAwICYmIHJlcS5zdGF0dXMgPCAzMDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodXJsLnN1YnN0cigwLCA3KSA9PT0gJ2ZpbGU6Ly8nICYmIHJlcS5yZXNwb25zZVRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSFRUUCBzdGF0dXM6ICcgKyByZXEuc3RhdHVzICsgJyByZXRyaWV2aW5nICcgKyB1cmwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEuc2VuZCgpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgaW50byBpdHMgb3JpZ2luYWwgcmVwcmVzZW50YXRpb24uXG4gICAgICogVXNlZCBmb3IgaW5saW5lIHNvdXJjZW1hcHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYjY0c3RyIEJhc2UtNjQgZW5jb2RlZCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBvcmlnaW5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9hdG9iKGI2NHN0cikge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmF0b2IpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuYXRvYihiNjRzdHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYSBwb2x5ZmlsbCBmb3Igd2luZG93LmF0b2IgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3BhcnNlSnNvbihzdHJpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyAmJiBKU09OLnBhcnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYSBwb2x5ZmlsbCBmb3IgSlNPTi5wYXJzZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmluZEZ1bmN0aW9uTmFtZShzb3VyY2UsIGxpbmVOdW1iZXIvKiwgY29sdW1uTnVtYmVyKi8pIHtcbiAgICAgICAgdmFyIHN5bnRheGVzID0gW1xuICAgICAgICAgICAgLy8ge25hbWV9ID0gZnVuY3Rpb24gKHthcmdzfSkgVE9ETyBhcmdzIGNhcHR1cmVcbiAgICAgICAgICAgIC9bJ1wiXT8oWyRfQS1aYS16XVskX0EtWmEtejAtOV0qKVsnXCJdP1xccypbOj1dXFxzKmZ1bmN0aW9uXFxiLyxcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHtuYW1lfSh7YXJnc30pIG1bMV09bmFtZSBtWzJdPWFyZ3NcbiAgICAgICAgICAgIC9mdW5jdGlvblxccysoW14oJ1wiYF0qPylcXHMqXFwoKFteKV0qKVxcKS8sXG4gICAgICAgICAgICAvLyB7bmFtZX0gPSBldmFsKClcbiAgICAgICAgICAgIC9bJ1wiXT8oWyRfQS1aYS16XVskX0EtWmEtejAtOV0qKVsnXCJdP1xccypbOj1dXFxzKig/OmV2YWx8bmV3IEZ1bmN0aW9uKVxcYi8sXG4gICAgICAgICAgICAvLyBmbl9uYW1lKCkge1xuICAgICAgICAgICAgL1xcYig/ISg/OmlmfGZvcnxzd2l0Y2h8d2hpbGV8d2l0aHxjYXRjaClcXGIpKD86KD86c3RhdGljKVxccyspPyhcXFMrKVxccypcXCguKj9cXClcXHMqXFx7LyxcbiAgICAgICAgICAgIC8vIHtuYW1lfSA9ICgpID0+IHtcbiAgICAgICAgICAgIC9bJ1wiXT8oWyRfQS1aYS16XVskX0EtWmEtejAtOV0qKVsnXCJdP1xccypbOj1dXFxzKlxcKC4qP1xcKVxccyo9Pi9cbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAvLyBXYWxrIGJhY2t3YXJkcyBpbiB0aGUgc291cmNlIGxpbmVzIHVudGlsIHdlIGZpbmQgdGhlIGxpbmUgd2hpY2ggbWF0Y2hlcyBvbmUgb2YgdGhlIHBhdHRlcm5zIGFib3ZlXG4gICAgICAgIHZhciBjb2RlID0gJyc7XG4gICAgICAgIHZhciBtYXhMaW5lcyA9IE1hdGgubWluKGxpbmVOdW1iZXIsIDIwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhMaW5lczsgKytpKSB7XG4gICAgICAgICAgICAvLyBsaW5lTm8gaXMgMS1iYXNlZCwgc291cmNlW10gaXMgMC1iYXNlZFxuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsaW5lTnVtYmVyIC0gaSAtIDFdO1xuICAgICAgICAgICAgdmFyIGNvbW1lbnRQb3MgPSBsaW5lLmluZGV4T2YoJy8vJyk7XG4gICAgICAgICAgICBpZiAoY29tbWVudFBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGNvbW1lbnRQb3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBsaW5lICsgY29kZTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gc3ludGF4ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBzeW50YXhlc1tpbmRleF0uZXhlYyhjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZW5zdXJlU3VwcG9ydGVkRW52aXJvbm1lbnQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjb25zdW1lIHNvdXJjZSBtYXBzIGluIG9sZGVyIGJyb3dzZXJzJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZW5zdXJlU3RhY2tGcmFtZUlzTGVnaXQoc3RhY2tmcmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrZnJhbWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHaXZlbiBTdGFja0ZyYW1lIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhY2tmcmFtZS5maWxlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dpdmVuIGZpbGUgbmFtZSBpcyBub3QgYSBTdHJpbmcnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhY2tmcmFtZS5saW5lTnVtYmVyICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgc3RhY2tmcmFtZS5saW5lTnVtYmVyICUgMSAhPT0gMCB8fFxuICAgICAgICAgICAgc3RhY2tmcmFtZS5saW5lTnVtYmVyIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2l2ZW4gbGluZSBudW1iZXIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhY2tmcmFtZS5jb2x1bW5OdW1iZXIgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBzdGFja2ZyYW1lLmNvbHVtbk51bWJlciAlIDEgIT09IDAgfHxcbiAgICAgICAgICAgIHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2l2ZW4gY29sdW1uIG51bWJlciBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmluZFNvdXJjZU1hcHBpbmdVUkwoc291cmNlKSB7XG4gICAgICAgIHZhciBzb3VyY2VNYXBwaW5nVXJsUmVnRXhwID0gL1xcL1xcL1sjQF0gP3NvdXJjZU1hcHBpbmdVUkw9KFteXFxzJ1wiXSspXFxzKiQvbWc7XG4gICAgICAgIHZhciBsYXN0U291cmNlTWFwcGluZ1VybDtcbiAgICAgICAgdmFyIG1hdGNoU291cmNlTWFwcGluZ1VybDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgIHdoaWxlIChtYXRjaFNvdXJjZU1hcHBpbmdVcmwgPSBzb3VyY2VNYXBwaW5nVXJsUmVnRXhwLmV4ZWMoc291cmNlKSkge1xuICAgICAgICAgICAgbGFzdFNvdXJjZU1hcHBpbmdVcmwgPSBtYXRjaFNvdXJjZU1hcHBpbmdVcmxbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RTb3VyY2VNYXBwaW5nVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFNvdXJjZU1hcHBpbmdVcmw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZU1hcHBpbmdVUkwgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZXh0cmFjdExvY2F0aW9uSW5mb0Zyb21Tb3VyY2VNYXBTb3VyY2Uoc3RhY2tmcmFtZSwgc291cmNlTWFwQ29uc3VtZXIsIHNvdXJjZUNhY2hlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBzb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFja2ZyYW1lLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFja2ZyYW1lLmNvbHVtbk51bWJlclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChsb2Muc291cmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FjaGUgbWFwcGVkIHNvdXJjZXNcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGVkU291cmNlID0gc291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihsb2Muc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUNhY2hlW2xvYy5zb3VyY2VdID0gbWFwcGVkU291cmNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgIC8vIGdpdmVuIHN0YWNrZnJhbWUgYW5kIHNvdXJjZSBsb2NhdGlvbiwgdXBkYXRlIHN0YWNrZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBsb2MubmFtZSB8fCBzdGFja2ZyYW1lLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHN0YWNrZnJhbWUuYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBsb2Muc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvYy5jb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IG9yaWdpbmFsIHNvdXJjZSBmb3IgZ2l2ZW4gc3RhY2tmcmFtZSBhbmQgc291cmNlIG1hcCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiAgICAgIG9wdHMuc291cmNlQ2FjaGUgPSB7dXJsOiBcIlNvdXJjZSBTdHJpbmdcIn0gPT4gcHJlbG9hZCBzb3VyY2UgY2FjaGVcbiAgICAgKiAgICAgIG9wdHMuc291cmNlTWFwQ29uc3VtZXJDYWNoZSA9IHsvcGF0aC9maWxlLmpzLm1hcDogU291cmNlTWFwQ29uc3VtZXJ9XG4gICAgICogICAgICBvcHRzLm9mZmxpbmUgPSBUcnVlIHRvIHByZXZlbnQgbmV0d29yayByZXF1ZXN0cy5cbiAgICAgKiAgICAgICAgICAgICAgQmVzdCBlZmZvcnQgd2l0aG91dCBzb3VyY2VzIG9yIHNvdXJjZSBtYXBzLlxuICAgICAqICAgICAgb3B0cy5hamF4ID0gUHJvbWlzZSByZXR1cm5pbmcgZnVuY3Rpb24gdG8gbWFrZSBYLURvbWFpbiByZXF1ZXN0c1xuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBTdGFja1RyYWNlR1BTKG9wdHMpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0YWNrVHJhY2VHUFMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrVHJhY2VHUFMob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgdGhpcy5zb3VyY2VDYWNoZSA9IG9wdHMuc291cmNlQ2FjaGUgfHwge307XG4gICAgICAgIHRoaXMuc291cmNlTWFwQ29uc3VtZXJDYWNoZSA9IG9wdHMuc291cmNlTWFwQ29uc3VtZXJDYWNoZSB8fCB7fTtcblxuICAgICAgICB0aGlzLmFqYXggPSBvcHRzLmFqYXggfHwgX3hkcjtcblxuICAgICAgICB0aGlzLl9hdG9iID0gb3B0cy5hdG9iIHx8IF9hdG9iO1xuXG4gICAgICAgIHRoaXMuX2dldCA9IGZ1bmN0aW9uIF9nZXQobG9jYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNEYXRhVXJsID0gbG9jYXRpb24uc3Vic3RyKDAsIDUpID09PSAnZGF0YTonO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZUNhY2hlW2xvY2F0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuc291cmNlQ2FjaGVbbG9jYXRpb25dKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMub2ZmbGluZSAmJiAhaXNEYXRhVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Nhbm5vdCBtYWtlIG5ldHdvcmsgcmVxdWVzdHMgaW4gb2ZmbGluZSBtb2RlJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgVVJMcyBjYW4gaGF2ZSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIzOTdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdXBwb3J0ZWRFbmNvZGluZ1JlZ2V4cCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjsoW1xcdz06XCItXSs7KSpiYXNlNjQsLztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxvY2F0aW9uLm1hdGNoKHN1cHBvcnRlZEVuY29kaW5nUmVnZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBTdGFydCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZFNvdXJjZSA9IGxvY2F0aW9uLnN1YnN0cihzb3VyY2VNYXBTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX2F0b2IoZW5jb2RlZFNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VDYWNoZVtsb2NhdGlvbl0gPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgZW5jb2Rpbmcgb2YgdGhlIGlubGluZSBzb3VyY2VtYXAgaXMgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4aHJQcm9taXNlID0gdGhpcy5hamF4KGxvY2F0aW9uLCB7bWV0aG9kOiAnZ2V0J30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIFByb21pc2UgdG8gcHJldmVudCBkdXBsaWNhdGUgaW4tZmxpZ2h0IHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZUNhY2hlW2xvY2F0aW9uXSA9IHhoclByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHJQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0aW5nIFNvdXJjZU1hcENvbnN1bWVycyBpcyBleHBlbnNpdmUsIHNvIHRoaXMgd3JhcHMgdGhlIGNyZWF0aW9uIG9mIGFcbiAgICAgICAgICogU291cmNlTWFwQ29uc3VtZXIgaW4gYSBwZXItaW5zdGFuY2UgY2FjaGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2VNYXBwaW5nVVJMID0gVVJMIHRvIGZldGNoIHNvdXJjZSBtYXAgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFNvdXJjZVJvb3QgPSBEZWZhdWx0IHNvdXJjZSByb290IGZvciBzb3VyY2UgbWFwIGlmIHVuZGVmaW5lZFxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyBhIFNvdXJjZU1hcENvbnN1bWVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9nZXRTb3VyY2VNYXBDb25zdW1lciA9IGZ1bmN0aW9uIF9nZXRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXBwaW5nVVJMLCBkZWZhdWx0U291cmNlUm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VNYXBDb25zdW1lckNhY2hlW3NvdXJjZU1hcHBpbmdVUkxdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5zb3VyY2VNYXBDb25zdW1lckNhY2hlW3NvdXJjZU1hcHBpbmdVUkxdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlTWFwQ29uc3VtZXJQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KHNvdXJjZU1hcHBpbmdVUkwpLnRoZW4oZnVuY3Rpb24oc291cmNlTWFwU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VNYXBTb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU1hcFNvdXJjZSA9IF9wYXJzZUpzb24oc291cmNlTWFwU291cmNlLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VNYXBTb3VyY2Uuc291cmNlUm9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwU291cmNlLnNvdXJjZVJvb3QgPSBkZWZhdWx0U291cmNlUm9vdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBTb3VyY2VNYXAuU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwU291cmNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZU1hcENvbnN1bWVyQ2FjaGVbc291cmNlTWFwcGluZ1VSTF0gPSBzb3VyY2VNYXBDb25zdW1lclByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc291cmNlTWFwQ29uc3VtZXJQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIFN0YWNrRnJhbWUsIGVuaGFuY2UgZnVuY3Rpb24gbmFtZSBhbmQgdXNlIHNvdXJjZSBtYXBzIGZvciBhXG4gICAgICAgICAqIGJldHRlciBTdGFja0ZyYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0YWNrRnJhbWV9IHN0YWNrZnJhbWUgb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIHdpdGggd2l0aCBzb3VyY2UtbWFwcGVkIFN0YWNrRnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGlucG9pbnQgPSBmdW5jdGlvbiBTdGFja1RyYWNlR1BTJCRwaW5wb2ludChzdGFja2ZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRNYXBwZWRMb2NhdGlvbihzdGFja2ZyYW1lKS50aGVuKGZ1bmN0aW9uKG1hcHBlZFN0YWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZU1hcHBlZFN0YWNrRnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1hcHBlZFN0YWNrRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kRnVuY3Rpb25OYW1lKG1hcHBlZFN0YWNrRnJhbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlLCByZXNvbHZlTWFwcGVkU3RhY2tGcmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmV4cGVjdGVkLW11bHRpbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgWydjYXRjaCddKHJlc29sdmVNYXBwZWRTdGFja0ZyYW1lKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIHJlamVjdCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIFN0YWNrRnJhbWUsIGd1ZXNzIGZ1bmN0aW9uIG5hbWUgZnJvbSBsb2NhdGlvbiBpbmZvcm1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdGFja0ZyYW1lfSBzdGFja2ZyYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIHdpdGggZW5oYW5jZWQgU3RhY2tGcmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmluZEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uIFN0YWNrVHJhY2VHUFMkJGZpbmRGdW5jdGlvbk5hbWUoc3RhY2tmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF9lbnN1cmVTdGFja0ZyYW1lSXNMZWdpdChzdGFja2ZyYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXQoc3RhY2tmcmFtZS5maWxlTmFtZSkudGhlbihmdW5jdGlvbiBnZXRTb3VyY2VDYWxsYmFjayhzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzdGFja2ZyYW1lLmxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBzdGFja2ZyYW1lLmNvbHVtbk51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGd1ZXNzZWRGdW5jdGlvbk5hbWUgPSBfZmluZEZ1bmN0aW9uTmFtZShzb3VyY2UsIGxpbmVOdW1iZXIsIGNvbHVtbk51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVwbGFjZSBmdW5jdGlvbk5hbWUgaWYgd2UgZm91bmQgc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChndWVzc2VkRnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGd1ZXNzZWRGdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogc3RhY2tmcmFtZS5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBzdGFja2ZyYW1lLmZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBjb2x1bW5OdW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RhY2tmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCByZWplY3QpWydjYXRjaCddKHJlamVjdCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIFN0YWNrRnJhbWUsIHNlZWsgc291cmNlLW1hcHBlZCBsb2NhdGlvbiBhbmQgcmV0dXJuIG5ldyBlbmhhbmNlZCBTdGFja0ZyYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0YWNrRnJhbWV9IHN0YWNrZnJhbWVcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgd2l0aCBlbmhhbmNlZCBTdGFja0ZyYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRNYXBwZWRMb2NhdGlvbiA9IGZ1bmN0aW9uIFN0YWNrVHJhY2VHUFMkJGdldE1hcHBlZExvY2F0aW9uKHN0YWNrZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBfZW5zdXJlU3VwcG9ydGVkRW52aXJvbm1lbnQoKTtcbiAgICAgICAgICAgICAgICBfZW5zdXJlU3RhY2tGcmFtZUlzTGVnaXQoc3RhY2tmcmFtZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQ2FjaGUgPSB0aGlzLnNvdXJjZUNhY2hlO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHN0YWNrZnJhbWUuZmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0KGZpbGVOYW1lKS50aGVuKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlTWFwcGluZ1VSTCA9IF9maW5kU291cmNlTWFwcGluZ1VSTChzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNEYXRhVXJsID0gc291cmNlTWFwcGluZ1VSTC5zdWJzdHIoMCwgNSkgPT09ICdkYXRhOic7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0U291cmNlUm9vdCA9IGZpbGVOYW1lLnN1YnN0cmluZygwLCBmaWxlTmFtZS5sYXN0SW5kZXhPZignLycpICsgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZU1hcHBpbmdVUkxbMF0gIT09ICcvJyAmJiAhaXNEYXRhVXJsICYmICEoL15odHRwcz86XFwvXFwvfF5cXC9cXC8vaSkudGVzdChzb3VyY2VNYXBwaW5nVVJMKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwcGluZ1VSTCA9IGRlZmF1bHRTb3VyY2VSb290ICsgc291cmNlTWFwcGluZ1VSTDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXBwaW5nVVJMLCBkZWZhdWx0U291cmNlUm9vdClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9leHRyYWN0TG9jYXRpb25JbmZvRnJvbVNvdXJjZU1hcFNvdXJjZShzdGFja2ZyYW1lLCBzb3VyY2VNYXBDb25zdW1lciwgc291cmNlQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpWydjYXRjaCddKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGFja2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIHJlamVjdClbJ2NhdGNoJ10ocmVqZWN0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbn0pKTtcbiIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3N0YWNrdHJhY2UnLCBbJ2Vycm9yLXN0YWNrLXBhcnNlcicsICdzdGFjay1nZW5lcmF0b3InLCAnc3RhY2t0cmFjZS1ncHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2Vycm9yLXN0YWNrLXBhcnNlcicpLCByZXF1aXJlKCdzdGFjay1nZW5lcmF0b3InKSwgcmVxdWlyZSgnc3RhY2t0cmFjZS1ncHMnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdGFja1RyYWNlID0gZmFjdG9yeShyb290LkVycm9yU3RhY2tQYXJzZXIsIHJvb3QuU3RhY2tHZW5lcmF0b3IsIHJvb3QuU3RhY2tUcmFjZUdQUyk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiBTdGFja1RyYWNlKEVycm9yU3RhY2tQYXJzZXIsIFN0YWNrR2VuZXJhdG9yLCBTdGFja1RyYWNlR1BTKSB7XG4gICAgdmFyIF9vcHRpb25zID0ge1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKHN0YWNrZnJhbWUpIHtcbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgc3RhY2tmcmFtZXMgZm9yIHRoaXMgbGlicmFyeSBieSBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4gKHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lIHx8ICcnKS5pbmRleE9mKCdTdGFja1RyYWNlJCQnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAoc3RhY2tmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJycpLmluZGV4T2YoJ0Vycm9yU3RhY2tQYXJzZXIkJCcpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIChzdGFja2ZyYW1lLmZ1bmN0aW9uTmFtZSB8fCAnJykuaW5kZXhPZignU3RhY2tUcmFjZUdQUyQkJykgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgKHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lIHx8ICcnKS5pbmRleE9mKCdTdGFja0dlbmVyYXRvciQkJykgPT09IC0xO1xuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VDYWNoZToge31cbiAgICB9O1xuXG4gICAgdmFyIF9nZW5lcmF0ZUVycm9yID0gZnVuY3Rpb24gU3RhY2tUcmFjZSQkR2VuZXJhdGVFcnJvcigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEVycm9yIG11c3QgYmUgdGhyb3duIHRvIGdldCBzdGFjayBpbiBJRVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZSAyIGdpdmVuIE9iamVjdHMuIElmIGEgY29uZmxpY3Qgb2NjdXJzIHRoZSBzZWNvbmQgb2JqZWN0IHdpbnMuXG4gICAgICogRG9lcyBub3QgZG8gZGVlcCBtZXJnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlyc3QgYmFzZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Vjb25kIG92ZXJyaWRlc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG1lcmdlZCBmaXJzdCBhbmQgc2Vjb25kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbWVyZ2UoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgICAgICAgW2ZpcnN0LCBzZWNvbmRdLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXNTaGFwZWRMaWtlUGFyc2FibGVFcnJvcihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVyci5zdGFjayB8fCBlcnJbJ29wZXJhI3NvdXJjZWxvYyddO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maWx0ZXJlZChzdGFja2ZyYW1lcywgZmlsdGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tmcmFtZXMuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrZnJhbWVzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBiYWNrdHJhY2UgZnJvbSBpbnZvY2F0aW9uIHBvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IG9mIFN0YWNrRnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gU3RhY2tUcmFjZSQkZ2V0KG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBfZ2VuZXJhdGVFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIF9pc1NoYXBlZExpa2VQYXJzYWJsZUVycm9yKGVycikgPyB0aGlzLmZyb21FcnJvcihlcnIsIG9wdHMpIDogdGhpcy5nZW5lcmF0ZUFydGlmaWNpYWxseShvcHRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgYmFja3RyYWNlIGZyb20gaW52b2NhdGlvbiBwb2ludC5cbiAgICAgICAgICogSU1QT1JUQU5UOiBEb2VzIG5vdCBoYW5kbGUgc291cmNlIG1hcHMgb3IgZ3Vlc3MgZnVuY3Rpb24gbmFtZXMhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gb2YgU3RhY2tGcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3luYzogZnVuY3Rpb24gU3RhY2tUcmFjZSQkZ2V0U3luYyhvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gX21lcmdlKF9vcHRpb25zLCBvcHRzKTtcbiAgICAgICAgICAgIHZhciBlcnIgPSBfZ2VuZXJhdGVFcnJvcigpO1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gX2lzU2hhcGVkTGlrZVBhcnNhYmxlRXJyb3IoZXJyKSA/IEVycm9yU3RhY2tQYXJzZXIucGFyc2UoZXJyKSA6IFN0YWNrR2VuZXJhdG9yLmJhY2t0cmFjZShvcHRzKTtcbiAgICAgICAgICAgIHJldHVybiBfZmlsdGVyZWQoc3RhY2ssIG9wdHMuZmlsdGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYW4gZXJyb3Igb2JqZWN0LCBwYXJzZSBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3IgQXJyYXlbU3RhY2tGcmFtZX1cbiAgICAgICAgICovXG4gICAgICAgIGZyb21FcnJvcjogZnVuY3Rpb24gU3RhY2tUcmFjZSQkZnJvbUVycm9yKGVycm9yLCBvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gX21lcmdlKF9vcHRpb25zLCBvcHRzKTtcbiAgICAgICAgICAgIHZhciBncHMgPSBuZXcgU3RhY2tUcmFjZUdQUyhvcHRzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrZnJhbWVzID0gX2ZpbHRlcmVkKEVycm9yU3RhY2tQYXJzZXIucGFyc2UoZXJyb3IpLCBvcHRzLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShQcm9taXNlLmFsbChzdGFja2ZyYW1lcy5tYXAoZnVuY3Rpb24oc2YpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVPcmlnaW5hbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZ3BzLnBpbnBvaW50KHNmKS50aGVuKHJlc29sdmUsIHJlc29sdmVPcmlnaW5hbClbJ2NhdGNoJ10ocmVzb2x2ZU9yaWdpbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBTdGFja0dlbmVyYXRvciB0byBnZW5lcmF0ZSBhIGJhY2t0cmFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IG9mIEFycmF5W1N0YWNrRnJhbWVdXG4gICAgICAgICAqL1xuICAgICAgICBnZW5lcmF0ZUFydGlmaWNpYWxseTogZnVuY3Rpb24gU3RhY2tUcmFjZSQkZ2VuZXJhdGVBcnRpZmljaWFsbHkob3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IF9tZXJnZShfb3B0aW9ucywgb3B0cyk7XG4gICAgICAgICAgICB2YXIgc3RhY2tGcmFtZXMgPSBTdGFja0dlbmVyYXRvci5iYWNrdHJhY2Uob3B0cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc3RhY2tGcmFtZXMgPSBzdGFja0ZyYW1lcy5maWx0ZXIob3B0cy5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdGFja0ZyYW1lcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgZnVuY3Rpb24sIHdyYXAgaXQgc3VjaCB0aGF0IGludm9jYXRpb25zIHRyaWdnZXIgYSBjYWxsYmFjayB0aGF0XG4gICAgICAgICAqIGlzIGNhbGxlZCB3aXRoIGEgc3RhY2sgdHJhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRvIGJlIGluc3RydW1lbnRlZFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdpdGggYSBzdGFjayB0cmFjZSBvbiBpbnZvY2F0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycmJhY2sgb3B0aW9uYWwgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGVycm9yIGlmIHVuYWJsZSB0byBnZXQgc3RhY2sgdHJhY2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIG9wdGlvbmFsIGNvbnRleHQgb2JqZWN0IChlLmcuIHdpbmRvdylcbiAgICAgICAgICovXG4gICAgICAgIGluc3RydW1lbnQ6IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJGluc3RydW1lbnQoZm4sIGNhbGxiYWNrLCBlcnJiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW5zdHJ1bWVudCBub24tZnVuY3Rpb24gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmbi5fX3N0YWNrdHJhY2VPcmlnaW5hbEZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBpbnN0cnVtZW50ZWQsIHJldHVybiBnaXZlbiBGdW5jdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluc3RydW1lbnRlZCA9IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJGluc3RydW1lbnRlZCgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldCgpLnRoZW4oY2FsbGJhY2ssIGVycmJhY2spWydjYXRjaCddKGVycmJhY2spO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZyB8fCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1NoYXBlZExpa2VQYXJzYWJsZUVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb21FcnJvcihlKS50aGVuKGNhbGxiYWNrLCBlcnJiYWNrKVsnY2F0Y2gnXShlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGluc3RydW1lbnRlZC5fX3N0YWNrdHJhY2VPcmlnaW5hbEZuID0gZm47XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50ZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBpbnN0cnVtZW50ZWQsXG4gICAgICAgICAqIHJldmVydCB0aGUgZnVuY3Rpb24gdG8gaXQncyBvcmlnaW5hbCAobm9uLWluc3RydW1lbnRlZCkgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRvIGRlLWluc3RydW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGRlaW5zdHJ1bWVudDogZnVuY3Rpb24gU3RhY2tUcmFjZSQkZGVpbnN0cnVtZW50KGZuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGUtaW5zdHJ1bWVudCBub24tZnVuY3Rpb24gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmbi5fX3N0YWNrdHJhY2VPcmlnaW5hbEZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIG5vdCBpbnN0cnVtZW50ZWQsIHJldHVybiBvcmlnaW5hbFxuICAgICAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYW4gZXJyb3IgbWVzc2FnZSBhbmQgQXJyYXkgb2YgU3RhY2tGcmFtZXMsIHNlcmlhbGl6ZSBhbmQgUE9TVCB0byBnaXZlbiBVUkwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHN0YWNrZnJhbWVzXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yTXNnXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0T3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3J0OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRyZXBvcnQoc3RhY2tmcmFtZXMsIHVybCwgZXJyb3JNc2csIHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBvbnJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPj0gMjAwICYmIHJlcS5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdQT1NUIHRvICcgKyB1cmwgKyAnIGZhaWxlZCB3aXRoIHN0YXR1czogJyArIHJlcS5zdGF0dXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxLm9wZW4oJ3Bvc3QnLCB1cmwpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlcXVlc3QgaGVhZGVyc1xuICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucyAmJiB0eXBlb2YgcmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBoZWFkZXIgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCBoZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCBoZWFkZXJzW2hlYWRlcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlcG9ydFBheWxvYWQgPSB7c3RhY2s6IHN0YWNrZnJhbWVzfTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JNc2cgIT09IHVuZGVmaW5lZCAmJiBlcnJvck1zZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRQYXlsb2FkLm1lc3NhZ2UgPSBlcnJvck1zZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXEuc2VuZChKU09OLnN0cmluZ2lmeShyZXBvcnRQYXlsb2FkKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KSk7XG4iLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcbiAgcmV0dXJuIChbXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1cbiAgXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2NDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkgPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNzRHJpdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9LYXRhbE1ldHJpY3NEcml2ZXJcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1R5cGVcIikpO1xuXG52YXIgX2thdGFsU3VzaGlDbGllbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYW16bi9rYXRhbC1zdXNoaS1jbGllbnRcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBLQVRfU1RBTkRBTE9ORV9ORVhVU19QUk9EVUNFUl9JRCA9ICdrYXRhbCc7XG52YXIgS0FUX1NUQU5EQUxPTkVfREVGQVVMVF9TT1VSQ0VfR1JPVVBTID0ge1xuICB0ZXN0OiAnY29tLmFtYXpvbi5lZWwua2F0YWwubWV0cmljcy5jb3JlLm5leHVzLmdhbW1hJyxcbiAgcHJvZDogJ2NvbS5hbWF6b24uZWVsLmthdGFsLm1ldHJpY3MuY29yZS5uZXh1cydcbn07XG5cbnZhciBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaUJ1aWxkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaUJ1aWxkZXIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGlCdWlsZGVyKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImNvbnRleHRcIiwge30pO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGlCdWlsZGVyLCBbe1xuICAgIGtleTogXCJ3aXRoU3VzaGlDbGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFN1c2hpQ2xpZW50KHN1c2hpQ2xpZW50KSB7XG4gICAgICBjb25zb2xlLmxvZygnd2l0aFN1c2hpIGNsaWVudC4uLicpO1xuICAgICAgdGhpcy5jb250ZXh0LnN1c2hpQ2xpZW50ID0gc3VzaGlDbGllbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aERvbWFpblJlYWxtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhEb21haW5SZWFsbShkb21haW4sIHJlYWxtKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZG9tYWluID0gZG9tYWluO1xuICAgICAgdGhpcy5jb250ZXh0LnJlYWxtID0gcmVhbG07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEN1c3RvbVByb2R1Y2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhDdXN0b21Qcm9kdWNlcihzdXNoaVByb2R1Y2VySWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zdXNoaVByb2R1Y2VyID0gc3VzaGlQcm9kdWNlcklkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDdXN0b21Tb3VyY2VHcm91cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ3VzdG9tU291cmNlR3JvdXAoc291cmNlR3JvdXBJZCkge1xuICAgICAgdGhpcy5jb250ZXh0LnNvdXJjZUdyb3VwSWQgPSBzb3VyY2VHcm91cElkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhFcnJvckhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEVycm9ySGFuZGxlcihlcnJvckhhbmRsZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFN1c2hpQ2xpZW50T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU3VzaGlDbGllbnRPcHRpb25zKHN1c2hpQ2xpZW50T3B0aW9ucykge1xuICAgICAgdGhpcy5jb250ZXh0LnN1c2hpQ2xpZW50T3B0aW9ucyA9IHN1c2hpQ2xpZW50T3B0aW9ucztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoU3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZShzdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSA9IHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICByZXR1cm4gbmV3IEthdGFsTWV0cmljc0RyaXZlclN1c2hpKHRoaXMuY29udGV4dCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaUJ1aWxkZXI7XG59KCk7XG5cbnZhciBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0thdGFsTWV0cmljc0RyaXZlcikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSwgX0thdGFsTWV0cmljc0RyaXZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSk7XG5cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljc0RyaXZlclN1c2hpKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwic3VzaGlcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCBcInByb2R1Y2VySWRcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCBcInNvdXJjZUdyb3VwSWRcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCBcImVycm9ySGFuZGxlclwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwiY29tYmluZWRFcnJvckhhbmRsZXJcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKF90aGlzLmVycm9ySGFuZGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF90aGlzLmVycm9ySGFuZGxlcihlcnIpOyAvLyBSZXR1cm4gdG8gYXZvaWQgZmFsbGluZyB0aHJvdWdoIHRvIGRlZmF1bHQgZXJyb3IgaGFuZGxlclxuXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKG5leHRFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaGFuZGxpbmcgZXJyb3IgcHVibGlzaGluZyBtZXRyaWNzOlwiKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG5leHRFcnIpOyAvLyBGYWxsIHRocm91Z2hcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyKGVycik7XG4gICAgfSk7XG4gICAgdmFyIGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluLFxuICAgICAgICByZWFsbSA9IG9wdGlvbnMucmVhbG0sXG4gICAgICAgIGVycm9ySGFuZGxlciA9IG9wdGlvbnMuZXJyb3JIYW5kbGVyLFxuICAgICAgICBzdXNoaUNsaWVudCA9IG9wdGlvbnMuc3VzaGlDbGllbnQsXG4gICAgICAgIF9vcHRpb25zJHN1c2hpUHJvZHVjZSA9IG9wdGlvbnMuc3VzaGlQcm9kdWNlcixcbiAgICAgICAgcHJvZHVjZXJJZCA9IF9vcHRpb25zJHN1c2hpUHJvZHVjZSA9PT0gdm9pZCAwID8gS0FUX1NUQU5EQUxPTkVfTkVYVVNfUFJPRFVDRVJfSUQgOiBfb3B0aW9ucyRzdXNoaVByb2R1Y2UsXG4gICAgICAgIHN1c2hpQ2xpZW50T3B0aW9ucyA9IG9wdGlvbnMuc3VzaGlDbGllbnRPcHRpb25zLFxuICAgICAgICBzdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlID0gb3B0aW9ucy5zdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlOyAvLyBjdXN0b20gc291cmNlIGdyb3VwIGFsd2F5cyBvdmVycmlkZXMgZGVmYXVsdHNcblxuICAgIHZhciBzb3VyY2VHcm91cElkID0gb3B0aW9ucy5zb3VyY2VHcm91cElkIHx8IEtBVF9TVEFOREFMT05FX0RFRkFVTFRfU09VUkNFX0dST1VQU1tkb21haW5dIHx8IEtBVF9TVEFOREFMT05FX0RFRkFVTFRfU09VUkNFX0dST1VQU1sndGVzdCddO1xuICAgIF90aGlzLnN1c2hpID0gc3VzaGlDbGllbnQgfHwgX3RoaXMuYnVpbGRTdXNoaUNsaWVudChkb21haW4sIHJlYWxtLCBzb3VyY2VHcm91cElkLCBzdXNoaUNsaWVudE9wdGlvbnMsIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUpO1xuICAgIF90aGlzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgICBfdGhpcy5wcm9kdWNlcklkID0gcHJvZHVjZXJJZDtcbiAgICBfdGhpcy5zb3VyY2VHcm91cElkID0gc291cmNlR3JvdXBJZDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSwgW3tcbiAgICBrZXk6IFwiYmVmb3JlVW5sb2FkXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBjYWxsZWQgcmlnaHQgYmVmb3JlIHRoZSBwYWdlIHVubG9hZHMuIFRoaXNcbiAgICAgKiBhbGxvd3MgZm9yIGFueSBmaW5hbCBtZXRyaWNzLCBzdWNoIGFzIHBhZ2UgdmlzaXQgZHVyYXRpb24sIHRvIGJlIHNlbnRcbiAgICAgKiBiZWZvcmUgdGhlIHVzZXIgbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZSBvciBjbG9zZXMgdGhlIHRhYi5cbiAgICAgKiBOT1RFOiBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBBUEkgYW5kIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlVW5sb2FkKGNiKSB7XG4gICAgICB0aGlzLnN1c2hpLm9uU3VzaGlVbmxvYWQoY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGVycm9yIGhhbmRsZXIgaWYgdGhlIHVzZXItc3VwcGxpZWQgZXJyb3IgaGFuZGxlciBmYWlscyBvciBpcyB1bnNldC4gIFNob3VsZCBuZXZlciBiZSBjYWxsZWQgdW5sZXNzXG4gICAgICogdXNlci1wcm92aWRlZCBlcnJvciBoYW5kbGVyIG1pc2JlaGF2ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyIFVuaGFuZGxlZCBlcnJvciBvYmplY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRFcnJvckhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdEVycm9ySGFuZGxlcihlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwdWJsaXNoaW5nIG1ldHJpY3M6XCIpO1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBlcnJvci1oYW5kbGVyIHN1cHBsaWVkIGJ5IHRoZSB1c2VyIHdoZW4gdGhpcyBvYmplY3Qgd2FzIGNvbnN0cnVjdGVkOyBpZiB0aGF0IGlzIHVuc2V0IG9yIGl0c2VsZiB0aHJvd3NcbiAgICAgKiBhbiBleGNlcHRpb24sIGNhbGxzIHRoZSBkZWZhdWx0IGVycm9yIGhhbmRsZXIgYXMgYSBmYWxsYmFjaywgd2hpY2ggd2lsbCBqdXN0IGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyIEVycm9yIG9iamVjdCB0byBoYW5kbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpdGhFcnJvckhhbmRsaW5nXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byB3cmFwIGEgZnVuY3Rpb24gaW4gdGhlIGVycm9yIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9UaGVUaGluZyBGdW5jdGlvbiB0byBydW4gdW5kZXIgdGhlIHdyYXBwZXJcbiAgICAgKiBAcmV0dXJuIFJldHVybiB2YWx1ZSBmcm9tIGNhbGxlZCBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdpdGhFcnJvckhhbmRsaW5nKGRvVGhlVGhpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkb1RoZVRoaW5nKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lZEVycm9ySGFuZGxlcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFN1c2hpQ2xpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkU3VzaGlDbGllbnQoZG9tYWluLCByZWFsbSwgc291cmNlR3JvdXBJZCwgc3VzaGlDbGllbnRPcHRpb25zLCBzdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlKSB7XG4gICAgICBpZiAoIWRvbWFpbiB8fCAhcmVhbG0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSByZXF1aXJlcyBhIGRvbWFpbiBhbmQgcmVhbG0gdG8gYnVpbGQgYSBzdXNoaSBjbGllbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgX2thdGFsU3VzaGlDbGllbnQuZGVmYXVsdChLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaS5nZXRSZWFsbU5hbWUocmVhbG0pLCBzb3VyY2VHcm91cElkLCB0aGlzLmNvbWJpbmVkRXJyb3JIYW5kbGVyLCBzdXNoaUNsaWVudE9wdGlvbnMsIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoXCIsXG4gICAgdmFsdWU6IC8vIFRPRE86IGVycm9ySGFuZGxlciBpbiB0aGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCBpcyBub3QgcmVmZXJlbmNlZC5cbiAgICAvLyBUZWNoIGRlYnQ6IGh0dHBzOi8vaXNzdWVzLmFtYXpvbi5jb20vaXNzdWVzL0tBVC04NzVcbiAgICBmdW5jdGlvbiBwdWJsaXNoKG1ldHJpY09iamVjdCwgZXJyb3JIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gU3VwcG9ydCBmb3IgbmV3IDItYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoLCB3aGljaCBkb2VzIG5vdCBwYXNzIHRoZSB1bnVzZWQgZXJyb3JIYW5kbGVyIG9iamVjdCAoS0FULTg3NSlcbiAgICAgIHZhciBtZXRyaWNzQ29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gYXJndW1lbnRzWzFdIDogYXJndW1lbnRzWzJdO1xuICAgICAgdGhpcy53aXRoRXJyb3JIYW5kbGluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgbG9naWMgaXMgbm93IG1vdmVkIGludG8gS2F0YWxNZXRyaWNzUHVibGlzaGVyLCBvbmNlIGV2ZXJ5Ym9keSBoYXMgdGhhdCB1cGRhdGUgd2UgY2FuIHJlbW92ZSB0aGlzLlxuICAgICAgICAvLyBUZWNoIGRlYnQ6IGh0dHBzOi8vaXNzdWVzLmFtYXpvbi5jb20vaXNzdWVzL0tBVC04NzZcbiAgICAgICAgaWYgKF9LYXRhbE1ldHJpY1R5cGUuZGVmYXVsdC5MaXN0ID09PSBtZXRyaWNPYmplY3QudHlwZSkge1xuICAgICAgICAgIG1ldHJpY09iamVjdC5tZXRyaWNMaXN0LmZvckVhY2goZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICAgICAgX3RoaXMyLnB1Ymxpc2gobWV0cmljLCBtZXRyaWNzQ29udGV4dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHVzU2NoZW1hID0gX3RoaXMyLm1hcE9iamVjdFR5cGVUb05leHVzU2NoZW1hKG1ldHJpY09iamVjdC50eXBlKTtcblxuICAgICAgICB2YXIgZmllbGRzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtZXRyaWNzQ29udGV4dC5jb250ZXh0KSwge30sIHtcbiAgICAgICAgICBtZXRyaWNLZXk6IG1ldHJpY09iamVjdC5uYW1lLFxuICAgICAgICAgIHZhbHVlOiBtZXRyaWNPYmplY3QudmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1ldHJpY09iamVjdC5pc01vbml0b3IpIHtcbiAgICAgICAgICBmaWVsZHMuaXNNb25pdG9yID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBEZWxldGluZyBjbG91ZFdhdGNoRGltZW5zaW9ucyBmaWVsZCBpZiBleGlzdHMgYXMgaXQgYXBwbGllcyBvbmx5IGZvciBLYXRhbE1vbml0b3JpbmdBV1NEcml2ZXIuXG5cblxuICAgICAgICBpZiAoZmllbGRzLmNsb3VkV2F0Y2hEaW1lbnNpb25zKSB7XG4gICAgICAgICAgZGVsZXRlIGZpZWxkcy5jbG91ZFdhdGNoRGltZW5zaW9ucztcbiAgICAgICAgfSAvLyBSZXNldCB0aGUgZXZlbnQgY291bnQgYmFjayB0byAwLCBvdGhlcndpc2UgU3VzaGkgd2lsbCBzdG9wIHB1Ymxpc2hpbmcgYWZ0ZXIgMUsgaXRlbXMgKGh0dHBzOi8vaXNzdWVzLmFtYXpvbi5jb20vaXNzdWVzL0tBVC0xNTM0KVxuXG5cbiAgICAgICAgX3RoaXMyLnN1c2hpLnJlc2V0KCk7XG5cbiAgICAgICAgX3RoaXMyLnN1c2hpLmV2ZW50KGZpZWxkcywgX3RoaXMyLnByb2R1Y2VySWQsIG5leHVzU2NoZW1hLCB7XG4gICAgICAgICAgXCJzc2RcIjogMVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBPYmplY3RUeXBlVG9OZXh1c1NjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBPYmplY3RUeXBlVG9OZXh1c1NjaGVtYShvYmplY3RUeXBlKSB7XG4gICAgICBzd2l0Y2ggKG9iamVjdFR5cGUpIHtcbiAgICAgICAgY2FzZSBfS2F0YWxNZXRyaWNUeXBlLmRlZmF1bHQuU3RyaW5nOlxuICAgICAgICAgIHJldHVybiAna2F0YWwuY2xpZW50Lm1ldHJpY3MuU3RyaW5nLjInO1xuXG4gICAgICAgIGNhc2UgX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0LkNvdW50ZXI6XG4gICAgICAgICAgcmV0dXJuICdrYXRhbC5jbGllbnQubWV0cmljcy5Db3VudGVyLjMnO1xuXG4gICAgICAgIGNhc2UgX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0LlRpbWVyOlxuICAgICAgICAgIHJldHVybiAna2F0YWwuY2xpZW50Lm1ldHJpY3MuVGltZXIuMic7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIuY29uY2F0KG9iamVjdFR5cGUsIFwiIHdoZW4gcHVibGlzaGluZyBtZXRyaWMgb2JqZWN0LlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0UmVhbG1OYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlYWxtTmFtZShyZWFsbSkge1xuICAgICAgc3dpdGNoIChyZWFsbSkge1xuICAgICAgICBjYXNlICdOQUFtYXpvbic6XG4gICAgICAgIGNhc2UgJ1VTQW1hem9uJzpcbiAgICAgICAgICByZXR1cm4gX2thdGFsU3VzaGlDbGllbnQuZGVmYXVsdC5SRUdJT05TLk5BO1xuXG4gICAgICAgIGNhc2UgJ0VVQW1hem9uJzpcbiAgICAgICAgICByZXR1cm4gX2thdGFsU3VzaGlDbGllbnQuZGVmYXVsdC5SRUdJT05TLkVVO1xuXG4gICAgICAgIGNhc2UgJ0ZFQW1hem9uJzpcbiAgICAgICAgY2FzZSAnSlBBbWF6b24nOlxuICAgICAgICAgIHJldHVybiBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0LlJFR0lPTlMuRkU7XG5cbiAgICAgICAgY2FzZSAnQ05BbWF6b24nOlxuICAgICAgICAgIHJldHVybiBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0LlJFR0lPTlMuQ047XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBMZXQgdGhlIFN1c2hpQ2xpZW50IGRlY2lkZSBpZiB0aGlzIGlzIGJvZ3VzIG9yIG5vdC5cbiAgICAgICAgICByZXR1cm4gcmVhbG07XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaTtcbn0oX0thdGFsTWV0cmljc0RyaXZlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkgPSBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBcIkJ1aWxkZXJcIiwgS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGlCdWlsZGVyKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxucmVxdWlyZShcIi4vbm9kZWpzU2hpbXNcIik7XG5cbnZhciBfS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkgPSByZXF1aXJlKFwiLi9LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaVwiKTtcblxuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbnZhciBfZGVmYXVsdCA9IF9LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaS5LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9WYWxpZGF0ZVNpbXBsZVN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaGVscGVyL1ZhbGlkYXRlU2ltcGxlU3RyaW5nXCIpKTtcblxudmFyIF92YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb25zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWxwZXIvdmFsaWRhdGVDbG91ZFdhdGNoRGltZW5zaW9uc1wiKSk7XG5cbnZhciBfRmlyc3RNYXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2hlbHBlci9GaXJzdE1hcFwiKSk7XG5cbnZhciBfbWVyZ2VMaXN0cyA9IHJlcXVpcmUoXCIuL2hlbHBlci9tZXJnZUxpc3RzXCIpO1xuXG52YXIgX2VtYmVkUmVxdWVzdElkID0gcmVxdWlyZShcIi4vaGVscGVyL2VtYmVkUmVxdWVzdElkXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFJFUVVJUkVEX0ZJRUxEUyA9IFsnc2l0ZScsICdzZXJ2aWNlTmFtZScsICdtZXRob2ROYW1lJ107XG5cbnZhciBLYXRhbE1ldHJpY3NDb250ZXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBtZXRyaWNzIGNvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gZmllbGRzLlxuICAgKlxuICAgKiBAcGFyYW0gY29udGV4dEZpZWxkcyBDb250ZXh0IGZpZWxkcyB2YWx1ZSAoZGVmYXVsdCBlbXB0eSlcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljc0NvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHRGaWVsZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljc0NvbnRleHQpO1xuICAgIC8vIENvcHkgZmllbGRzIHNvIHRoaXMgaXMgaW1tdXRhYmxlXG4gICAgdGhpcy5jb250ZXh0ID0gX29iamVjdFNwcmVhZCh7fSwgY29udGV4dEZpZWxkcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0IHdoaWNoIGlzIGEgY29weSBvZiB0aGlzIGNvbnRleHQsIHdpdGggdmFsdWVzIGFkZGVkIG9yIG92ZXJyaWRkZW4gZnJvbVxuICAgKiB0aGUgZ2l2ZW4gY29udGV4dC5cbiAgICpcbiAgICogSWYgdGhlIGdpdmVuIGNvbnRleHQgaXMgbnVsbCBvciBlbXB0eSwgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb3JpZ2luYWwgb2JqZWN0IGFzIGFuIG9wdGltaXphdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHRoYXRDb250ZXh0IENvbnRleHQgdG8gbWVyZ2UgdmFsdWVzIGZyb21cbiAgICogQHJldHVybiBOZXcgY29udGV4dCB3aXRoIGRlZmF1bHQgdmFsdWVzIGZyb20gdGhpcyBjb250ZXh0LCBhbmQgdmFsdWVzIG92ZXJyaWRkZW4gb3IgYWRkZWQgYnkgdGhlIGdpdmVuIGNvbnRleHQuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNzQ29udGV4dCwgW3tcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UodGhhdENvbnRleHQpIHtcbiAgICAgIGlmICghdGhhdENvbnRleHQpIHJldHVybiB0aGlzOyAvLyBDaGVjayBmb3IgYSBjb21tb24gZXJyb3JcblxuICAgICAgaWYgKHRoYXRDb250ZXh0IGluc3RhbmNlb2YgS2F0YWxNZXRyaWNzQ29udGV4dC5CdWlsZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkthdGFsTWV0cmljc0NvbnRleHQuQnVpbGRlciBvYmplY3QgcGFzc2VkIGluc3RlYWQgb2YgS2F0YWxNZXRyaWNzQ29udGV4dC4gIFRyeSBjYWxsaW5nIC5idWlsZCgpIG1ldGhvZC5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhhdENvbnRleHQgaW5zdGFuY2VvZiBLYXRhbE1ldHJpY3NDb250ZXh0ID8gdGhhdENvbnRleHQuY29udGV4dCA6IHRoYXRDb250ZXh0O1xuXG4gICAgICB2YXIgbmV3Q29udGV4dCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmNvbnRleHQpLCBjb250ZXh0KSwge30sIHtcbiAgICAgICAgcmVsYXRlZE1ldHJpY3M6ICgwLCBfbWVyZ2VMaXN0cy5tZXJnZUxpc3RzKSh0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MsIGNvbnRleHQucmVsYXRlZE1ldHJpY3MpLFxuICAgICAgICByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbjogKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiwgY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiksXG4gICAgICAgIC8vIENvbWJpbmVzIHRoZSBkaW1lbnNpb25zIGZyb20gYmFzZSBwdWJsaXNoZXIgd2l0aCBhbnkgY2hpbGQgcHVibGlzaGVyLlxuICAgICAgICBjbG91ZFdhdGNoRGltZW5zaW9uczogKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5jbG91ZFdhdGNoRGltZW5zaW9ucywgY29udGV4dC5jbG91ZFdhdGNoRGltZW5zaW9ucylcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbmV3IEthdGFsTWV0cmljc0NvbnRleHQobmV3Q29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBjb250ZXh0IHdoaWNoIGlzIGEgY29weSBvZiB0aGlzIGNvbnRleHQgd2l0aCByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiByZW1vdmVkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjaGlsZCBwdWJsaXNoZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIENvcHkgb2YgdGhpcyBjb250ZXh0LCB3aXRoIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uIHJlbW92ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpdGhvdXRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRob3V0UmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEthdGFsTWV0cmljc0NvbnRleHQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmNvbnRleHQpLCB7fSwge1xuICAgICAgICByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbjogdW5kZWZpbmVkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGNvbnRleHQgc3VpdGFibGUgZm9yIHB1YmxpY2F0aW9uIHRvIHRoZSBkcml2ZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBzdHJpcHMgb3V0IGFueSBwcml2YXRlIGZpZWxkcywgYW5kIGxlYXZlcyBvbmx5IGZpZWxkcyBmcm9tIHRoZSBzY2hlbWEgdGhhdCB0aGUgZHJpdmVyIHNob3VsZCBwdWJsaXNoLlxuICAgICAqXG4gICAgICogQHJldHVybiBDb250ZXh0IHN1aXRhYmxlIGZvciBkcml2ZXIgcHVibGljYXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyaXZlckNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJpdmVyQ29udGV4dCgpIHtcbiAgICAgIC8vIERvbid0IHB1Ymxpc2ggcmVsYXRlZE1ldHJpY3MgdG8gdGhlIGRyaXZlclxuICAgICAgdmFyIG5ld0NvbnRleHRGaWVsZHMgPSBfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmNvbnRleHQpO1xuXG4gICAgICBkZWxldGUgbmV3Q29udGV4dEZpZWxkc1tcInJlbGF0ZWRNZXRyaWNzXCJdO1xuICAgICAgZGVsZXRlIG5ld0NvbnRleHRGaWVsZHNbXCJyZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvblwiXTtcbiAgICAgIGRlbGV0ZSBuZXdDb250ZXh0RmllbGRzW1wicmVxdWVzdElkXCJdO1xuXG4gICAgICBpZiAodGhpcy5jb250ZXh0LnJlcXVlc3RJZCkge1xuICAgICAgICBuZXdDb250ZXh0RmllbGRzLmFjdGlvbklkID0gKDAsIF9lbWJlZFJlcXVlc3RJZC5lbWJlZFJlcXVlc3RJZCkobmV3Q29udGV4dEZpZWxkcy5hY3Rpb25JZCwgdGhpcy5jb250ZXh0LnJlcXVlc3RJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dChuZXdDb250ZXh0RmllbGRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc2ltcGxlIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggYSBjb3B5IG9mIHRoZSBmaWVsZHMgZm9yIHRoaXMgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gU2ltcGxlIEphdmFzY3JpcHQgb2JqZWN0IHdpdGggYSBjb3B5IG9mIHRoZSBmaWVsZHMgZm9yIHRoaXMgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpZWxkcygpIHtcbiAgICAgIC8vIENvcHkgZmllbGRzIHNvIHRoaXMgcmVtYWlucyBpbW11dGFibGVcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgYSB2YWxpZGF0aW9uIGVycm9yIG9uIHRoaXMgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbGlkYXRpb24gZXJyb3IgZW5jb3VudGVyZWQgaWYgb25lIGlzIGZvdW5kLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgRXJyb3JzIGZvdW5kIHdpdGggdGhpcyBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGVycjsgLy8gRmllbGRzIOKAnHNpdGXigJ0sIOKAnHNlcnZpY2VOYW1l4oCdLCDigJxtZXRob2ROYW1l4oCdLCBhbmQg4oCcbWV0cmljS2V54oCdIGFyZSByZXF1aXJlZC5cblxuICAgICAgZXJyID0gKDAsIF9GaXJzdE1hcC5kZWZhdWx0KShSRVFVSVJFRF9GSUVMRFMsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAoX3RoaXMuY29udGV4dFtmaWVsZF0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkZpZWxkIFwiLmNvbmNhdChmaWVsZCwgXCIgaXMgcmVxdWlyZWQsIGJ1dCBpdCBpcyBcIikuY29uY2F0KF90aGlzLmNvbnRleHRbZmllbGRdKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGVycikgcmV0dXJuIGVycjtcbiAgICAgIHJldHVybiAoMCwgX0ZpcnN0TWFwLmRlZmF1bHQpKE9iamVjdC5rZXlzKHRoaXMuY29udGV4dCksIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudmFsaWRhdGVGaWVsZChmaWVsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgYW4gaW5kaXZpZHVhbCBjb250ZXh0IGZpZWxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkIE5hbWUgb2YgZmllbGQgdG8gdmFsaWRhdGVcbiAgICAgKiBAcmV0dXJucyBFcnJvciBmb3VuZCB3aXRoIHRoaXMgZmllbGQsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGVGaWVsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgICB2YXIgdmFsID0gdGhpcy5jb250ZXh0W2ZpZWxkXTtcbiAgICAgIHZhciBuYW1lRm9yRXJyb3IgPSBcImZpZWxkIFwiLmNvbmNhdChmaWVsZCk7XG5cbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgLy8gU3RyaW5ncyB3aGljaCBjb3VsZCBiZSB1c2VkIGFzIHBhcnRpdGlvbiBrZXlzIChcInNpdGVcIiBhbmQgXCJzZXJ2aWNlTmFtZVwiKSBjYW5ub3QgY29udGFpbiBzbGFzaGVzLCBpblxuICAgICAgICAvLyBhZGRpdGlvbiB0byB0aGUgb3RoZXIgcmVzdGljdGlvbnMgYmVsb3cuXG4gICAgICAgIGNhc2UgJ3NpdGUnOlxuICAgICAgICBjYXNlICdzZXJ2aWNlTmFtZSc6XG4gICAgICAgICAgaWYgKHZhbC5pbmRleE9mKCcvJykgPiAtMSkgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGNvbnRhaW4gb25seSB2YWxpZCBjaGFyYWN0ZXJzLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsLCBcIi4gIEl0IGNhbm5vdCBjb250YWluIGEgc2xhc2guXCIpKTtcbiAgICAgICAgLy8gRWxzZSBmYWxsIHRocm91Z2hcbiAgICAgICAgLy8gU3RyaW5ncyBmb3IgZmllbGRzIOKAnHNpdGXigJ0sIOKAnHNlcnZpY2VOYW1l4oCdLCDigJxtZXRob2ROYW1l4oCdLCDigJxtZXRyaWNLZXnigJ0gbXVzdCBtYXRjaCBiZSB2YWxpZCBQTUVUIGZpZWxkIG5hbWVzOlxuICAgICAgICAvLyBtYXhpbXVtIGxlbmd0aCBvZiAyNTYsIG9ubHkgbGV0dGVycywgbnVtYmVycywgYW5kIHRoZSBkb3QsIGNvbG9uLCBhdC1zaWduLCB1bmRlcnNjb3JlLCBmb3J3YXJkLXNsYXNoLFxuICAgICAgICAvLyBhbmQgc2xhc2ggY2hhcmFjdGVycyAoaW4gc2hvcnQgdGhlIHJlZ2V4IF5bQS1aYS16MC05LjpAXy8tXSskKS5cblxuICAgICAgICBjYXNlICdtZXRob2ROYW1lJzpcbiAgICAgICAgY2FzZSAnYWN0aW9uSWQnOlxuICAgICAgICAgIHJldHVybiAoMCwgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nLmRlZmF1bHQpKHZhbCwgbmFtZUZvckVycm9yKTtcblxuICAgICAgICBjYXNlICdjbG91ZFdhdGNoRGltZW5zaW9ucyc6XG4gICAgICAgICAgcmV0dXJuICgwLCBfdmFsaWRhdGVDbG91ZFdhdGNoRGltZW5zaW9ucy5kZWZhdWx0KSh2YWwgfHwgW10pO1xuICAgICAgfSAvLyBObyBlcnJvciBmb3VuZCwgaW1wbGljaXRseSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRlciBjbGFzcyBmb3IgS2F0YWxNZXRyaWNzQ29udGV4dFxuICAgICAqL1xuXG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljc0NvbnRleHQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljc0NvbnRleHQ7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY3NDb250ZXh0LCBcIkJ1aWxkZXJcIiwgLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX2NsYXNzMigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBfY2xhc3MyKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImNvbnRleHRcIiwge30pO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoX2NsYXNzMiwgW3tcbiAgICBrZXk6IFwid2l0aFNpdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFNpdGUoc2l0ZSkge1xuICAgICAgdGhpcy5jb250ZXh0LnNpdGUgPSBzaXRlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhTZXJ2aWNlTmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU2VydmljZU5hbWUoc2VydmljZU5hbWUpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhNZXRob2ROYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhNZXRob2ROYW1lKG1ldGhvZE5hbWUpIHtcbiAgICAgIHRoaXMuY29udGV4dC5tZXRob2ROYW1lID0gbWV0aG9kTmFtZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoQWN0aW9uSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEFjdGlvbklkKGFjdGlvbklkKSB7XG4gICAgICB0aGlzLmNvbnRleHQuYWN0aW9uSWQgPSBhY3Rpb25JZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoUmVxdWVzdElkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhSZXF1ZXN0SWQocmVxdWVzdElkKSB7XG4gICAgICB0aGlzLmNvbnRleHQucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDbG91ZFdhdGNoRGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ2xvdWRXYXRjaERpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICAgICAgdGhpcy5jb250ZXh0LmNsb3VkV2F0Y2hEaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIGFueSByZWxhdGVkIG1ldHJpY3Mgd2l0aCB0aGUgZ2l2ZW4gbGlzdCAoc2VlIGFkZFJlbGF0ZWRNZXRyaWNzIHRvIGFkZCBpbnN0ZWFkIG9mIHJlcGxhY2UpLlxuICAgICAqXG4gICAgICogUmVsYXRlZCBtZXRyaWNzIGFyZSBtZXRyaWNzIHRoYXQgYXJlIHB1Ymxpc2hlZCB3aGVuZXZlciBhIG5ldyBhY3Rpb24gaXMgc3RhcnRlZC4gIFRoZXkgYXJlIHVzZWQgdG8gcmVsYXRlIHRoZVxuICAgICAqIGFjdGlvbiBiYWNrIHRvIHRoZSBjb250ZXh0IHdoZXJlIGl0IGlzIGhhcHBlbmluZywgZm9yIGV4YW1wbGUgYSByZXF1ZXN0IElEIG9yIGEgdXNlciBpZGVudGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxhdGVkTWV0cmljcyBSZWxhdGVkIG1ldHJpY3MgdG8gcHVibGlzaCB3aGVuIGEgbmV3IGFjdGlvbiBpcyBzdGFydGVkIGZvciB0aGlzIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyBUaGlzIGJ1aWxkZXIgb2JqZWN0IHRvIGNvbnRpbnVlIGJ1aWxkaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoUmVsYXRlZE1ldHJpY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFJlbGF0ZWRNZXRyaWNzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlbGF0ZWRNZXRyaWNzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICByZWxhdGVkTWV0cmljc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzID0gcmVsYXRlZE1ldHJpY3M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFkZGl0aW9uYWwgcmVsYXRlZCBtZXRyaWNzIHRvIHRoaXMgYnVpbGRlci4gIFNlZSB3aXRoUmVsYXRlZE1ldHJpY3MgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVsYXRlZE1ldHJpY3MgQWRkaXRpb25hbCByZWxhdGVkIG1ldHJpY3MgdG8gcHVibGlzaCB3aGVuIGEgbmV3IGFjdGlvbiBpcyBzdGFydGVkIGZvciB0aGlzIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyBUaGlzIGJ1aWxkZXIgb2JqZWN0IHRvIGNvbnRpbnVlIGJ1aWxkaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRSZWxhdGVkTWV0cmljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSZWxhdGVkTWV0cmljcygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVsYXRlZE1ldHJpY3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgcmVsYXRlZE1ldHJpY3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzID0gKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljcywgcmVsYXRlZE1ldHJpY3MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2Ugc2luZ2xlLWFjdGlvbiByZWxhdGVkIG1ldHJpY3Mgd2l0aCB0aGUgZ2l2ZW4gbGlzdCAoc2VlIGFkZFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uIHRvIGFkZCBpbnN0ZWFkIG9mIHJlcGxhY2UsXG4gICAgICogYW5kIHdpdGhSZWxhdGVkTWV0cmljcyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCByZWxhdGVkIG1ldHJpY3MpLlxuICAgICAqXG4gICAgICogU2luZ2xlLWFjdGlvbiByZWxhdGVkIG1ldHJpY3MgYXJlIHB1Ymxpc2hlZCB3aGVuIGEgbmV3IGNoaWxkIG1ldHJpYyBwdWJsaXNoZXIgaXMgY3JlYXRlZCwgYnV0IG5vdCBpbmNsdWRlZCBhc1xuICAgICAqIHJlbGF0ZWQgbWV0cmljcyBmb3IgdGhlIG5ldyBjaGlsZCBtZXRyaWMgcHVibGlzaGVyLCBzbyBhcmUgbm90IHB1Ymxpc2hlZCBhZ2FpbiBpZiB0aGUgY2hpbGQgbWV0cmljIHB1Ymxpc2hlclxuICAgICAqIGNyZWF0ZXMgZ3JhbmRjaGlsZCBwdWJsaXNoZWQgbWV0cmljcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRyaWNzIFJlbGF0ZWQgbWV0cmljc1xuICAgICAqIEByZXR1cm5zIFRoaXMgYnVpbGRlciBvYmplY3QgdG8gY29udGludWUgYnVpbGRpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpdGhSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIG1ldHJpY3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgbWV0cmljc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gPSBtZXRyaWNzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhZGRpdGlvbmFsIHNpbmdsZS1hY3Rpb24gcmVsYXRlZCBtZXRyaWNzIHRvIHRoaXMgYnVpbGRlci4gIFNlZSBhZGRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRyaWNzIFJlbGF0ZWQgbWV0cmljc1xuICAgICAqIEByZXR1cm5zIFRoaXMgYnVpbGRlciBvYmplY3QgdG8gY29udGludWUgYnVpbGRpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBtZXRyaWNzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIG1ldHJpY3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uID0gKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiwgbWV0cmljcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZSB0aGUgZmllbGRzIHNldCBpbiB0aGlzIGJ1aWxkZXIgYW5kIHVzZSB0aGVtIHRvIGNyZWF0ZSBhIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0LlxuICAgICAqXG4gICAgICogQHJldHVybiBLYXRhbE1ldHJpY3NDb250ZXh0IG9iamVjdCBidWlsdCB3aXRoIHRoZSBwYXJhbWV0ZXJzIGdpdmVuIHRvIHRoaXMgYnVpbGRlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICByZXR1cm4gbmV3IEthdGFsTWV0cmljc0NvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIF9jbGFzczI7XG59KCkpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwidXVpZC92NFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNzQ29udGV4dCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNzQ29udGV4dFwiKSk7XG5cbnZhciBfbWV0cmljT2JqZWN0ID0gcmVxdWlyZShcIi4vbWV0cmljT2JqZWN0XCIpO1xuXG52YXIgX21lcmdlTGlzdHMgPSByZXF1aXJlKFwiLi9oZWxwZXIvbWVyZ2VMaXN0c1wiKTtcblxudmFyIF9tZXRyaWNzRXh0ZW5zaW9uID0gcmVxdWlyZShcIi4vaGVscGVyL21ldHJpY3NFeHRlbnNpb25cIik7XG5cbnZhciBfZW1iZWRSZXF1ZXN0SWQgPSByZXF1aXJlKFwiLi9oZWxwZXIvZW1iZWRSZXF1ZXN0SWRcIik7XG5cbnZhciBJTklUSUFMSVpBVElPTl9NRVRIT0RfTkFNRSA9ICdJbml0aWFsaXphdGlvbic7XG5cbi8qKlxuICogRGVmYXVsdCBlcnJvciBoYW5kbGVyIGlmIHRoZSB1c2VyLXN1cHBsaWVkIGVycm9yIGhhbmRsZXIgZmFpbHMgb3IgaXMgdW5zZXQuXG4gKiBTaG91bGQgbmV2ZXIgYmUgY2FsbGVkIHVubGVzcyB1c2VyLXByb3ZpZGVkIGVycm9yIGhhbmRsZXIgbWlzYmVoYXZlcy5cbiAqL1xudmFyIERFRkFVTFRfRVJST1JfSEFORExFUiA9IGZ1bmN0aW9uIERFRkFVTFRfRVJST1JfSEFORExFUihlcnIpIHtcbiAgY29uc29sZS5lcnJvcihcIkVycm9yIHB1Ymxpc2hpbmcgbWV0cmljczpcIik7XG4gIGNvbnNvbGUuZXJyb3IoZXJyKTtcbn07XG5cbnZhciBQQVJFTlRfQUNUSU9OX0lEX05BTUUgPSAncGFyZW50QWN0aW9uSWQnO1xuXG52YXIgZ2V0Q29udGV4dEZpZWxkcyA9IGZ1bmN0aW9uIGdldENvbnRleHRGaWVsZHMoY29udGV4dCkge1xuICBpZiAoY29udGV4dC5jb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufTtcbi8qKlxuICogQ2xhc3MgdXNlZCBmb3IgcHVibGlzaGluZyBtZXRyaWNzIHRvIEthdGFsLiAgQ29udGFpbnMgYSBkcml2ZXIgYW5kIGEgY29udGV4dC5cbiAqXG4gKiBUaGlzIGNsYXNzIGtub3dzIGhvdyB0byBwdWJsaXNoIG1ldHJpY3MsIGFuZCBob3cgdG8gY3JlYXRlIG5ldyBwdWJsaXNoZXJzIHdpdGggYSBtb2RpZmllZCBjb250ZXh0LlxuICovXG5cblxudmFyIEthdGFsTWV0cmljc1B1Ymxpc2hlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbWV0cmljcyBwdWJsaXNoZXIgd2l0aCB0aGUgZ2l2ZW4gZHJpdmVyIGFuZCBjb250ZXh0XG4gICAqXG4gICAqIEBwYXJhbSBkcml2ZXIgU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNzRHJpdmVyIHVzZWQgdG8gcHVibGlzaCB0aGUgbWV0cmljc1xuICAgKiBAcGFyYW0gZXJyb3JIYW5kbGVyIEhhbmRsZXIgZm9yIGVycm9ycyB0aGF0IG9jY3VyIHdoaWxlIHVzaW5nIHRoaXMgcHVibGlzaGVyXG4gICAqIEBwYXJhbSBjb250ZXh0IENvbnRleHQgZm9yIHRoaXMgbWV0cmljcyBwdWJsaXNoZXI7IGNvbnRhaW5zIGRhdGEgdG8gYmUgaW5jbHVkZWQgd2l0aCBldmVyeVxuICAgKiAgICAgbWV0cmljIHB1Ymxpc2hlZCB1c2luZyB0aGlzIHB1Ymxpc2hlciBvYmplY3QuICBEZWZhdWx0IGlzIGFuIGVtcHR5IGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY3NQdWJsaXNoZXIoZHJpdmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBlcnJvckhhbmRsZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfRVJST1JfSEFORExFUjtcbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoKTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY3NQdWJsaXNoZXIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29tYmluZWRFcnJvckhhbmRsZXJcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoaXMuZXJyb3JIYW5kbGVyKGVycik7XG4gICAgICB9IGNhdGNoIChuZXh0RXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBlcnJvciBwdWJsaXNoaW5nIG1ldHJpY3M6XCIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKG5leHRFcnIpO1xuICAgICAgICBERUZBVUxUX0VSUk9SX0hBTkRMRVIoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGZvciBhIGNvbW1vbiBlcnJvclxuICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdC5CdWlsZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLYXRhbE1ldHJpY3NDb250ZXh0LkJ1aWxkZXIgb2JqZWN0IHBhc3NlZCBpbnN0ZWFkIG9mIEthdGFsTWV0cmljc0NvbnRleHQuICBUcnkgY2FsbGluZyAuYnVpbGQoKSBtZXRob2QuXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZHJpdmVyID0gZHJpdmVyO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgIHRoaXMuY29udGV4dCA9ICEoY29udGV4dCBpbnN0YW5jZW9mIF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQpID8gbmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoY29udGV4dCkgOiBjb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoZSBlcnJvci1oYW5kbGVyIHN1cHBsaWVkIGJ5IHRoZSB1c2VyIHdoZW4gdGhpcyBvYmplY3Qgd2FzIGNvbnN0cnVjdGVkOyBpZiB0aGF0IGlzIHVuc2V0IG9yIGl0c2VsZiB0aHJvd3NcbiAgICogYW4gZXhjZXB0aW9uLCBjYWxscyB0aGUgZGVmYXVsdCBlcnJvciBoYW5kbGVyIGFzIGEgZmFsbGJhY2ssIHdoaWNoIHdpbGwganVzdCBsb2cgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLlxuICAgKlxuICAgKiBAcGFyYW0gZXJyIEVycm9yIG9iamVjdCB0byBoYW5kbGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NQdWJsaXNoZXIsIFt7XG4gICAga2V5OiBcIndpdGhFcnJvckhhbmRsaW5nXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byB3cmFwIGEgZnVuY3Rpb24gaW4gdGhlIGVycm9yIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9UaGVUaGluZyBGdW5jdGlvbiB0byBydW4gdW5kZXIgdGhlIHdyYXBwZXJcbiAgICAgKiBAcmV0dXJuIFJldHVybiB2YWx1ZSBmcm9tIGNhbGxlZCBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdpdGhFcnJvckhhbmRsaW5nKGRvVGhlVGhpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkb1RoZVRoaW5nKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lZEVycm9ySGFuZGxlcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHJldHVybiBhbGwgdGhlIHJlbGF0ZWQgbWV0cmljcyBvZiBiYXNlIHB1Ymxpc2hlciBhbmQgYWRkaXRpb25hbENvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgcHVibGlzaGVyXG4gICAgICogQHJldHVybiBSZXR1cm4gYWxsIHJlbGF0ZWQgbWV0cmljcyBmcm9tIGJhc2UgcHVibGlzaGVyIGFuZCBhZGRpdGlvbmFsQ29udGV4dC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEFkZGl0aW9uYWxSZWxhdGVkTWV0cmljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBZGRpdGlvbmFsUmVsYXRlZE1ldHJpY3MoYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHZhciBuZXdDb250ZXh0ID0gYWRkaXRpb25hbENvbnRleHQgaW5zdGFuY2VvZiBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0ID8gYWRkaXRpb25hbENvbnRleHQuY29udGV4dCA6IGFkZGl0aW9uYWxDb250ZXh0O1xuICAgICAgdmFyIGJhc2VSZWxhdGVkTWV0cmljcyA9IHRoaXMuZ2V0QmFzZVJlbGF0ZWRNZXRyaWNzKCk7XG4gICAgICByZXR1cm4gKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKGJhc2VSZWxhdGVkTWV0cmljcywgbmV3Q29udGV4dC5yZWxhdGVkTWV0cmljcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmV0dXJuIGFsbCB0aGUgcmVsYXRlZCBtZXRyaWNzIG9mIGJhc2UgcHVibGlzaGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiBSZXR1cm4gYWxsIHJlbGF0ZWQgbWV0cmljcyBmcm9tIHRoZSBiYXNlIHB1Ymxpc2hlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VSZWxhdGVkTWV0cmljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlUmVsYXRlZE1ldHJpY3MoKSB7XG4gICAgICByZXR1cm4gKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzLCB0aGlzLmNvbnRleHQuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggdGhlIGdpdmVuIG1ldHJpYyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBndWFyYW50ZWVkIG5ldmVyIHRvIHRocm93IGFuIGV4Y2VwdGlvbi4gIElmIHRoZSBtZXRyaWMgb2JqZWN0IG9yIGNvbnRleHQgYXJlIGludmFsaWQsXG4gICAgICogb3IgYW55IG90aGVyIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgcHVibGlzaGluZywgdGhlIHB1Ymxpc2hlcidzIGVycm9yIGhhbmRsZXIgaXMgY2FsbGVkLiAgSWYgdGhlXG4gICAgICogcHVibGlzaGVyJ3MgZXJyb3IgaGFuZGxlciBpcyB1bnNldCBvciBmYWlscywgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBpcyBjYWxsZWQgKHNlZSBkZWZhdWx0RXJyb3JIYW5kbGVyKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrYXRhbE1ldHJpY09iamVjdCBNZXRyaWMgb2JqZWN0IHRvIHB1Ymxpc2hcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaChrYXRhbE1ldHJpY09iamVjdCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMud2l0aEVycm9ySGFuZGxpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWthdGFsTWV0cmljT2JqZWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHB1Ymxpc2ggdW5kZWZpbmVkL251bGwgbWV0cmljIG9iamVjdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfbWV0cmljT2JqZWN0Lk9iamVjdC5UeXBlcy5MaXN0ID09PSBrYXRhbE1ldHJpY09iamVjdC50eXBlKSB7XG4gICAgICAgICAga2F0YWxNZXRyaWNPYmplY3QubWV0cmljTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgICAgIF90aGlzMi5wdWJsaXNoKG1ldHJpYyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRyaXZlckNvbnRleHQgPSBfdGhpczIuY29udGV4dC5kcml2ZXJDb250ZXh0KCk7XG5cbiAgICAgICAgICB2YXIgY29udGV4dEVycm9yID0gZHJpdmVyQ29udGV4dC52YWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgICAgICBpZiAoY29udGV4dEVycm9yKSB0aHJvdyBjb250ZXh0RXJyb3I7XG4gICAgICAgICAgdmFyIG9iamVjdEVycm9yID0ga2F0YWxNZXRyaWNPYmplY3QudmFsaWRhdGlvbkVycm9yKCk7XG4gICAgICAgICAgaWYgKG9iamVjdEVycm9yKSB0aHJvdyBvYmplY3RFcnJvcjtcbiAgICAgICAgICAoMCwgX21ldHJpY3NFeHRlbnNpb24uZGlzcGF0Y2hNZXRyaWNFdmVudCkoa2F0YWxNZXRyaWNPYmplY3QsIGRyaXZlckNvbnRleHQpO1xuXG4gICAgICAgICAgX3RoaXMyLmRyaXZlci5wdWJsaXNoKGthdGFsTWV0cmljT2JqZWN0LCBkcml2ZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBwdWJsaXNoZXIgd2hpY2ggaXMgaWRlbnRpY2FsIHRvIHRoaXMgcHVibGlzaGVyLCBidXQgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBmaWVsZHMgbWVyZ2VkIGludG9cbiAgICAgKiB0aGUgbmV3IHB1Ymxpc2hlcidzIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgcHVibGlzaGVyXG4gICAgICogQHJldHVybnMgTmV3IHB1Ymxpc2hlciBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIHVwZGF0ZWQgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3Q2hpbGRQdWJsaXNoZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRQdWJsaXNoZXIoYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzUHVibGlzaGVyKHRoaXMuZHJpdmVyLCB0aGlzLmVycm9ySGFuZGxlciwgdGhpcy5jb250ZXh0Lm1lcmdlKGFkZGl0aW9uYWxDb250ZXh0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJlZ2luIGEgbmV3IGFjdGlvbiwgYW5kIHJldHVybiBhIG5ldyBwdWJsaXNoZXIgZm9yIG1ldHJpY3MgcmVsYXRlZCB0byB0aGF0IGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEJlZ2lubmluZyBhIG5ldyBhY3Rpb24gaW52b2x2ZXMgdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgICAgKiAgIDEuIEdlbmVyYXRlIGEgbmV3IGFjdGlvbklkIGZvciB0aGUgYWN0aW9uLCByYW5kb21seSBpbiB0aGUgYnJvd3NlclxuICAgICAqICAgMi4gSWYgdGhlcmUgYXJlIGFueSByZWxhdGVkIG1ldHJpY3MgaW4gdGhlIGNvbnRleHQsIHB1Ymxpc2ggdGhlbVxuICAgICAqICAgMy4gQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgcHVibGlzaGVyIHdpdGggdGhpcyBvYmplY3QncyBjb250ZXh0LCBtZXJnZWQgd2l0aCBhbnkgYWRkaXRpb25hbCBjb250ZXh0IGdpdmVuLFxuICAgICAqICAgICAgbWVyZ2VkIHdpdGggdGhlIGFjdGlvbklkIGdlbmVyYXRlZCBhYm92ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBwdWJsaXNoZXJcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlcihhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgdmFyIGFjdGlvbklkID0gdGhpcy5fZ2VuZXJhdGVBY3Rpb25pZChhZGRpdGlvbmFsQ29udGV4dCk7XG5cbiAgICAgIHZhciBuZXdDb250ZXh0ID0gdGhpcy5jb250ZXh0LndpdGhvdXRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbigpLm1lcmdlKHtcbiAgICAgICAgYWN0aW9uSWQ6IGFjdGlvbklkXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCk7XG4gICAgICB2YXIgbmV3UHVibGlzaGVyID0gbmV3IEthdGFsTWV0cmljc1B1Ymxpc2hlcih0aGlzLmRyaXZlciwgdGhpcy5lcnJvckhhbmRsZXIsIG5ld0NvbnRleHQpO1xuICAgICAgdmFyIGFsbFJlbGF0ZWRNZXRyaWNzID0gYWRkaXRpb25hbENvbnRleHQgJiYgIShhZGRpdGlvbmFsQ29udGV4dCBpbnN0YW5jZW9mIF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQuQnVpbGRlcikgPyB0aGlzLmdldEFkZGl0aW9uYWxSZWxhdGVkTWV0cmljcyhhZGRpdGlvbmFsQ29udGV4dCkgOiB0aGlzLmdldEJhc2VSZWxhdGVkTWV0cmljcygpO1xuXG4gICAgICBpZiAoYWxsUmVsYXRlZE1ldHJpY3MpIHtcbiAgICAgICAgYWxsUmVsYXRlZE1ldHJpY3MuZm9yRWFjaChmdW5jdGlvbiAobWV0cmljKSB7XG4gICAgICAgICAgbmV3UHVibGlzaGVyLnB1Ymxpc2gobWV0cmljKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdQdWJsaXNoZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJlZ2luIGEgbmV3IGNoYWluZWQgY2hpbGQgYWN0aW9uLCBhbmQgcmV0dXJuIGEgbmV3IHB1Ymxpc2hlciBmb3IgbWV0cmljcyByZWxhdGVkIHRvIHRoYXQgYWN0aW9uLlxuICAgICAqXG4gICAgICogQSBjaGFpbmVkIGFjdGlvbiBpcyBoYW5kbGVkIHRoZSBzYW1lIHdheSBhcyBpbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlciwgYnV0IGFkZGl0aW9uYWxseSxcbiAgICAgKiB0aGUgcmV0dXJuZWQgcHVibGlzaGVyIGhhcyBhIHJlbGF0ZWRNZXRyaWNOb0luaGVyaXQgbmFtZWQgXCJwYXJlbnRBY3Rpb25JZFwiLCB3aXRoIHRoZSBuZXdseVxuICAgICAqIGdlbmVyYXRlZCBhY3Rpb25JZCBhcyBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGUgZWZmZWN0IG9mIHRoaXMgaXMgdGhhdCBhbnkgZnVydGhlciBjaGFpbmVkIGNoaWxkIGFjdGlvbnMgY2FuIGJlIGNvbm5lY3RlZCBiYWNrIHRvIHRoaXNcbiAgICAgKiBhY3Rpb24gdGhyb3VnaCB0aGUgcGFyZW50QWN0aW9uSWQsIGFuZCBzbyBvbiByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBwdWJsaXNoZXJcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICB2YXIgYWN0aW9uSWQgPSB0aGlzLl9nZW5lcmF0ZUFjdGlvbmlkKGFkZGl0aW9uYWxDb250ZXh0KTtcblxuICAgICAgdmFyIHBhcmVudEFjdGlvbklkID0gKDAsIF9lbWJlZFJlcXVlc3RJZC5lbWJlZFJlcXVlc3RJZCkoYWN0aW9uSWQsIHRoaXMuY29udGV4dC5jb250ZXh0LnJlcXVlc3RJZCk7XG4gICAgICB2YXIgcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gPSBbbmV3IF9tZXRyaWNPYmplY3QuU3RyaW5nKFBBUkVOVF9BQ1RJT05fSURfTkFNRSwgcGFyZW50QWN0aW9uSWQpXTtcbiAgICAgIHZhciBuZXdDb250ZXh0ID0gbmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoe1xuICAgICAgICBhY3Rpb25JZDogYWN0aW9uSWQsXG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uOiByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvblxuICAgICAgfSkubWVyZ2UoYWRkaXRpb25hbENvbnRleHQpO1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXIobmV3Q29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IGNoYWluZWQgY2hpbGQgYWN0aW9uIHB1Ymxpc2hlciB3aXRoIHRoZSBnaXZlbiB2YWx1ZSBmb3IgbWV0aG9kTmFtZS5cbiAgICAgKlxuICAgICAqIEFwYXJ0IGZyb20gc2V0dGluZyB0aGUgbWV0aG9kTmFtZSBpbiB0aGUgY2hpbGQgY29udGV4dCwgdGhpcyBtZXRob2QgaXMgaWRlbnRpY2FsIHRvIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyQ2hhaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRob2ROYW1lIE1ldGhvZCBuYW1lIGZvciBuZXcgcHVibGlzaGVyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIHN1cHBseSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybnMgTmV3IHB1Ymxpc2hlciBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIHVwZGF0ZWQgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkRm9yTWV0aG9kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyQ2hhaW5lZEZvck1ldGhvZChtZXRob2ROYW1lLCBhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkKG5ldyBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0KHtcbiAgICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZVxuICAgICAgfSkubWVyZ2UoYWRkaXRpb25hbENvbnRleHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgYWN0aW9uIHB1Ymxpc2hlciB3aXRoIHRoZSBnaXZlbiB2YWx1ZSBmb3IgbWV0aG9kTmFtZS5cbiAgICAgKlxuICAgICAqIEFwYXJ0IGZyb20gc2V0dGluZyB0aGUgbWV0aG9kTmFtZSBpbiB0aGUgY2hpbGQgY29udGV4dCwgdGhpcyBtZXRob2QgaXMgaWRlbnRpY2FsIHRvIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyRm9yTWV0aG9kLlxuICAgICAqIEBwYXJhbSBtZXRob2ROYW1lIE1ldGhvZCBuYW1lIGZvciBuZXcgcHVibGlzaGVyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIHN1cHBseSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybnMgTmV3IHB1Ymxpc2hlciBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIHVwZGF0ZWQgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QobWV0aG9kTmFtZSwgYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyKG5ldyBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0KHtcbiAgICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZVxuICAgICAgfSkubWVyZ2UoYWRkaXRpb25hbENvbnRleHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgYWN0aW9uIGZvciBhcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvbi4gIEl0IHdpbGwgYWx3YXlzIGhhdmUgYSBtZXRob2ROYW1lXG4gICAgICogb2YgXCJJbml0aWFsaXphdGlvblwiOyBvdGhlcndpc2UgdGhpcyBtZXRob2QgaXMgaWRlbnRpY2FsIHRvIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyRm9yTWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm5zIE5ldyBwdWJsaXNoZXIgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2l0aCBhbiB1cGRhdGVkIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyRm9ySW5pdGlhbGl6YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JJbml0aWFsaXphdGlvbihhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QoSU5JVElBTElaQVRJT05fTUVUSE9EX05BTUUsIGFkZGl0aW9uYWxDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgc3RyaW5nIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTWV0cmljIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgU3RyaW5nIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hTdHJpbmcobmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMucHVibGlzaChuZXcgX21ldHJpY09iamVjdC5TdHJpbmcobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgc3RyaW5nIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLCB0cnVuY2F0ZWQgdG8gdGhlIG1heGltdW0gc2l6ZSBhbGxvd2VkIGJ5IHRoZVxuICAgICAqIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIFN0cmluZyB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGlzaFN0cmluZ1RydW5jYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hTdHJpbmdUcnVuY2F0ZShuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG9iamVjdCA9IG5ldyBfbWV0cmljT2JqZWN0LlN0cmluZyhuYW1lLCB2YWx1ZSk7XG4gICAgICBvYmplY3QudHJ1bmNhdGUgPSB0cnVlO1xuICAgICAgdGhpcy5wdWJsaXNoKG9iamVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcHVibGlzaCBhIGNvdW50ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBDb3VudGVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoQ291bnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaXNoQ291bnRlcihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5ldyBfbWV0cmljT2JqZWN0LkNvdW50ZXIobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgdGltZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaW1lciB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGlzaFRpbWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hUaW1lcihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5ldyBfbWV0cmljT2JqZWN0LlRpbWVyKG5hbWUsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcHVibGlzaCBhIGNvdW50ZXIgd2l0aCB0aGUgaXNNb25pdG9yIGZsYWcgc2V0LCBhbmQgdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTWV0cmljIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgQ291bnRlciB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGlzaENvdW50ZXJNb25pdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hDb3VudGVyTW9uaXRvcihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5ldyBfbWV0cmljT2JqZWN0LkNvdW50ZXIobmFtZSwgdmFsdWUpLndpdGhNb25pdG9yKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSB0aW1lciB3aXRoIHRoZSBpc01vbml0b3IgZmxhZyBzZXQsIGFuZCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaW1lciB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGlzaFRpbWVyTW9uaXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaXNoVGltZXJNb25pdG9yKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IF9tZXRyaWNPYmplY3QuVGltZXIobmFtZSwgdmFsdWUpLndpdGhNb25pdG9yKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGhlbHBlciBtZXRob2QgdG8gZXh0cmFjdCBhbiBhY3Rpb25JZCBmcm9tIGEgY29udGV4dCBpZiBvbmUgaXMgcHJvdmlkZWQsIGFuZCBvdGhlcndpc2UgZ2VuZXJhdGUgYSBuZXcgb25lLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQWN0aW9uIElEIHN0cmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbmVyYXRlQWN0aW9uaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlQWN0aW9uaWQoY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IGdldENvbnRleHRGaWVsZHMoY29udGV4dCk7XG5cbiAgICAgICAgaWYgKGZpZWxkcy5hY3Rpb25JZCkge1xuICAgICAgICAgIHJldHVybiBmaWVsZHMuYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfdi5kZWZhdWx0KSgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNzUHVibGlzaGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY3NQdWJsaXNoZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRFRkFVTFRfRVJST1JfSEFORExFUiA9IHZvaWQgMDtcblxudmFyIERFRkFVTFRfRVJST1JfSEFORExFUiA9IGZ1bmN0aW9uIERFRkFVTFRfRVJST1JfSEFORExFUihlcnIpIHtcbiAgdGhyb3cgZXJyO1xufTtcblxuZXhwb3J0cy5ERUZBVUxUX0VSUk9SX0hBTkRMRVIgPSBERUZBVUxUX0VSUk9SX0hBTkRMRVI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGEgS2F0YWwgbWV0cmljcyBkcml2ZXIuXG4gKi9cbnZhciBLYXRhbE1ldHJpY3NEcml2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY3NEcml2ZXIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzRHJpdmVyKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlciwgW3tcbiAgICBrZXk6IFwicHVibGlzaFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggdGhlIGdpdmVuIG1ldHJpYyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgaGFuZGxlciBhbmQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRyaWNPYmplY3QgTWV0cmljIG9iamVjdCB0byBwdWJsaXNoLiAgQ29udGFpbnMgbWV0cmljS2V5LCBpc01vbml0b3IsIHR5cGUsIGFuZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gY29udGV4dCBDb250ZXh0IGZvciBwdWJsaXNoaW5nIHRoaXMgbWV0cmljLiAgQ29udGFpbnMgYWxsIG90aGVyIGZpZWxkcyB0byBiZSBwdWJsaXNoZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVibGlzaChtZXRyaWNPYmplY3QsIGNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2F0YWxNZXRyaWNzRHJpdmVyIGlzIGFuIGFic3RyYWN0IGNsYXNzLCBwbGVhc2UgY2hvb3NlIGEgZHJpdmVyIGFuZCB1c2UgdGhhdCBpbnN0ZWFkJyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY3NEcml2ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljc0RyaXZlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpcnN0TWFwO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IG5vbi11bmRlZmluZWQgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gcnVubmluZyBlYWNoIHZhbHVlXG4gKiBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhyb3VnaCB0aGUgbWFwcGVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIGFycmF5IEFuIGFycmF5IG9mIHZhbHVlcy5cbiAqIEBwYXJhbSBtYXBwZXIgQSBtYXBwZXIgZnVuY3Rpb24gdGhhdCBzaG91bGQgcmV0dXJuIGEgdmFsdWUgb3IgdW5kZWZpbmVkLlxuICogQHJldHVybnMgVGhlIGZpcnN0IG5vbi11bmRlZmluZWQgdmFsdWUgZnJvbSB0aGUgbWFwcGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmaXJzdE1hcChhcnJheSwgbWFwcGVyKSB7XG4gIHZhciB0b1JldHVybiA9IHVuZGVmaW5lZDtcbiAgYXJyYXkuc29tZShmdW5jdGlvbiAodmFsKSB7XG4gICAgdG9SZXR1cm4gPSBtYXBwZXIodmFsKTtcbiAgICByZXR1cm4gdG9SZXR1cm4gIT0gbnVsbDtcbiAgfSk7XG4gIHJldHVybiB0b1JldHVybjtcbn1cblxuOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIG9iamVjdFZhbHVlcyA9IE9iamVjdC52YWx1ZXMgPyBPYmplY3QudmFsdWVzIDogZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59O1xudmFyIF9kZWZhdWx0ID0gb2JqZWN0VmFsdWVzO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGVTaW1wbGVJbnQ7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxuLyoqXG4gKiBOdW1iZXIuaXNJbnRlZ2VyIGlzIG5vdCBpbiBJRTExLCBhbmQgbGV0dGluZyBCYWJlbCBwb2x5ZmlsbCBpdCBhZGRlZCB0b28gbXVjaCB3ZWlnaHQuXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzSW50ZWdlclxuICovXG52YXIgaXNJbnRlZ2VyID0gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbCkge1xuICByZXR1cm4gaXNGaW5pdGUodmFsKSAmJiBNYXRoLmZsb29yKHZhbCkgPT09IHZhbDtcbn07XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB2YWxpZCB0byBiZSBwdWJsaXNoZWQgdG8gS2F0YWxNZXRyaWNzIGFzIGFuIGludGVnZXIgKENvdW50ZXIgb3IgVGltZXIpLFxuICogYW5kIHJldHVybiBlaXRoZXIgdW5kZWZpbmVkIChubyBlcnJvciksIG9yIGFuIEVycm9yIG9iamVjdCBkZXNjcmliaW5nIHRoZSBwcm9ibGVtLlxuICpcbiAqIEBwYXJhbSB2YWwgVmFsdWUgdG8gY2hlY2tcbiAqIEBwYXJhbSBuYW1lRm9yRXJyb3IgTmFtZSB0byB1c2Ugd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIG5lY2Vzc2FyeVxuICogQHJldHVybnMgRXJyb3IsIG9yIHVuZGVmaW5lZCBpZiBubyBlcnJvclxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVTaW1wbGVJbnQodmFsLCBuYW1lRm9yRXJyb3IpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGhhdmUgdHlwZSAnbnVtYmVyJywgYnV0IGl0IHdhcyB0eXBlICdcIikuY29uY2F0KCgwLCBfdHlwZW9mMi5kZWZhdWx0KSh2YWwpLCBcIidcIikpO1xuICB9XG5cbiAgaWYgKHZhbCA8IDApIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gYmUgcG9zaXRpdmUsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWwpKTtcbiAgfSAvLyBUaGlzIHdpbGwgYWxzbyBjYXRjaCBOYU4gYW5kIEluZmluaXR5XG5cblxuICBpZiAoIWlzSW50ZWdlcih2YWwpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIGFuIGludGVnZXIsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWwpKTtcbiAgfSAvLyBDb3VsZG4ndCBmaW5kIGFueXRoaW5nIHdyb25nLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxufVxuXG47IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGVTaW1wbGVTdHJpbmc7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIFNJTVBMRV9TVFJJTkdfUEFUID0gL15bQS1aYS16MC05LjpAXy8tXSskLztcbnZhciBTSU1QTEVfU1RSSU5HX01BWF9MRU4gPSAxMjc7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB2YWxpZCB0byBiZSBwdWJsaXNoZWQgdG8gS2F0YWxNZXRyaWNzIGFzIGEgZmllbGQgdmFsdWUsXG4gKiBzdWNoIGFzIHNpdGUsIHNlcnZpY2VOYW1lLCBtZXRob2ROYW1lLCBvciBhY3Rpb25JZCAobm90ZSB0aGlzIGlzIG5vdCB1c2VkIHRvIGNoZWNrIHZhbHVlcyBmb3Igc3RyaW5nIG1ldHJpY3MpLlxuICogSXQgcmV0dXJucyBlaXRoZXIgdW5kZWZpbmVkIChubyBlcnJvciksIG9yIGFuIEVycm9yIG9iamVjdCBkZXNjcmliaW5nIHRoZSBwcm9ibGVtLlxuICpcbiAqIFRvIGJlIHB1Ymxpc2hlZCwgaXQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcsIGxlc3MgdGhhbiAyNTYgY2hhcmFjdGVycywgY29udGFpbmluZyBvbmx5IEFTQ0lJXG4gKiBsZXR0ZXJzLCBudW1iZXJzLCBvciB0aGVzZSBjaGFyYWN0ZXJzOiAuOkBfLy0gKHRob3NlIGFyZSB0aGUgUE1FVCBmaWVsZCB2YWx1ZSByZXF1aXJlbWVudHMpLlxuICpcbiAqIEBwYXJhbSB2YWwgU3RyaW5nIHZhbHVlIHRvIGNoZWNrXG4gKiBAcGFyYW0gbmFtZUZvckVycm9yIE5hbWUgdG8gdXNlIGluIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBvbmUgaXMgZ2VuZXJhdGVkXG4gKiBAcmV0dXJucyBFcnJvciwgb3IgdW5kZWZpbmVkIGlmIG5vIGVycm9yXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVTaW1wbGVTdHJpbmcodmFsLCBuYW1lRm9yRXJyb3IpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gYmUgYSBzdHJpbmcsIGJ1dCBpdCB3YXMgYSBcIikuY29uY2F0KCgwLCBfdHlwZW9mMi5kZWZhdWx0KSh2YWwpKSk7XG4gIH1cblxuICBpZiAodmFsLmxlbmd0aCA+IFNJTVBMRV9TVFJJTkdfTUFYX0xFTikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBiZSBsZXNzIHRoYW4gXCIpLmNvbmNhdChTSU1QTEVfU1RSSU5HX01BWF9MRU4sIFwiIGNoYXJhY3RlcnMsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWwubGVuZ3RoLCBcIiBjaGFyYWN0ZXJzXCIpKTtcbiAgfVxuXG4gIGlmICh2YWwubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBiZSBub24tYmxhbmtcIikpO1xuICB9XG5cbiAgaWYgKCFTSU1QTEVfU1RSSU5HX1BBVC50ZXN0KHZhbCkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gY29udGFpbiBvbmx5IHZhbGlkIGNoYXJhY3RlcnMsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWwsIFwiLiAgSXQgY2FuIG9ubHkgY29udGFpbiBsZXR0ZXJzLCBudW1iZXJzLCBhbmQgdGhlc2Ugc3ltYm9sczogLjpAXy8tXCIpKTtcbiAgfSAvLyBDb3VsZG4ndCBmaW5kIGFueXRoaW5nIHdyb25nLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5lbWJlZFJlcXVlc3RJZCA9IGVtYmVkUmVxdWVzdElkO1xuXG4vLyB1bnRpbCB3ZSBjYW4gYWRkIGEgcmVxdWVzdElkIGZpZWxkIHRvIHRoZSBhbmRlcyBzY2hlbWEgd2Ugd2lsbCBlbWJlZCBpdCBpbiB0aGUgYWN0aW9uSWRcbmZ1bmN0aW9uIGVtYmVkUmVxdWVzdElkKGFjdGlvbklkLCByZXF1ZXN0SWQpIHtcbiAgaWYgKHJlcXVlc3RJZCkge1xuICAgIHJldHVybiBbcmVxdWVzdElkLCBhY3Rpb25JZF0uam9pbihcIjo6XCIpO1xuICB9XG5cbiAgcmV0dXJuIGFjdGlvbklkO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWVyZ2VMaXN0cyA9IG1lcmdlTGlzdHM7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheVwiKSk7XG5cbi8vIEhlbHBlciBtZXRob2QgdG8gbWVyZ2UgdHdvIGxpc3RzIHdoaWNoIGNvdWxkIGJlIHVuZGVmaW5lZFxuLy8gUmV0dXJucyBtZXJnZWQgbGlzdHMgaWYgZWl0aGVyIGlzIGRlZmluZWQsIG90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZFxuZnVuY3Rpb24gbWVyZ2VMaXN0cyhsaXN0MSwgbGlzdDIpIHtcbiAgaWYgKGxpc3QxIHx8IGxpc3QyKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShsaXN0MSB8fCBbXSksICgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKGxpc3QyIHx8IFtdKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG47IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRpc3BhdGNoTWV0cmljRXZlbnQgPSBkaXNwYXRjaE1ldHJpY0V2ZW50O1xuXG4vKipcbiAqIFB1Ymxpc2ggdG8gZXh0ZXJuYWwgcGFydGllcyB0aGF0IGFyZSBcbiAqIGxpc3RlbmluZyBmb3Iga2F0YWwubWV0cmljcy5wdWJsaXNoIEN1c3RvbSBFdmVudHNcbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hNZXRyaWNFdmVudChtZXRyaWMsIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlzcGF0Y2hDdXN0b21FdmVudChtZXRyaWMsIGNvbnRleHQpOyAvLyBmb3IgbGVnYWN5IHB1cnBvc2VzLCBhbHNvIHB1Ymxpc2ggdG8gX19LQVRBTF9NRVRSSUNTX0VYVEVOU0lPTl9fXG5cbiAgcHVibGlzaFRvTWV0cmljc0V4dGVuc2lvbihtZXRyaWMsIGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEN1c3RvbUV2ZW50KG1ldHJpYywgY29udGV4dCkge1xuICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2thdGFsLm1ldHJpY3MucHVibGlzaCcsIHtcbiAgICBkZXRhaWw6IHtcbiAgICAgIG1ldHJpYzogbWV0cmljLFxuICAgICAgY29udGV4dDogY29udGV4dC5nZXRGaWVsZHMoKVxuICAgIH1cbiAgfSk7XG4gIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cbi8qKlxuICogQERlcHJlY2F0ZWRcbiAqIFB1Ymxpc2ggdG8gaHR0cHM6Ly9jb2RlLmFtYXpvbi5jb20vcGFja2FnZXMvS2F0YWxNZXRyaWNzRXh0ZW5zaW9uXG4gKiBUaGUgZXh0ZW5zaW9uIGluamVjdHMgYSBnbG9iYWwgX19LQVRBTF9NRVRSSUNTX0VYVEVOU0lPTl9fIG9iamVjdCB3aXRoIGFcbiAqIGBwdWJsaXNoYCBtZXRob2QuXG4gKi9cblxuXG5mdW5jdGlvbiBwdWJsaXNoVG9NZXRyaWNzRXh0ZW5zaW9uKG1ldHJpYywgY29udGV4dCkge1xuICB2YXIgZXh0ZW5zaW9uID0gd2luZG93Ll9fS0FUQUxfTUVUUklDU19FWFRFTlNJT05fXztcblxuICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgZXh0ZW5zaW9uLnB1Ymxpc2gobWV0cmljLCBjb250ZXh0LmdldEZpZWxkcygpKTtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRlQ2xvdWRXYXRjaERpbWVuc2lvbnM7XG5cbnZhciBfRmlyc3RNYXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0ZpcnN0TWFwXCIpKTtcblxudmFyIFBSSU5UQUJMRV9BU0NJSV9QQVRURVJOID0gL15bXFx4MjAtXFx4N0VdKyQvO1xudmFyIEFUX0xFQVNUX09ORV9OT05fV0hJVEVTUEFDRV9QQVRURVJOID0gL14uKlxcUysuKiQvO1xudmFyIERJTUVOU0lPTl9OQU1FX1NUUklOR19NQVhfTEVOID0gMjU1O1xudmFyIERJTUVOU0lPTl9WQUxVRV9TVFJJTkdfTUFYX0xFTiA9IDEwMjQ7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBkaW1lbnNpb25zIGFyZSB2YWxpZCB0byBiZSBwdWJsaXNoZWQgdG8gS2F0YWxNb25pdG9yaW5nIGJhY2stZW5kLlxuICogSXQgcmV0dXJucyBlaXRoZXIgdW5kZWZpbmVkIChubyBlcnJvciksIG9yIGFuIEVycm9yIG9iamVjdCBkZXNjcmliaW5nIHRoZSBwcm9ibGVtLlxuICpcbiAqIFRvIGJlIHB1Ymxpc2hlZCwgbmFtZSBhbmQgdmFsdWUgb2Ygc3RyaW5nIG1ldHJpY3MgbXVzdCBmb2xsb3cgcmVzdHJpY3Rpb25zIGFzIGRlc2NyaWJlZCBieVxuICogQ2xvdWRXYXRjaCBEaW1lbnNpb24gQVBJIERvY3VtZW50YXRpb246XG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uQ2xvdWRXYXRjaC9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9EaW1lbnNpb24uaHRtbFxuICpcbiAqIEBwYXJhbSBkaW1lbnNpb25zIEFycmF5IG9mIHN0cmluZyBtZXRyaWNzIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBFcnJvciwgb3IgdW5kZWZpbmVkIGlmIG5vIGVycm9yXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVDbG91ZFdhdGNoRGltZW5zaW9ucyhkaW1lbnNpb25zKSB7XG4gIHJldHVybiAoMCwgX0ZpcnN0TWFwLmRlZmF1bHQpKGRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW1lbnNpb24pIHtcbiAgICB2YXIgbmFtZSA9IGRpbWVuc2lvbi5uYW1lLFxuICAgICAgICB2YWx1ZSA9IGRpbWVuc2lvbi52YWx1ZTtcbiAgICByZXR1cm4gdmFsaWRhdGVDbG91ZFdhdGNoRGltZW5zaW9uKG5hbWUsIHZhbHVlKTtcbiAgfSk7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBkaW1lbnNpb24gaXMgdmFsaWQgYXMgZGVzY3JpYmVkIGJ5IENsb3VkV2F0Y2ggZG9jdW1lbnRhdGlvbi5cbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25DbG91ZFdhdGNoL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0RpbWVuc2lvbi5odG1sXG4gKlxuICogQHBhcmFtIG5hbWUgQ2xvdWRXYXRjaCBEaW1lbnNpb24gTmFtZSBTdHJpbmcgdG8gY2hlY2tcbiAqIEBwYXJhbSB2YWx1ZSBDbG91ZFdhdGNoIERpbWVuc2lvbiBWYWx1ZSBTdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm5zIEVycm9yLCBvciB1bmRlZmluZWQgaWYgbm8gZXJyb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2xvdWRXYXRjaERpbWVuc2lvbihuYW1lLCB2YWx1ZSkge1xuICBpZiAobmFtZS5sZW5ndGggPiBESU1FTlNJT05fTkFNRV9TVFJJTkdfTUFYX0xFTikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gbmFtZSBmb3IgdmFsdWUgXCIuY29uY2F0KHZhbHVlLCBcIiB0byBiZSBcIikuY29uY2F0KERJTUVOU0lPTl9OQU1FX1NUUklOR19NQVhfTEVOLCBcIiBjaGFyYWN0ZXJzIG9yIGxlc3MsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdChuYW1lLmxlbmd0aCwgXCIgY2hhcmFjdGVyc1wiKSk7XG4gIH1cblxuICBpZiAobmFtZS5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIERpbWVuc2lvbiBuYW1lIGZvciB2YWx1ZSBcIi5jb25jYXQodmFsdWUsIFwiIHRvIGJlIG5vbi1ibGFua1wiKSk7XG4gIH1cblxuICBpZiAoIVBSSU5UQUJMRV9BU0NJSV9QQVRURVJOLnRlc3QobmFtZSkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIG5hbWUgZm9yIHZhbHVlIFwiLmNvbmNhdCh2YWx1ZSwgXCIgdG8gY29udGFpbiBvbmx5IEFTQ0lJIGNoYXJhY3RlcnMsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdChuYW1lKSk7XG4gIH1cblxuICBpZiAoIUFUX0xFQVNUX09ORV9OT05fV0hJVEVTUEFDRV9QQVRURVJOLnRlc3QobmFtZSkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIG5hbWUgZm9yIHZhbHVlIFwiLmNvbmNhdCh2YWx1ZSwgXCIgdG8gY29udGFpbiBhdCBsZWFzdCBvbmUgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyLCBidXQgaXQgd2FzIFwiKS5jb25jYXQobmFtZSkpO1xuICB9XG5cbiAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIjpcIikpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIG5hbWUgZm9yIHZhbHVlIFwiLmNvbmNhdCh2YWx1ZSwgXCIgdG8gbm90IHN0YXJ0IHdpdGggYSBjb2xvbiAoXFxcIjpcXFwiKSwgYnV0IGl0IHdhcyBcIikuY29uY2F0KG5hbWUpKTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5sZW5ndGggPiBESU1FTlNJT05fVkFMVUVfU1RSSU5HX01BWF9MRU4pIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIHZhbHVlIGZvciBuYW1lIFwiLmNvbmNhdChuYW1lLCBcIiB0byBiZSBcIikuY29uY2F0KERJTUVOU0lPTl9WQUxVRV9TVFJJTkdfTUFYX0xFTiwgXCIgY2hhcmFjdGVycyBvciBsZXNzLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsdWUubGVuZ3RoLCBcIiBjaGFyYWN0ZXJzXCIpKTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIERpbWVuc2lvbiB2YWx1ZSBmb3IgbmFtZSBcIi5jb25jYXQobmFtZSwgXCIgdG8gYmUgbm9uLWJsYW5rXCIpKTtcbiAgfVxuXG4gIGlmICghUFJJTlRBQkxFX0FTQ0lJX1BBVFRFUk4udGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIHZhbHVlIGZvciBuYW1lIFwiLmNvbmNhdChuYW1lLCBcIiB0byBjb250YWluIG9ubHkgQVNDSUkgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbHVlKSk7XG4gIH1cblxuICBpZiAoIUFUX0xFQVNUX09ORV9OT05fV0hJVEVTUEFDRV9QQVRURVJOLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIERpbWVuc2lvbiB2YWx1ZSBmb3IgbmFtZSBcIi5jb25jYXQobmFtZSwgXCIgdG8gY29udGFpbiBhdCBsZWFzdCBvbmUgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsdWUsIFwifVwiKSk7XG4gIH0gLy8gQ291bGRuJ3QgZmluZCBhbnl0aGluZyB3cm9uZywgaW1wbGljaXRseSByZXR1cm4gdW5kZWZpbmVkXG5cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xvdWRXYXRjaERpbWVuc2lvbnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Nsb3VkV2F0Y2hEaW1lbnNpb25zLkNsb3VkV2F0Y2hEaW1lbnNpb25zO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRleHRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckhhbmRsZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Vycm9ySGFuZGxlci5FcnJvckhhbmRsZXI7XG4gIH1cbn0pO1xuZXhwb3J0cy5NZXRyaWMgPSB2b2lkIDA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXRyaWNzRHJpdmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY3NEcml2ZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQdWJsaXNoZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljc1B1Ymxpc2hlci5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIE1ldHJpYyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL21ldHJpY09iamVjdFwiKSk7XG5cbmV4cG9ydHMuTWV0cmljID0gTWV0cmljO1xuXG52YXIgX0thdGFsTWV0cmljc1B1Ymxpc2hlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNzUHVibGlzaGVyXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY3NDb250ZXh0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY3NDb250ZXh0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY3NEcml2ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2RyaXZlci9LYXRhbE1ldHJpY3NEcml2ZXJcIikpO1xuXG52YXIgX0Vycm9ySGFuZGxlciA9IHJlcXVpcmUoXCIuL2RyaXZlci9FcnJvckhhbmRsZXJcIik7XG5cbnZhciBfQ2xvdWRXYXRjaERpbWVuc2lvbnMgPSByZXF1aXJlKFwiLi90eXBlcy9DbG91ZFdhdGNoRGltZW5zaW9uc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY09iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljT2JqZWN0XCIpKTtcblxudmFyIF9WYWxpZGF0ZVNpbXBsZUludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlci9WYWxpZGF0ZVNpbXBsZUludFwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIENvdW50ZXIgdHlwZS5cbiAqXG4gKiBDYW4gYmUgdXNlZCB0byBjb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIGFuIGV2ZW50IGhhcHBlbmVkIG9uIGEgcGFnZSwgb3IgYXMgYSBzaW1wbGUgMS8wIGNvdW50ZXIgdG8gdHJhY2tcbiAqIHN1Y2Nlc3MgYW5kIGZhaWx1cmUuXG4gKi9cbnZhciBLYXRhbE1ldHJpY0NvdW50ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY0NvdW50ZXIsIF9LYXRhbE1ldHJpY09iamVjdCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihLYXRhbE1ldHJpY0NvdW50ZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY291bnRlciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgQ291bnRlciBuYW1lXG4gICAqIEBwYXJhbSB2YWx1ZSBDb3VudGVyIHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY0NvdW50ZXIobmFtZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY0NvdW50ZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoaXMgY291bnRlclxuICAgKlxuICAgKiBAcmV0dXJuIENvdW50ZXIgdmFsdWVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY0NvdW50ZXIsIFt7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIG5ldyB2YWx1ZSBmb3IgdGhpcyBjb3VudGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGlzIGNvdW50ZXJcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIC8vIE1hdGgucm91bmQgd2lsbCBhbHNvIGNvZXJjZSBmcm9tIGEgc3RyaW5nIGlmIG5lY2Vzc2FyeSwgYW5kIHJldHVybiBOYU4gaWYgaW52YWxpZFxuICAgICAgdGhpcy5fdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdHlwZSBmb3IgdGhpcyBjb3VudGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBcIkNvdW50ZXJcIi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuQ291bnRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbnVtYmVyIHRvIHRoaXMgY291bnRlci5cbiAgICAgKlxuICAgICAqIENhbiBhbHNvIGJlIG5lZ2F0aXZlIHRvIHN1YnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZFZhbHVlIEFtb3VudCB0byBhZGQgdG8gdGhpcyBjb3VudGVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGFkZFZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlICs9IGFkZFZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5Nb25pdG9yXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGlvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIHZhciBzdXBlckVycm9yID0gKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlci5wcm90b3R5cGUpLCBcInZhbGlkYXRpb25FcnJvclwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHN1cGVyRXJyb3IpIHJldHVybiBzdXBlckVycm9yO1xuICAgICAgcmV0dXJuICgwLCBfVmFsaWRhdGVTaW1wbGVJbnQuZGVmYXVsdCkodGhpcy52YWx1ZSwgXCJmaWVsZCB2YWx1ZSBpbiBDb3VudGVyIG1ldHJpY3Mgb2JqZWN0ICdcIi5jb25jYXQodGhpcy5uYW1lLCBcIidcIikpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNDb3VudGVyO1xufShfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY0NvdW50ZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1N0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIFN0YW5kYXJkaXplZCBtZXRyaWMgZm9yIGluc3RydW1lbnRpbmcgSFRUUCByZXF1ZXN0cy5cbiAqXG4gKiBVbmRlciB0aGUgaG9vZCBpdCBpcyBhIEthdGFsTWV0cmljVGltZWRBdHRlbXB0IHdpdGggdGhlIG5hbWUgeW91IHByb3ZpZGUgcHJlZml4ZWQgd2l0aCBcIkhUVFBSZXF1ZXN0LlwiLlxuICogVGhhdCBvYmplY3Qgd2lsbCBjb250YWluIGEgbWV0cmljIHN1ZmZpeGVkIHdpdGggXCIuTGF0ZW5jeVwiIGZvciB0aGUgbGF0ZW5jeSBvZiB0aGlzIHJlcXVlc3QsIGFuZCBhIG1ldHJpYyBzdWZmaXhlZFxuICogd2l0aCBcIi5GYWlsdXJlXCIgdG8gcmVjb3JkIHRoZSBmYWlsdXJlIG9yIHN1Y2Nlc3Mgb2YgdGhpcyByZXF1ZXN0LlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhlIHJlcXVlc3Qgd2lsbCBiZSB0cmFja2VkIGFzIGEgZmFpbHVyZTsgdG8gbWFyayBpdCBhcyBhIHN1Y2Nlc3MgY2FsbCB0aGUgXCJzZXRTdWNjZXNzKClcIiBtZXRob2QuXG4gKlxuICogSXQgaGFzIGFkZGl0aW9uYWwgcHJvcGVydGllcyB3aGljaCB3aWxsIGJlIGVtaXR0ZWQgaWYgc2V0OyBzZWUgdXJsLCBzdGF0dXNDb2RlLCBhbmQgc3RhdHVzVGV4dC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IGdhdmUgdGhlIG5hbWUgXCJTZWFyY2hcIiwgdGhlc2UgbWV0cmljcyB3aWxsIGJlIGNyZWF0ZWQ6XG4gKiAgIEhUVFBSZXF1ZXN0LlNlYXJjaC5MYXRlbmN5IC0gTGF0ZW5jeSBmb3IgdGhpcyByZXF1ZXN0XG4gKiAgIEhUVFBSZXF1ZXN0LlNlYXJjaC5GYWlsdXJlIC0gRmFpbHVyZSBmb3IgdGhpcyByZXF1ZXN0ICgxIGZvciBmYWlsdXJlLCAwIGZvciBzdWNjZXNzKVxuICovXG52YXIgS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0thdGFsTWV0cmljVGltZWRBdHRlKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0KTtcblxuICAvKiogVGhlIHByZWZpeCBmb3IgdGhpcyBtZXRyaWMuICovXG5cbiAgLyoqIFRoZSBzdWZmaXggZm9yIFVSTCBtZXRyaWNzIG9mIHRoaXMgY2xhc3MuICovXG5cbiAgLyoqIFRoZSBzdWZmaXggZm9yIEhUVFAgcmVzcG9uc2UgY29kZSBtZXRyaWNzIG9mIHRoaXMgY2xhc3MuICovXG5cbiAgLyoqIFRoZSBzdWZmaXggZm9yIEhUVFAgcmVzcG9uc2UgdGV4dCBtZXRyaWNzIG9mIHRoaXMgY2xhc3MuICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBIVFRQIFJlcXVlc3QgdGltZWQgYXR0ZW1wdCBtZXRyaWMgaW5jb3Jwb3JhdGluZyB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogVGhlIG5hbWUgeW91IGdpdmUgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIEthdGFsTWV0cmljVGltZWRBdHRlbXB0IHdpdGggdGhlIHByb3ZpZGVkIG5hbWUgcHJlZml4ZWQgd2l0aCBcIkhUVFBSZXF1ZXN0LlwiLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoaXMgbWV0cmljOyByZXN1bHRpbmcgbWV0cmljcyB3aWxsIHByZWZpeCB0aGlzIG5hbWUgd2l0aCBcIkhUVFBSZXF1ZXN0LlwiXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0KG5hbWUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0KTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJcIi5jb25jYXQoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5IVFRQX1JFUVVFU1RfUFJFRklYLCBcIi5cIikuY29uY2F0KG5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB1cmwgZm9yIHRoaXMgbWV0cmljLlxuICAgKlxuICAgKiBBIHN0cmluZyBtZXRyaWMgd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlzdCBvZiBvYmplY3RzIHRoYXQgd2lsbCBiZSBwdWJsaXNoZWQgZm9yIHRoaXMgbWV0cmljLiAgSXRzIG5hbWUgd2lsbFxuICAgKiBiZSB0aGlzIG1ldHJpY3MgbmFtZSBzdWZmaXhlZCB3aXRoICcuVVJMJywgYW5kIGl0cyB2YWx1ZSB3aWxsIGJlIHRoZSBVUkwgdmFsdWUgZ2l2ZW4gaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIFVSTCBmb3IgdGhpcyBtZXRyaWNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBbe1xuICAgIGtleTogXCJ1cmxcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBVUkwgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBUaGUgVVJMIGZvciB0aGlzIG1ldHJpYywgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlVSTF9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFVSTCBtZXRyaWMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBVUkwgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlVSTF9TVUZGSVgsIF9LYXRhbE1ldHJpY1N0cmluZy5kZWZhdWx0LCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVybE1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5VUkxfU1VGRklYKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIEEgc3RyaW5nIG1ldHJpYyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBsaXN0IG9mIG9iamVjdHMgdGhhdCB3aWxsIGJlIHB1Ymxpc2hlZCBmb3IgdGhpcyBtZXRyaWMuICBJdHMgbmFtZSB3aWxsXG4gICAgICogYmUgdGhpcyBtZXRyaWNzIG5hbWUgc3VmZml4ZWQgd2l0aCAnLlN0YXR1c0NvZGUnLCBhbmQgaXRzIHZhbHVlIHdpbGwgYmUgdGhlIHN0YXR1cyBjb2RlIHZhbHVlIGdpdmVuIGhlcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBmb3IgdGhpcyBtZXRyaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXR1c0NvZGVcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGZvciB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlIG1ldHJpYyBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljVmFsdWUoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfQ09ERV9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgbWV0cmljIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBtZXRyaWMsIGlmIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19DT0RFX1NVRkZJWCwgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdHVzQ29kZU1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfQ09ERV9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIHRleHQgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQSBzdHJpbmcgbWV0cmljIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyB0aGF0IHdpbGwgYmUgcHVibGlzaGVkIGZvciB0aGlzIG1ldHJpYy4gIEl0cyBuYW1lIHdpbGxcbiAgICAgKiBiZSB0aGlzIG1ldHJpY3MgbmFtZSBzdWZmaXhlZCB3aXRoICcuU3RhdHVzVGV4dCcsIGFuZCBpdHMgdmFsdWUgd2lsbCBiZSB0aGUgc3RhdHVzIHRleHQgdmFsdWUgZ2l2ZW4gaGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXNUZXh0IEhUVFAgcmVzcG9uc2Ugc3RhdHVzIHRleHQgZm9yIHRoaXMgbWV0cmljLCBvciB1bmRlZmluZWQgdG8gcmVtb3ZlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGF0dXNUZXh0XCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgdGV4dCBmb3IgdGhpcyBtZXRyaWMsIGlmIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFzc29jaWF0ZWQgSFRUUCByZXNwb25zZSBzdGF0dXMgdGV4dCBtZXRyaWMgb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuU1RBVFVTX1RFWFRfU1VGRklYKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGZvciB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IG1ldHJpYyBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRPckRlbGV0ZU5hbWVkTWV0cmljVmFsdWUoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfVEVYVF9TVUZGSVgsIF9LYXRhbE1ldHJpY1N0cmluZy5kZWZhdWx0LCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXR1c1RleHRNZXRyaWNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuU1RBVFVTX1RFWFRfU1VGRklYKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljSHR0cFJlcXVlc3Q7XG59KF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNIdHRwUmVxdWVzdDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIFwiSFRUUF9SRVFVRVNUX1BSRUZJWFwiLCAnSFRUUFJlcXVlc3QnKTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIFwiVVJMX1NVRkZJWFwiLCAnVVJMJyk7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBcIlNUQVRVU19DT0RFX1NVRkZJWFwiLCAnU3RhdHVzQ29kZScpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgXCJTVEFUVVNfVEVYVF9TVUZGSVhcIiwgJ1N0YXR1c1RleHQnKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZWRBdHRlbXB0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdFwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIFN0YW5kYXJkaXplZCBtZXRyaWMgZm9yIGluc3RydW1lbnRpbmcgYXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb24uXG4gKlxuICogVW5kZXIgdGhlIGhvb2QgaXQgaXMgYSBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCB3aXRoIHRoZSBuYW1lIFwiSW5pdGlhbGl6YXRpb25cIi5cbiAqIFRoYXQgb2JqZWN0IHdpbGwgY29udGFpbiBhIG1ldHJpYyBzdWZmaXhlZCB3aXRoIFwiLkxhdGVuY3lcIiBmb3IgdGhlIGxhdGVuY3kgb2YgdGhpcyByZXF1ZXN0LCBhbmQgYSBtZXRyaWMgc3VmZml4ZWRcbiAqIHdpdGggXCIuRmFpbHVyZVwiIHRvIHJlY29yZCB0aGUgZmFpbHVyZSBvciBzdWNjZXNzIG9mIHRoaXMgcmVxdWVzdC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSByZXF1ZXN0IHdpbGwgYmUgdHJhY2tlZCBhcyBhIGZhaWx1cmU7IHRvIG1hcmsgaXQgYXMgYSBzdWNjZXNzIGNhbGwgdGhlIFwic2V0U3VjY2VzcygpXCIgbWV0aG9kLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZXNlIG1ldHJpY3Mgd2lsbCBiZSBjcmVhdGVkOlxuICogICBJbml0aWFsaXphdGlvbi5MYXRlbmN5IC0gTGF0ZW5jeSBmb3IgYXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb25cbiAqICAgSW5pdGlhbGl6YXRpb24uRmFpbHVyZSAtIEZhaWx1cmUgZm9yIHRoaXMgYXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb24gKDEgZm9yIGZhaWx1cmUsIDAgZm9yIHN1Y2Nlc3MpXG4gKi9cbnZhciBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNUaW1lZEF0dGUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbiwgX0thdGFsTWV0cmljVGltZWRBdHRlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24pO1xuXG4gIC8qKiBUaGUgbmFtZSBmb3IgdGhpcyBtZXRyaWMuICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0aW1lZCBhdHRlbXB0IG1ldHJpYyBuYW1lZCBcIkluaXRpYWxpemF0aW9uXCIsIGZvciByZWNvcmRpbmcgbGF0ZW5jeSBhbmQgZmFpbHVyZSBpbmZvcm1hdGlvbiBhYm91dFxuICAgKiB5b3VyIGFwcGxpY2F0aW9uJ3MgaW5pdGlhbGl6YXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24pO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLklOSVRJQUxJWkVfTUVUUklDX05BTUUpO1xuICB9XG5cbiAgcmV0dXJuIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb247XG59KF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbjtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24sIFwiSU5JVElBTElaRV9NRVRSSUNfTkFNRVwiLCAnSW5pdGlhbGl6YXRpb24nKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0TGlzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RMaXN0XCIpKTtcblxudmFyIF9PYmplY3RWYWx1ZXNQb255ZmlsbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlci9PYmplY3RWYWx1ZXNQb255ZmlsbFwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIE1ldHJpYyBvYmplY3QgbGlzdCB0aGF0IHRyYWNrcyBtZXRyaWNzIGJ5IG5hbWUsIGFuZCBnZW5lcmF0ZXMgbWV0cmljcyBwcmVmaXhlZCB3aXRoIHRoZSBuYW1lIG9mIHRoaXMgb2JqZWN0LlxuICovXG52YXIgS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdExpcykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCwgX0thdGFsTWV0cmljT2JqZWN0TGlzKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG5hbWVkIG9iamVjdCBsaXN0LlxuICAgKlxuICAgKiBUaGUgbmFtZSBnaXZlbiBoZXJlIHdpbGwgYmUgdXNlZCB0byBwcmVmaXggYWxsIG1ldHJpY3MuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhpcyBtZXRyaWNcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0KG5hbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICBfdGhpcy5uYW1lZE1ldHJpY3MgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCwgW3tcbiAgICBrZXk6IFwibWV0cmljTGlzdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICgwLCBfT2JqZWN0VmFsdWVzUG9ueWZpbGwuZGVmYXVsdCkodGhpcy5uYW1lZE1ldHJpY3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHRoZSBtZXRyaWMgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB3aXRoIGEgbmV3IG1ldHJpYyBnZW5lcmF0ZWQgYnkgdGhlIGdpdmVuIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhlIG5ld2x5IGNyZWF0ZWQgbWV0cmljIHN1cHBvcnRzIG1vbml0b3JpbmcsIGl0cyBpc01vbml0b3IgZmxhZyB3aWxsIGJlIHNldCB0byB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICogaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgY29udGFpbmluZyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqIEBwYXJhbSBtZXRyaWNDcmVhdG9yIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBmdWxsIG5hbWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICogICAgICAgIGFuZCByZXR1cm5zIGEgbmV3bHkgY29uc3RydWN0ZWQgS2F0YWxNZXRyaWNPYmplY3Qgd2l0aCB0aGlzIG5hbWUgYW5kIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXROYW1lZE1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROYW1lZE1ldHJpYyhzdWJOYW1lLCBtZXRyaWNDcmVhdG9yKSB7XG4gICAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLmdldE5hbWVGb3JTdWJNZXRyaWMoc3ViTmFtZSk7XG4gICAgICB2YXIgbWV0cmljID0gbWV0cmljQ3JlYXRvcihmdWxsTmFtZSk7XG5cbiAgICAgIGlmIChtZXRyaWMuY2FuTW9uaXRvcikge1xuICAgICAgICBtZXRyaWMuaXNNb25pdG9yID0gdGhpcy5pc01vbml0b3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmFtZWRNZXRyaWNzW3N1Yk5hbWVdID0gbWV0cmljO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwsIGRlbGV0ZSB0aGUgbWV0cmljIHdpdGggdGhlIGdpdmUgbmFtZTsgb3RoZXJ3aXNlIGlmIHRoZSBnaXZlbiBuYW1lZFxuICAgICAqIG1ldHJpYyBhbHJlYWR5IGV4aXN0cyB1cGRhdGUgaXRzIHZhbHVlOyBvdGhlcndpc2UgY3JlYXRlIGEgbmV3IG1ldHJpYyBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgc2V0IGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc3BlY2lhbGl6ZWQgaGVscGVyIG1ldGhvZCBpcyBkZXNpZ25lZCB0byBkZWFsIHdpdGggdGhlIGNvbW1vbiBjYXNlIG9mIGEgdmFsdWUgc2V0dGVyIGluIGEgbW9yZSBjb21wbGV4XG4gICAgICogbWV0cmljLiAgT3V0c2lkZSBvZiBzdWJjbGFzc2VzLCBvdGhlciBtZXRob2RzIHdpbGwgcHJvYmFibHkgcHJvdmUgbW9yZSB1c2VmdWwuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgbnVsbCB0aGUgbWV0cmljIHdpbGwgYWxzbyBiZSBkZWxldGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiBtZXRyaWMgdG8gY3JlYXRlIG9yIGRlbGV0ZVxuICAgICAqIEBwYXJhbSBuZXdWYWx1ZUNsYXNzIENsYXNzIG9mIG5ldyBtZXRyaWMgdG8gY3JlYXRlXG4gICAgICogQHBhcmFtIG5ld1ZhbHVlIE5ldyB2YWx1ZSBmb3IgdGhpcyBtZXRyaWMgKG9yIHVuZGVmaW5lZCB0byBkZWxldGUgdGhlIG1ldHJpYylcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPckRlbGV0ZU5hbWVkTWV0cmljVmFsdWUoc3ViTmFtZSwgbmV3VmFsdWVDbGFzcywgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5kZWxldGVOYW1lZE1ldHJpYyhzdWJOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtZXRyaWMgPSB0aGlzLmdldE9yQ3JlYXRlTmFtZWRNZXRyaWMoc3ViTmFtZSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG5ld1ZhbHVlQ2xhc3MobmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWV0cmljLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3ViLW1ldHJpYyB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHVzZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IG1ldHJpYyBhbmRcbiAgICAgKiBzdG9yZSBhbmQgcmV0dXJuIHRoYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqIEBwYXJhbSBtZXRyaWNDcmVhdG9yIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBmdWxsIG5hbWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICogICAgICAgIGFuZCByZXR1cm5zIGEgbmV3bHkgY29uc3RydWN0ZWQgS2F0YWxNZXRyaWNPYmplY3Qgd2l0aCB0aGlzIG5hbWUgYW5kIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG4gICAgICogQHJldHVybiBNZXRyaWMgb2JqZWN0IHdoaWNoIHdhcyByZXRyaWV2ZWQgb3IgY3JlYXRlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3JDcmVhdGVOYW1lZE1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPckNyZWF0ZU5hbWVkTWV0cmljKHN1Yk5hbWUsIG1ldHJpY0NyZWF0b3IpIHtcbiAgICAgIGlmICghdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV0pIHtcbiAgICAgICAgdGhpcy5zZXROYW1lZE1ldHJpYyhzdWJOYW1lLCBtZXRyaWNDcmVhdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubmFtZWRNZXRyaWNzW3N1Yk5hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGdpdmVuIG5hbWVkIHN1Yi1tZXRyaWMsIGlmIGl0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICogQHJldHVybiB7S2F0YWxNZXRyaWNPYmplY3QgfCB1bmRlZmluZWR9IE1ldHJpYyBvYmplY3Qgd2l0aCB0aGlzIG5hbWUgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lZE1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lZE1ldHJpYyhzdWJOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgZ2l2ZW4gbmFtZWQgc3ViLW1ldHJpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVOYW1lZE1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVOYW1lZE1ldHJpYyhzdWJOYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBtZXRyaWMsIG9yIHVuZGVmaW5lZCBpZiB0aGUgbWV0cmljIGRvZXMgbm90IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcmV0dXJuIFZhbHVlIGZvciB0aGUgZ2l2ZW4gbWV0cmljLCBvciB1bmRlZmluZWQgaWYgdGhlIG1ldHJpYyBkb2VzIG5vdCBleGlzdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmFtZWRNZXRyaWNWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lZE1ldHJpY1ZhbHVlKHN1Yk5hbWUpIHtcbiAgICAgIHZhciBtZXRyaWMgPSB0aGlzLmdldE5hbWVkTWV0cmljKHN1Yk5hbWUpO1xuICAgICAgaWYgKCFtZXRyaWMpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gbWV0cmljLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIG5hbWUgZm9yIHRoZSBnaXZlbiBzdWItbWV0cmljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcmV0dXJuIEZ1bGwgbmFtZSBmb3IgdGhpcyBzdWItbWV0cmljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lRm9yU3ViTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWVGb3JTdWJNZXRyaWMoc3ViTmFtZSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCIuXCIpLmNvbmNhdChzdWJOYW1lKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0O1xufShfS2F0YWxNZXRyaWNPYmplY3RMaXN0LmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9WYWxpZGF0ZVNpbXBsZVN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlci9WYWxpZGF0ZVNpbXBsZVN0cmluZ1wiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1R5cGVcIikpO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGEgc2luZ2xlIG1ldHJpYyBpbiBLYXRhbC5cbiAqXG4gKiBBIHNpbmdsZSBtZXRyaWMgY29udGFpbnMgdGhlIG5hbWUgKG1ldHJpY0tleSksIHZhbHVlLCB0eXBlLCBhbmQgdGhlIGlzTW9uaXRvciBmbGFnOyBldmVyeXRoaW5nIGVsc2UgaXMgaW4gdGhlXG4gKiBLYXRhbE1ldHJpY3NDb250ZXh0IGl0IGlzIHB1Ymxpc2hlZCB0by5cbiAqL1xudmFyIEthdGFsTWV0cmljT2JqZWN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIE1ldHJpYyB0eXBlcy5cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBLYXRhbE1ldHJpY09iamVjdCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGlzIG1ldHJpYzsgcHVibGlzaGVkIGFzIG1ldHJpY0tleSBmaWVsZFxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNPYmplY3QobmFtZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljT2JqZWN0KTtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLl9pc01vbml0b3IgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lIGZvciB0aGlzIG1ldHJpYy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBuYW1lIGlzIGltbXV0YWJsZSwgYW5kIHRoaXMgY2Fubm90IGJlIHNldC5cbiAgICpcbiAgICogQHJldHVybnMgTmFtZSBmb3IgdGhpcyBtZXRyaWNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdCwgW3tcbiAgICBrZXk6IFwibmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybnMgTmFtZSBmb3IgdGhpcyBtZXRyaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1ldHJpY0tleVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLCBhbmQgcmV0dXJucyB0aGlzIG9iamVjdCBmb3IgY29udGludWVkIHVzZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZmxhZyBkZXRlcm1pbmVzIGlmIHRoZSBtZXRyaWMgY2FuIGJlIHVzZWQgZm9yIGRhc2hib2FyZHMgYW5kIGFsYXJtcyAoaS5lLiBpZiBpdCB3aWxsIGJlIHB1Ymxpc2hlZCB0byBQTUVUKVxuICAgICAqIEBwYXJhbSBpc01vbml0b3IgTmV3IHZhbHVlIGZvciB0aGUgaXNNb25pdG9yIGZsYWc7IGRlZmF1bHRzIHRvIHRydWVcbiAgICAgKiBAcmV0dXJucyBUaGlzIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aE1vbml0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aE1vbml0b3IoKSB7XG4gICAgICB2YXIgaXNNb25pdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgdGhpcy5pc01vbml0b3IgPSBpc01vbml0b3I7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpc01vbml0b3IgZmxhZyBmb3IgdGhpcyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBUaGUgdmFsdWUgaXMgZm9yY2VkIHRvIGEgYm9vbGVhbiBiYXNlZCBvbiBpdHMgdHJ1dGhpbmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc01vbml0b3IgTmV3IHZhbHVlIGZvciB0aGUgaXNNb25pdG9yIGZsYWdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzTW9uaXRvclwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlzTW9uaXRvciBmbGFnIGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGlzTW9uaXRvciBmbGFnIGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNNb25pdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG1ldHJpYyBjYW4gYmUgbWVhbmluZ2Z1bGx5IG1vbml0b3JlZC5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzLlxuICAgICAqXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoaXMgbWV0cmljIGNhbiBiZSBtZWFuaW5nZnVsbHkgbW9uaXRvcmVkXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGlzTW9uaXRvcikge1xuICAgICAgdGhpcy5faXNNb25pdG9yID0gISFpc01vbml0b3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNPYmplY3QgbXVzdCBpbXBsZW1lbnQgY2FuTW9uaXRvcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFR5cGUgb2YgdGhpcyBtZXRyaWMgKG9uZSBvZjogU3RyaW5nLCBDb3VudGVyLCBUaW1lciwgTGlzdClcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNPYmplY3QgbXVzdCBpbXBsZW1lbnQgdHlwZSBnZXR0ZXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGEgdmFsaWRhdGlvbiBlcnJvciBvbiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbGlkYXRpb24gZXJyb3IgZW5jb3VudGVyZWQgaWYgb25lIGlzIGZvdW5kLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Vycm9yIHwgdW5kZWZpbmVkfSBFcnJvciBmb3VuZCB3aXRoIHRoaXMgb2JqZWN0LCBvciB1bmRlZmluZWQgaWYgbm8gZXJyb3IgaXMgZm91bmRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRpb25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICBpZiAodGhpcy5pc01vbml0b3IgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdGhpcy5pc01vbml0b3IgIT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRmllbGQgaXNNb25pdG9yIHNob3VsZCBiZSBhIGJvb2xlYW4sIGJ1dCBpdCB3YXMgYSBcIi5jb25jYXQoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHRoaXMuaXNNb25pdG9yKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF9WYWxpZGF0ZVNpbXBsZVN0cmluZy5kZWZhdWx0KSh0aGlzLm5hbWUsICdmaWVsZCBuYW1lJyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY09iamVjdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNPYmplY3Q7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdCwgXCJUeXBlc1wiLCBfS2F0YWxNZXRyaWNUeXBlLmRlZmF1bHQpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX3NldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG52YXIgX0ZpcnN0TWFwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL0ZpcnN0TWFwXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0cmljIHRoYXQgY29udGFpbnMgYSBsaXN0IG9mIG90aGVyIG1ldHJpY3M7IHdoZW4gaXQgaXMgcHVibGlzaGVkLCB0aGUgbGlzdCBvZiBtZXRyaWNzIGlzIHJldHJpZXZlZCwgYW5kIGFsbFxuICogYXJlIHB1Ymxpc2hlZC5cbiAqL1xudmFyIEthdGFsTWV0cmljT2JqZWN0TGlzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdCwgX0thdGFsTWV0cmljT2JqZWN0KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljT2JqZWN0TGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBLYXRhbE1ldHJpY09iamVjdExpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgbWV0cmljLiAgTm90IHJlYWxseSB1c2VkLCBidXQgcHJlc2VudCBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBtZXRyaWNzLlxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNPYmplY3RMaXN0KG5hbWUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY09iamVjdExpc3QpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIGZvciB0aGlzIG9iamVjdFxuICAgKlxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBtZXRyaWNzIGZvciB0aGlzIG9iamVjdFxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdCwgW3tcbiAgICBrZXk6IFwibWV0cmljTGlzdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzcyBvZiBLYXRhbE1ldHJpY09iamVjdExpc3QgbXVzdCBpbXBsZW1lbnQgbWV0cmljTGlzdCBnZXR0ZXInKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNNb25pdG9yXCIsXG4gICAgZ2V0OiAvLyBUaGlzIGp1c3QgZGVsZWdhdGVzIHRvIHRoZSBzdXBlcmNsYXNzLCBidXQgaWYgd2Ugb3ZlcnJpZGUgdGhlIHNldHRlciB3aXRob3V0IG92ZXJyaWRpbmcgdGhlIGdldHRlclxuICAgIC8vIGdldHRpbmcgdGhlIHByb3BlcnR5IHdpbGwgYWx3YXlzIHJldHVybiB1bmRlZmluZWQuXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdExpc3QucHJvdG90eXBlKSwgXCJpc01vbml0b3JcIiwgdGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChpc01vbml0b3IpIHtcbiAgICAgICgwLCBfc2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdExpc3QucHJvdG90eXBlKSwgXCJpc01vbml0b3JcIiwgaXNNb25pdG9yLCB0aGlzLCB0cnVlKTtcbiAgICAgIHRoaXMubWV0cmljTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgaWYgKG1ldHJpYy5jYW5Nb25pdG9yKSB7XG4gICAgICAgICAgbWV0cmljLmlzTW9uaXRvciA9IGlzTW9uaXRvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0LlR5cGVzLkxpc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGFueSBvZiB0aGUgY29udGFpbmVkIG1ldHJpY3MgYXJlIGludmFsaWQsIHJldHVybiB0aGUgZmlyc3QgdmFsaWRhdGlvbiBlcnJvciBlbmNvdW50ZXJlZDsgb3RoZXJ3aXNlIHJldHVyblxuICAgICAqIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGlzbid0IGNhbGxlZCBieSB0aGUgcHVibGlzaGVyOyBpdCB2YWxpZGF0ZXMgZWFjaCBzdWItbWV0cmljIG9uIGl0cyBvd24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBFcnJvciBmb3VuZCB3aXRoIHN1Ym1ldHJpYywgaWYgYW55OyBlbHNlIHVuZGVmaW5lZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGlvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIC8vIERvZXNuJ3QgbWFrZSBzZW5zZSB0byBjaGVjayBzdXBlcmNsYXNzIGVycm9yIGhlcmUsIHNpbmNlIGl0IGlzIHRoZSBjb250YWluZWQgbWV0cmljcyB0aGF0IG1hdHRlci5cbiAgICAgIHJldHVybiAoMCwgX0ZpcnN0TWFwLmRlZmF1bHQpKHRoaXMubWV0cmljTGlzdCwgZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICByZXR1cm4gbWV0cmljLnZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY09iamVjdExpc3Q7XG59KF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljT2JqZWN0TGlzdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBTdHJpbmcgdHlwZS5cbiAqXG4gKiBDYW4gYmUgdXNlZCB0byBzdG9yZSBhcmJpdHJhcnkgc3RyaW5ncyBvZiBkYXRhLlxuICovXG52YXIgS2F0YWxNZXRyaWNTdHJpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1N0cmluZywgX0thdGFsTWV0cmljT2JqZWN0KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljU3RyaW5nKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgc3RyaW5nIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBTdHJpbmcgbmFtZVxuICAgKiBAcGFyYW0gdmFsdWUgU3RyaW5nIHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY1N0cmluZyhuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljU3RyaW5nKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwidHJ1bmNhdGVcIiwgZmFsc2UpO1xuICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN0cmluZyBtZXRyaWMuXG4gICAqXG4gICAqIEByZXR1cm4gVmFsdWUgZm9yIHRoaXMgbWV0cmljXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNTdHJpbmcsIFt7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgZm9yIHRoaXMgc3RyaW5nIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIFRoZSBuZXcgdmFsdWUgc2hvdWxkIGJlIGEgc3RyaW5nLCBidXQgbnVtYmVyIGFuZCBib29sZWFuIHR5cGVzIHdpbGwgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gc3RyaW5ncy5cbiAgICAgKiBGb3Igb3RoZXIgdHlwZXMsIGluY2x1ZGluZyB1bmRlZmluZWQgYW5kIG51bGwsIHRoZSB2YWx1ZSB3aWxsIGJlIGFjY2VwdGVkLCBidXQgd2lsbCBmYWlsIHZhbGlkYXRpb24gd2hlbiBwdWJsaXNoaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB2YWx1ZSBmb3IgdGhpcyBtZXRyaWNcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydW5jYXRpb24gZmxhZyBmb3IgdGhpcyBzdHJpbmcgbWV0cmljLlxuICAgICAqXG4gICAgICogSWYgc2V0LCB0aGUgdmFsdWUgaGVyZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdHJ1bmNhdGVkIHRvIHRoZSBtYXhpbXVtIHNpemUgYWxsb3dlZCBieSB0aGUgY3VycmVudCBzY2hlbWEuXG4gICAgICogT3RoZXJ3aXNlLCBzZW5kaW5nIGEgdmFsdWUgbGFyZ2VyIHRoYW4gYWxsb3dlZCB3aWxsIHJlc3VsdCBpbiBhIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVHJ1ZSB0byBhdXRvbWF0aWNhbGx5IHRydW5jYXRlIG1ldHJpY3MsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0eXBlIGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQWx3YXlzIHJldHVybnMgXCJTdHJpbmdcIi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0LlR5cGVzLlN0cmluZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIHN1cGVyRXJyb3IgPSAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNTdHJpbmcucHJvdG90eXBlKSwgXCJ2YWxpZGF0aW9uRXJyb3JcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGlmIChzdXBlckVycm9yKSByZXR1cm4gc3VwZXJFcnJvcjtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgZmllbGQgdmFsdWUgaW4gU3RyaW5nIG1ldHJpY3Mgb2JqZWN0ICdcIi5jb25jYXQodGhpcy5uYW1lLCBcIicgdG8gYmUgdHlwZSBzdHJpbmcsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodGhpcy52YWx1ZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID4gS2F0YWxNZXRyaWNTdHJpbmcuTUFYX1NJWkUpIHtcbiAgICAgICAgaWYgKHRoaXMudHJ1bmNhdGUpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5zdWJzdHJpbmcoMCwgS2F0YWxNZXRyaWNTdHJpbmcuTUFYX1NJWkUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBmaWVsZCB2YWx1ZSBpbiBTdHJpbmcgbWV0cmljcyBvYmplY3QgJ1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiJyB0byBiZSBcIikuY29uY2F0KEthdGFsTWV0cmljU3RyaW5nLk1BWF9TSVpFLCBcIiBjaGFyYWN0ZXJzIG9yIGxlc3MsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh0aGlzLnZhbHVlLmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIikpO1xuICAgICAgICB9XG4gICAgICB9IC8vIERpZG4ndCBmaW5kIGFueXRoaW5nIHdyb25nLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNTdHJpbmc7XG59KF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljU3RyaW5nO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNTdHJpbmcsIFwiTUFYX1NJWkVcIiwgMjU2KTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX0thdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNDb3VudGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY0NvdW50ZXJcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBNZXRyaWMgdGhhdCBwYWlycyBhIHRpbWVyIGFuZCBhIGZhaWx1cmUgY291bnRlciB0byByZWNvcmQgdGhlIHRpbWUgYW5kIHN0YXR1cyBvZiBhbiBhdHRlbXB0IHRvIGRvIHNvbWV0aGluZy5cbiAqL1xudmFyIEthdGFsTWV0cmljVGltZWRBdHRlbXB0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNOYW1lZE9iamUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQsIF9LYXRhbE1ldHJpY05hbWVkT2JqZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCk7XG5cbiAgLyoqIFRoZSBzdWItbWV0cmljIG5hbWUgZm9yIGxhdGVuY3kuICovXG5cbiAgLyoqIFRoZSBzdWItbWV0cmljIG5hbWUgZm9yIGZhaWx1cmUgY291bnQuICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0aW1lZCBhdHRlbXB0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogVGhpcyB3aWxsIGNyZWF0ZSB0d28gaW5uZXIgbWV0cmljcywgYSBLYXRhbE1ldHJpY0NvdW50ZXIgdGhhdCBoYXMgdGhlIGdpdmVuIG5hbWUgd2l0aCBcIi5GYWlsdXJlXCIgYXBwZW5kZWQsXG4gICAqIGFuZCBhIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2ggdGhhdCBoYXMgdGhlIGdpdmVuIG5hbWUgd2l0aCBcIi5MYXRlbmN5XCIgYXBwZW5kZWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhpcyBhdHRlbXB0XG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdChuYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSk7XG5cbiAgICBfdGhpcy5zZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5MQVRFTkNZX1NVRkZJWCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBuZXcgX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2guZGVmYXVsdChuYW1lKTtcbiAgICB9KTtcblxuICAgIF90aGlzLnNldE5hbWVkTWV0cmljKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LkZBSUxVUkVfU1VGRklYLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBfS2F0YWxNZXRyaWNDb3VudGVyLmRlZmF1bHQobmFtZSwgMSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgZmFpbHVyZSBjb3VudGVyIG1ldHJpYyBiYXNlZCBvbiB0aGUgZ2l2ZW4gZmFpbHVyZSBzdGF0dXMuXG4gICAqXG4gICAqIElmIGZhaWx1cmUgaXMgdHJ1ZSB0aGUgY291bnRlciB3aWxsIGhhdmUgYSB2YWx1ZSBvZiAxOyBpZiBpdCBpcyBmYWxzZSB0aGUgY291bnRlciB3aWxsIGhhdmUgYSB2YWx1ZSBvZiAwLlxuICAgKlxuICAgKiBAcGFyYW0gZmFpbHVyZSBXaGV0aGVyIHRoaXMgaXMgYSBmYWlsdXJlIG9yIG5vdDsgZGVmYXVsdCB0cnVlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQsIFt7XG4gICAga2V5OiBcInNldEZhaWx1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmFpbHVyZSgpIHtcbiAgICAgIHZhciBmYWlsdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgdmFyIGZhaWx1cmVDb3VudCA9IGZhaWx1cmUgPyAxIDogMDtcbiAgICAgIHZhciBtZXRyaWMgPSB0aGlzLmZhaWx1cmVNZXRyaWM7XG4gICAgICBtZXRyaWMudmFsdWUgPSBmYWlsdXJlQ291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmFpbHVyZSBzdGF0dXMgdG8gZmFsc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdWNjZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN1Y2Nlc3MoKSB7XG4gICAgICB0aGlzLnNldEZhaWx1cmUoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhdGVuY3kgbWV0cmljIHRvIHRoZSBnaXZlbiB2YWx1ZSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogTm90ZSB5b3UgZG9uJ3Qgbm9ybWFsbHkgaGF2ZSB0byBzZXQgdGhpcywgdGhlIHVuZGVybHlpbmcgbWV0cmljIGlzIGEgS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCB0aGF0IHdpbGwgc3RhcnRcbiAgICAgKiBhbmQgc3RvcCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhdGVuY3lNcyBMYXRlbmN5IGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TGF0ZW5jeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMYXRlbmN5KGxhdGVuY3lNcykge1xuICAgICAgdmFyIG1ldHJpYyA9IHRoaXMubGF0ZW5jeU1ldHJpYztcbiAgICAgIG1ldHJpYy52YWx1ZSA9IGxhdGVuY3lNcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0aW1lciBzdG9wd2F0Y2ggbWV0cmljIGZvciB0aGlzIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRpbWVyIHN0b3B3YXRjaCBtZXRyaWMgZm9yIHRoaXMgYXR0ZW1wdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGF0ZW5jeU1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuTEFURU5DWV9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZhaWx1cmUgY291bnRlciBtZXRyaWMgZm9yIHRoaXMgYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gRmFpbHVyZSBjb3VudGVyIG1ldHJpYyBmb3IgdGhpcyBldmVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFpbHVyZU1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuRkFJTFVSRV9TVUZGSVgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQ7XG59KF9LYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdC5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQ7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCwgXCJMQVRFTkNZX1NVRkZJWFwiLCAnTGF0ZW5jeScpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQsIFwiRkFJTFVSRV9TVUZGSVhcIiwgJ0ZhaWx1cmUnKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbnZhciBfVmFsaWRhdGVTaW1wbGVJbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVJbnRcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBUaW1lciB0eXBlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIHJlY29yZCBhIHRpbWUuICBUaGlzIGNsYXNzIHJlcXVpcmVzIGV4cGxpY2l0IHZhbHVlOyBzZWUgS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCBmb3IgYXV0b21hdGljXG4gKiB0aW1pbmcuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1RpbWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNPYmplY3QpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lciwgX0thdGFsTWV0cmljT2JqZWN0KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljVGltZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdGltZXIgbWV0cmljLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGUgbWV0cmljXG4gICAqIEBwYXJhbSB2YWx1ZSBUaW1lciB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljVGltZXIobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY1RpbWVyKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xuICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIGZvciB0aGlzIHRpbWVyXG4gICAqXG4gICAqIEByZXR1cm4gVGltZXIgdmFsdWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lciwgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyB0aW1lclxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB0aW1lciB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBNYXRoLnJvdW5kIHdpbGwgYWxzbyBjb2VyY2UgZnJvbSBhIHN0cmluZyBpZiBuZWNlc3NhcnksIGFuZCByZXR1cm4gTmFOIGlmIGludmFsaWRcblxuXG4gICAgICB0aGlzLl92YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgZm9yIHRoaXMgdGltZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyByZXR1cm5zIFwiVGltZXJcIi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuVGltZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIHN1cGVyRXJyb3IgPSAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lci5wcm90b3R5cGUpLCBcInZhbGlkYXRpb25FcnJvclwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHN1cGVyRXJyb3IpIHJldHVybiBzdXBlckVycm9yO1xuICAgICAgcmV0dXJuICgwLCBfVmFsaWRhdGVTaW1wbGVJbnQuZGVmYXVsdCkodGhpcy52YWx1ZSwgXCJmaWVsZCB2YWx1ZSBpbiBUaW1lciBtZXRyaWNzIG9iamVjdCAnXCIuY29uY2F0KHRoaXMubmFtZSwgXCInXCIpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljVGltZXI7XG59KF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljVGltZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3NldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFwiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUaW1lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZXJcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBTdWJjbGFzcyBvZiBLYXRhbE1ldHJpY1RpbWVyIHRoYXQgY2FuIGJlIHN0YXJ0ZWQgYW5kIHN0b3BwZWQsIGFuZCB3aWxsIHJlY29yZCB0aGUgZWxhcHNlZCB0aW1lIGJldHdlZW4gc3RhcnRpbmcgYW5kXG4gKiBzdG9wcGluZy4gIEJ5IGRlZmF1bHQgaXQgd2lsbCBzdGFydCB3aGVuIHRoZSBvYmplY3QgaXMgY3JlYXRlZCwgYW5kIHN0b3BwZWQgd2hlbiB0aGUgdmFsdWUgaXMgcmV0cmlldmVkIHdpdGhcbiAqIHRoZSBnZXR0ZXIgXCJ2YWx1ZVwiLlxuICovXG52YXIgS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0thdGFsTWV0cmljVGltZXIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCwgX0thdGFsTWV0cmljVGltZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0aW1lciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCBzdGFydGluZyB0aW1lLiAgSWYgbm8gc3RhcnRpbmcgdGltZSBpcyBnaXZlbiwgdGhlIGN1cnJlbnQgdGltZSBpcyB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGlzIHRpbWVyXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgTWlsbGlzZWNvbmQgZXBvY2ggdGltZSBmb3IgdGhlIHN0YXJ0IHRpbWU7IGRlZmF1bHRzIHRvIG5vd1xuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaChuYW1lLCBzdGFydFRpbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIHVuZGVmaW5lZCk7XG5cbiAgICBfdGhpcy5zdGFydChzdGFydFRpbWUpO1xuXG4gICAgX3RoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogUmUtc3RhcnQgdGltZXIgd2l0aCB0aGUgZ2l2ZW4gc3RhcnQgdGltZSwgb3IgdGhlIGN1cnJlbnQgdGltZSBpZiBub25lIGlzIGdpdmVuLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnRUaW1lIFdoZW4gdGhlIHRpbWVyIHdhcyBzdGFydGVkLCBpbiBlcG9jaCBtaWxsaXNlY29uZHM7IGRlZmF1bHRzIHRvIG5vd1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gsIFt7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KHN0YXJ0VGltZSkge1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gc3RhcnRUaW1lIHx8IHRoaXMubm93KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIHRpbWVyIGFuZCByZWNvcmQgdGhlIGVsYXBzZWQgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdG9wVGltZSBXaGVuIHRoZSB0aW1lciB3YXMgc3RvcHBlZCwgaW4gZXBvY2ggbWlsbGlzZWNvbmRzOyBkZWZhdWx0cyB0byBub3dcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcChzdG9wVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3BUaW1lID0gc3RvcFRpbWUgfHwgdGhpcy5ub3coKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHRpbWVyIGhhcyBiZWVuIHN0b3BwZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0aW1lciBoYXMgYmVlbiBzdG9wcGVkIHlldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTdG9wcGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcFRpbWUgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlbGFwc2VkIHRpbWUgYmV0d2VlbiB3aGVuIHRoZSB0aW1lciB3YXMgc3RhcnRlZCBhbmQgc3RvcHBlZDsgaWYgdGhlIHRpbWVyIGhhcyBub3QgeWV0IGJlZW4gc3RvcHBlZCxcbiAgICAgKiBzdG9wIGl0IGZpcnN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgRWxhcHNlZCB0aW1lIGJldHdlZW4gd2hlbiB0aW1lciB3YXMgc3RhcnRlZCBhbmQgc3RvcHBlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICgoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5wcm90b3R5cGUpLCBcInZhbHVlXCIsIHRoaXMpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9IC8vIFJlbHkgb24gc3VwZXIudmFsdWUgc2V0dGVyIHRvIHJvdW5kXG5cblxuICAgICAgICAoMCwgX3NldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5wcm90b3R5cGUpLCBcInZhbHVlXCIsIHRoaXMuc3RvcFRpbWUgLSB0aGlzLnN0YXJ0VGltZSwgdGhpcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5wcm90b3R5cGUpLCBcInZhbHVlXCIsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgd2hlbiB0aGlzIHRpbWVyIHdhcyBzdGFydGVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBTdGFydCB0aW1lLCBpbiBlcG9jaCBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OlxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgZm9yIHRoaXMgbWV0cmljLiAgTm90ZSB0aGlzIHdpbGwgb3ZlcnJpZGUgdGhlIHN0b3B3YXRjaCBiZWhhdmlvciBhbmQganVzdCB1c2UgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIGZvciB0aGlzIG1ldHJpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgKDAsIF9zZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gucHJvdG90eXBlKSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgdGhpcywgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0VGltZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0VGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHdoZW4gdGhpcyB0aW1lciB3YXMgc3RvcHBlZCAob3IgdW5kZWZpbmVkIGlmIGl0IGlzIHN0aWxsIHJ1bm5pbmcpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFN0b3AgdGltZSwgaW4gZXBvY2ggbWlsbHNlY29uZHMsIG9yIHVuZGVmaW5lZCBpZiB0aGUgc3RvcHdhdGNoIGlzIHN0aWxsIHJ1bm5pbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0b3BUaW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcFRpbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3coKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoO1xufShfS2F0YWxNZXRyaWNUaW1lcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2g7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbi8qKlxuICogTWV0cmljIHR5cGVzLlxuICovXG52YXIgS2F0YWxNZXRyaWNUeXBlO1xuXG4oZnVuY3Rpb24gKEthdGFsTWV0cmljVHlwZSkge1xuICBLYXRhbE1ldHJpY1R5cGVbXCJTdHJpbmdcIl0gPSBcIlN0cmluZ1wiO1xuICBLYXRhbE1ldHJpY1R5cGVbXCJDb3VudGVyXCJdID0gXCJDb3VudGVyXCI7XG4gIEthdGFsTWV0cmljVHlwZVtcIlRpbWVyXCJdID0gXCJUaW1lclwiO1xuICBLYXRhbE1ldHJpY1R5cGVbXCJMaXN0XCJdID0gXCJMaXN0XCI7XG59KShLYXRhbE1ldHJpY1R5cGUgfHwgKEthdGFsTWV0cmljVHlwZSA9IHt9KSk7XG5cbjtcbnZhciBfZGVmYXVsdCA9IEthdGFsTWV0cmljVHlwZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvdW50ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljQ291bnRlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBSZXF1ZXN0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5pdGlhbGl6YXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljSW5pdGlhbGl6YXRpb24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPYmplY3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljT2JqZWN0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RyaW5nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1N0cmluZy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVkQXR0ZW1wdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNUaW1lci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVyU3RvcHdhdGNoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljU3RyaW5nXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY0NvdW50ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljQ291bnRlclwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUaW1lciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lclwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZWRBdHRlbXB0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY0h0dHBSZXF1ZXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY0h0dHBSZXF1ZXN0XCIpKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIGVuY2Fwc3VsYXRlcyB0d28gSUlGRXMgdGhhdCB0aGUgU3VzaGkgbGlicmFyeSBjb250YWlucy4gQSBmYWtlIENTTSBhbmQgV2luZG93IG9iamVjdCBhcmUgY3JlYXRlZCBhbmQgcHJvdmlkZWRcbiAqIHRvIHRoZSBmdW5jdGlvbnMgc28gdGhhdCB0aGV5IGFjdHVhbGx5IGV4ZWN1dGUgaW4gYSBjb250cm9sbGVkIGVudmlyb25tZW50IGF3YXkgZnJvbSBhbnkgQ1NNIGNvZGUgdGhhdCBtaWdodCBiZSBleGVjdXRpbmdcbiAqIGF0IHRoZSBwbGF0Zm9ybSBsZXZlbCB3aXRoaW4gdGhlIHBhZ2UuXG4gKlxuICogVGhlIGJhc2ljIHJ1biBvcmRlciBpcyB0aGUgZm9sbG93aW5nOlxuICogMS4gQnVpbGQgdGhlIG1vY2sgQ1NNIG9iamVjdCwgdGhlbiBidWlsZCBhIG1vY2sgV2luZG93IG9iamVjdCB0aGF0IHJlZmVyZW5jZXMgdGhlIENTTSBvYmplY3QgYXMgdWVfY3NtXG4gKiAyLiBSdW4gdGhlIHRyYW5zcG9ydGF0aW9uLWNsaWVudHMuanMgU2NyaXB0IGZyb20gU3VzaGlKYXZhc2NyaXB0Q2xpZW50IHByb3ZpZGluZyB0aGUgbW9ja3MuIEl0IHdpbGwgbW9kaWZ5IGdsb2JhbHMgb24gdGhlIG1vY2sgb2JqZWN0cy5cbiAqIDMuIFJ1biB0aGUgc3VzaGktY2xpZW50LmpzIHNjcmlwdCBmcm9tIFN1c2hpSmF2YVNjcmlwdENsaWVudCBwcm92aWRpbmcgdGhlIG1vY2tzLiBJdCB3aWxsIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgc3VzaGkgY2xpZW50IGFuZCBpbmplY3QgaXQgaW50byB0aGUgQ1NNIGdsb2JhbHMgaW4gdGhlIG1vY2tzLlxuICogNC4gd2hlbmV2ZXIgZXZlbnQoKSBpcyBjYWxsZWQsIHJlZmVyIHRvIHRoZSBlbmNhcHN1bGF0ZWQgY3NtIG9iamVjdCB0byBhZGQgdGhlIGV2ZW50IHRvIHRoZSBxdWV1ZS5cbiAqL1xudmFyIFN1c2hpQ2xpZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU3VzaGlDbGllbnQsIG51bGwsIFt7XG4gICAga2V5OiBcImNyZWF0ZVN1c2hpVXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVN1c2hpVXJsKHJlZ2lvbiwgc291cmNlR3JvdXApIHtcbiAgICAgIGlmICghc291cmNlR3JvdXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VzaGkgRHJpdmVyIHdhcyBub3QgcHJvdmlkZWQgd2l0aCBhIHNvdXJjZSBncm91cC5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBkb21haW47XG5cbiAgICAgIHN3aXRjaCAocmVnaW9uKSB7XG4gICAgICAgIGNhc2UgU3VzaGlDbGllbnQuUkVHSU9OUy5OQTpcbiAgICAgICAgICBkb21haW4gPSBcInVuYWdpLW5hXCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdXNoaUNsaWVudC5SRUdJT05TLkVVOlxuICAgICAgICAgIGRvbWFpbiA9IFwidW5hZ2ktZXVcIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN1c2hpQ2xpZW50LlJFR0lPTlMuRkU6XG4gICAgICAgICAgZG9tYWluID0gXCJ1bmFnaS1mZVwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3VzaGlDbGllbnQuUkVHSU9OUy5DTjpcbiAgICAgICAgICBkb21haW4gPSBcInVuYWdpLWNuXCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgcmVnaW9uICdcIi5jb25jYXQocmVnaW9uLCBcIicgcHJvdmlkZWQgdG8gU3VzaGlDbGllbnQuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9cIi5jb25jYXQoZG9tYWluLCBcIi5hbWF6b24uY29tLzEvZXZlbnRzL1wiKS5jb25jYXQoc291cmNlR3JvdXApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVDc21Vc2VyQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDc21Vc2VyQ29udGV4dChzdXNoaVVybCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBoaVByaUZsdXNoSW50ZXJ2YWw6IDEwMDAsXG4gICAgICAgIGxvd1ByaUZsdXNoSW50ZXJ2YWw6IDEwMDAwLFxuICAgICAgICByZXF1ZXN0SWQ6IFwiMVwiLFxuICAgICAgICBlcnJvckNoYW5uZWw6IFwianNlcnJcIixcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2VXcmFwcGVyOiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9ySGFuZGxlckZ1bmN0aW9uOiBjb25zb2xlLmxvZyxcbiAgICAgICAgc3VzaGlVcmw6IHN1c2hpVXJsXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgU3VzaGkgQ2xpZW50IGZvciBhIHJlZ2lvbiBhbmQgc291cmNlIGdyb3VwXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVnaW9uIFJlZ2lvbiBpbiBTdXNoaUNsaWVudC5SRUdJT05TXG4gICAgICogQHBhcmFtIHNvdXJjZUdyb3VwIFN1c2hpIEVlbCBzb3VyY2UgZ3JvdXBcbiAgICAgKiBAcGFyYW0gZXJyb3JIYW5kbGVyIEVycm9yIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIENTTSBjb250ZXh0IG92ZXJyaWRlc1xuICAgICAqIEBwYXJhbSBjbGllbnRPdmVycmlkZSBBbiBvcHRpb25hbCB0cmFuc3BvcnRhdGlvbiBjbGllbnQgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgY2xpZW50cyAobmF2aWdhdG9yLnNlbmRCZWFjb24gYW5kIFhEb21haW5SZXF1ZXN0IG9yIFhNTEh0dHBSZXF1ZXN0KVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiUkVHSU9OU1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgTkE6IFwiTkFcIixcbiAgICAgICAgRVU6IFwiRVVcIixcbiAgICAgICAgRkU6IFwiRkVcIixcbiAgICAgICAgQ046IFwiQ05cIlxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBTdXNoaUNsaWVudCgpIHtcbiAgICB2YXIgcmVnaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBTdXNoaUNsaWVudC5SRUdJT05TLk5BO1xuICAgIHZhciBzb3VyY2VHcm91cCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBlcnJvckhhbmRsZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgdmFyIGNsaWVudE92ZXJyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgU3VzaGlDbGllbnQpO1xuICAgIHZhciBzdXNoaVVybCA9IFN1c2hpQ2xpZW50LmNyZWF0ZVN1c2hpVXJsKHJlZ2lvbiwgc291cmNlR3JvdXApO1xuICAgIHZhciBjc21Vc2VyQ29udGV4dCA9IFN1c2hpQ2xpZW50LmNyZWF0ZUNzbVVzZXJDb250ZXh0KHN1c2hpVXJsLCBvcHRpb25zKTtcbiAgICB0aGlzLnVlX2NzbSA9IHRoaXMuc2V0dXBNb2NrQ1NNT2JqZWN0KGNzbVVzZXJDb250ZXh0KTtcbiAgICB0aGlzLmVuY2Fwc3VsYXRlZFdpbmRvdyA9IHRoaXMuc2V0dXBNb2NrV2luZG93KHRoaXMudWVfY3NtKTtcbiAgICB0aGlzLnRyYW5zcG9ydGF0aW9uQ2xpZW50Q29kZSh0aGlzLnVlX2NzbSwgd2luZG93KTtcblxuICAgIGlmIChjbGllbnRPdmVycmlkZSkge1xuICAgICAgdGhpcy51ZV9jc20udWUuX3NCY24gPSB7XG4gICAgICAgIGlzU3VwcG9ydGVkOiB0cnVlLFxuICAgICAgICBzZW5kOiBmdW5jdGlvbiBzZW5kKGVuZHBvaW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgY2xpZW50T3ZlcnJpZGUoZW5kcG9pbnQsIHBheWxvYWQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuY2xpZW50Q29kZSh0aGlzLnVlX2NzbSwgdGhpcy5lbmNhcHN1bGF0ZWRXaW5kb3cpO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU3VzaGlDbGllbnQsIFt7XG4gICAga2V5OiBcImV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50KGRhdGEsIHByb2R1Y2VySWQsIHNjaGVtYUlkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJTdXNoaUNsaWVudCB3cmFwcGVyIHB1Ymxpc2hpbmcgdGhlIGZvbGxvd2luZzpcIiwge1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgcHJvZHVjZXJJZDogcHJvZHVjZXJJZCxcbiAgICAgICAgICBzY2hlbWFJZDogc2NoZW1hSWQsXG4gICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudWVfY3NtLnVlLmV2ZW50KGRhdGEsIHByb2R1Y2VySWQsIHNjaGVtYUlkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgeW91IHBsYW4gdG8gZW1pdCAxMDAwIG9yIG1vcmUgZXZlbnRzIHBlciBpbnN0YW50aWF0ZWQgY2xpZW50LFxuICAgICAqIGNhbGwgcmVzZXQgYWZ0ZXIgY2FsbGluZyBldmVudCB0byBhbGxvdyB0aGUgQ1NNIGNsaWVudCB0byBjb250aW51ZSBzZW5kaW5nIGV2ZW50cy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy51ZV9jc20udWUuZXZlbnQucmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGp1c3QgYmVmb3JlIGVhY2ggdGltZSBtZXRyaWNzIGFyZVxuICAgICAqIGZsdXNoZWQgdG8gdGhlIG5ldHdvcmsuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIEEgZnVuY3Rpb24gdGhhdCBzdXNoaSB3aWxsIGNhbGwgYmVmb3JlIGZsdXNoZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblN1c2hpRmx1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdXNoaUZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVlX2NzbS51ZS5vblN1c2hpRmx1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQganVzdCBiZWZvcmUgdGhlIHBhZ2UgdW5sb2Fkcy5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHNlbmQgYW55IGZpbmFsIG1ldHJpY3MgdG8gc3VzaGksIHN1Y2ggYXMgcGFnZSB2aXNpdFxuICAgICAqIGR1cmF0aW9uIG9yIGJhdGNoZWQgY291bnRlcnMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIEEgZnVuY3Rpb24gdGhhdCBzdXNoaSB3aWxsIGNhbGwgYmVmb3JlIHVubG9hZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uU3VzaGlVbmxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdXNoaVVubG9hZChjYWxsYmFjaykge1xuICAgICAgdGhpcy51ZV9jc20udWUub25TdXNoaVVubG9hZChjYWxsYmFjayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwTW9ja0NTTU9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cE1vY2tDU01PYmplY3QoY3NtVXNlckNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBleGVjU3R1YiA9IGZ1bmN0aW9uIGV4ZWNTdHViKGNhbGxiYWNrLCBhdHRyaWJ1dGlvbikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZXZlbnRTdHViID0gZnVuY3Rpb24gZXZlbnRTdHViKGxvZywgcHJvZHVjZXIsIGV2ZW50VHlwZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJTdXNoaUNsaWVudCBDU00gc3R1YiBjYWxsZWQgaW4gdW5zdXBwb3J0ZWQgbWFubmVyOiBldmVudCgpXCIpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIGVycm9ySGFuZGxlcihsb2dFdmVudCwgY2hhbm5lbCkge1xuICAgICAgICBpZiAoX3RoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgX3RoaXMuZXJyb3JIYW5kbGVyKGxvZ0V2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFuIGVycm9yIGhhcyBvY2N1cnJlZCBpbiBTdXNoaUNsaWVudCBjaGFubmVsIFwiICsgY2hhbm5lbCwgbG9nRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgYXR0YWNoSGFuZGxlciA9IGZ1bmN0aW9uIGF0dGFjaEhhbmRsZXIoZXZ0LCBoYW5kbGVyLCBjb250YWluZXIpIHtcbiAgICAgICAgLy9UT0RPIG1pZ2h0IGJlIGFibGUgdG8ganVzdCB1c2Ugd2luZG93LnVlLmF0dGFjaD9cbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IHdpbmRvdzsgLy9vayB0byB1c2UgcmVhbCB3aW5kb3cgZ2xvYmFsIGhlcmUuXG5cbiAgICAgICAgaWYgKHdpbmRvdy5FdmVudFRhcmdldCAmJiB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlICYmIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lci5jYWxsKGNvbnRhaW5lciwgZXZ0LCBoYW5kbGVyLCAhIXdpbmRvdy51ZV9jbGYpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyLCAhIXdpbmRvdy51ZV9jbGYpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRhaW5lci5hdHRhY2hFdmVudCkge1xuICAgICAgICAgIGNvbnRhaW5lci5hdHRhY2hFdmVudChcIm9uXCIgKyBldnQsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1ZV9ocHNpOiBjc21Vc2VyQ29udGV4dC5oaVByaUZsdXNoSW50ZXJ2YWwsXG4gICAgICAgIHVlX2xwc2k6IGNzbVVzZXJDb250ZXh0Lmxvd1ByaUZsdXNoSW50ZXJ2YWwsXG4gICAgICAgIHVlOiB7XG4gICAgICAgICAgc3N3OiBjc21Vc2VyQ29udGV4dC5zZXNzaW9uU3RvcmFnZVdyYXBwZXIsXG4gICAgICAgICAgbG9nOiBlcnJvckhhbmRsZXIsXG4gICAgICAgICAgZXhlYzogZXhlY1N0dWIsXG4gICAgICAgICAgZXZlbnQ6IGV2ZW50U3R1YixcbiAgICAgICAgICBhdHRhY2g6IGF0dGFjaEhhbmRsZXJcbiAgICAgICAgfSxcbiAgICAgICAgdWVMb2dFcnJvcjogY3NtVXNlckNvbnRleHQuZXJyb3JIYW5kbGVyRnVuY3Rpb24sXG4gICAgICAgIHVlX3N1cmw6IGNzbVVzZXJDb250ZXh0LnN1c2hpVXJsLFxuICAgICAgICB1ZV9pZDogY3NtVXNlckNvbnRleHQucmVxdWVzdElkLFxuICAgICAgICB1ZV9lcnJfY2hhbjogY3NtVXNlckNvbnRleHQuZXJyb3JDaGFubmVsXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cE1vY2tXaW5kb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBNb2NrV2luZG93KHVlX2NzbSkge1xuICAgICAgLy9hcHBhcmVudGx5IGNhbm5vdCByZWYgdGhlIHNldFRpbWVvdXQgZnVuY3Rpb24gZGlyZWN0bHkgaW4gc29tZSBicm93c2VycyBzbyB3ZSBoYXZlIHRvIHdyYXAgaXQuXG4gICAgICB2YXIgdGltZW91dFdyYXBwZXIgPSBmdW5jdGlvbiB0aW1lb3V0V3JhcHBlcihmbiwgdGltZW91dCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVvdXQpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdWVfY3NtOiB1ZV9jc20sXG4gICAgICAgIHVlTG9nRXJyb3I6IHVlX2NzbS51ZUxvZ0Vycm9yLFxuICAgICAgICB1ZTogdWVfY3NtLnVlLFxuICAgICAgICBzZXRUaW1lb3V0OiB0aW1lb3V0V3JhcHBlclxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29kZSB3aXRoaW4gZnVuY3Rpb24gcHVsbGVkIGRpcmVjdGx5IGZyb21cbiAgICAgKiBodHRwczovL2NvZGUuYW1hem9uLmNvbS9wYWNrYWdlcy9TdXNoaUphdmFTY3JpcHRDbGllbnQvYmxvYnMvbWFpbmxpbmUvLS0vamF2YXNjcmlwdC9zdXNoaS1jbGllbnQuanNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsaWVudENvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xpZW50Q29kZSh1ZV9jc20sIHdpbmRvdykge1xuICAgICAgdWVfY3NtLnVlLmV4ZWMoZnVuY3Rpb24gKGIsIGspIHtcbiAgICAgICAgZnVuY3Rpb24gQSgpIHtcbiAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbYV07XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBoO1xuXG4gICAgICAgICAgICAgIGlmIChjLmlzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSB0LmJ1aWxkUGF5bG9hZChsLCBlKTtcbiAgICAgICAgICAgICAgICBoID0gYy5zZW5kKEosIGIpO1xuICAgICAgICAgICAgICB9IGVsc2UgdGhyb3cgZHVtbXlFeGNlcHRpb247XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgICB9IGNhdGNoIChkKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIEIoe1xuICAgICAgICAgICAgbTogXCJBbGwgc3VwcG9ydGVkIGNsaWVudHMgZmFpbGVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbjogXCJDU01TdXNoaUNsaWVudF9UUkFOU1BPUlRBVElPTl9GQUlMXCIsXG4gICAgICAgICAgICBmOiBcInN1c2hpLWNsaWVudC5qc1wiLFxuICAgICAgICAgICAgbG9nTGV2ZWw6IFwiRVJST1JcIlxuICAgICAgICAgIH0sIGsudWVfZXJyX2NoYW4gfHwgXCJqc2VyclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG0oKSB7XG4gICAgICAgICAgaWYgKGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IG4ubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgICAgblthXSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBKGQuX3NCY24gfHwge30sIGQuX2FqeCB8fCB7fSk7XG4gICAgICAgICAgICBlID0gW107XG4gICAgICAgICAgICBmID0ge307XG4gICAgICAgICAgICBsID0ge307XG4gICAgICAgICAgICB1ID0gdiA9IHEgPSB3ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBLKCkge1xuICAgICAgICAgIHZhciBhID0gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgYyA9IGZ1bmN0aW9uIGMoYSkge1xuICAgICAgICAgICAgcmV0dXJuIDEwID4gYSA/IFwiMFwiICsgYSA6IGE7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyA/IGEudG9JU09TdHJpbmcoKSA6IGEuZ2V0VVRDRnVsbFllYXIoKSArIFwiLVwiICsgYyhhLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICsgYyhhLmdldFVUQ0RhdGUoKSkgKyBcIlRcIiArIGMoYS5nZXRVVENIb3VycygpKSArIFwiOlwiICsgYyhhLmdldFVUQ01pbnV0ZXMoKSkgKyBcIjpcIiArIGMoYS5nZXRVVENTZWNvbmRzKCkpICsgXCIuXCIgKyBTdHJpbmcoKGEuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgLyAxRTMpLnRvRml4ZWQoMykpLnNsaWNlKDIsIDUpICsgXCJaXCI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB4KGEpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGMpIHt9XG5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEMoYSwgYywgaCwgZykge1xuICAgICAgICAgIHZhciBwID0gITE7XG4gICAgICAgICAgZyA9IGcgfHwge307XG4gICAgICAgICAgcisrO1xuICAgICAgICAgIHIgPT0gRCAmJiBCKHtcbiAgICAgICAgICAgIG06IFwiTWF4IG51bWJlciBvZiBTdXNoaSBMb2dzIGV4Y2VlZGVkXCIsXG4gICAgICAgICAgICBmOiBcInN1c2hpLWNsaWVudC5qc1wiLFxuICAgICAgICAgICAgbG9nTGV2ZWw6IFwiRVJST1JcIixcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uOiBcIkNTTVN1c2hpQ2xpZW50X01BWF9DQUxMU1wiXG4gICAgICAgICAgfSwgay51ZV9lcnJfY2hhbiB8fCBcImpzZXJyXCIpO1xuICAgICAgICAgIHZhciBmO1xuICAgICAgICAgIGlmIChmID0gIShyID49IEQpKSAoZiA9IGEgJiYgLTEgPCBhLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZihcIk9iamVjdFwiKSAmJiBjICYmIC0xIDwgYy5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluZGV4T2YoXCJTdHJpbmdcIikgJiYgaCAmJiAtMSA8IGguY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKFwiU3RyaW5nXCIpKSB8fCBMKys7XG4gICAgICAgICAgZiAmJiAoZC5jb3VudCAmJiBkLmNvdW50KFwiRXZlbnQ6XCIgKyBoLCAxKSwgYS5wcm9kdWNlcklkID0gYS5wcm9kdWNlcklkIHx8IGMsIGEuc2NoZW1hSWQgPSBhLnNjaGVtYUlkIHx8IGgsIGEudGltZXN0YW1wID0gSygpLCBjID0gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogK25ldyBEYXRlKCksIGggPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIsIDEyKSwgYS5tZXNzYWdlSWQgPSBiLnVlX2lkICsgXCItXCIgKyBjICsgXCItXCIgKyBoLCBnICYmICFnLnNzZCAmJiAoYS5zZXNzaW9uSWQgPSBhLnNlc3Npb25JZCB8fCBiLnVlX3NpZCwgYS5yZXF1ZXN0SWQgPSBhLnJlcXVlc3RJZCB8fCBiLnVlX2lkLCBhLm9iZnVzY2F0ZWRNYXJrZXRwbGFjZUlkID0gYS5vYmZ1c2NhdGVkTWFya2V0cGxhY2VJZCB8fCBiLnVlX21pZCksIChjID0geChhKSkgPyAoYyA9IGMubGVuZ3RoLCAoZS5sZW5ndGggPT0gTSB8fCBxICsgYyA+IE4pICYmIG0oKSwgcSArPSBjLCBhID0ge1xuICAgICAgICAgICAgZGF0YTogdC5jb21wcmVzc0V2ZW50KGEpXG4gICAgICAgICAgfSwgZS5wdXNoKGEpLCAoZyB8fCB7fSkubiA/IDAgPT09IEUgPyBtKCkgOiB1IHx8ICh1ID0gay5zZXRUaW1lb3V0KG0sIEUpKSA6IHYgfHwgKHYgPSBrLnNldFRpbWVvdXQobSwgTykpLCBwID0gITApIDogcCA9ICExKTtcbiAgICAgICAgICAhcCAmJiBiLnVlX2ludCAmJiBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKUyBOZXh1cyBBUEkgY2FsbFwiKTtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7XG4gICAgICAgICAgaWYgKCFHKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHkubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgICAgeVthXSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgbi5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICBuW2FdKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUubGVuZ3RoICYmIChiLnVlX3NidWltcCAmJiBiLnVlICYmIGIudWUuc3N3ICYmIChhID0geCh7XG4gICAgICAgICAgICAgIGRjdDogbCxcbiAgICAgICAgICAgICAgZXZ0OiBlXG4gICAgICAgICAgICB9KSwgYi51ZS5zc3coXCJlZWxkYXRhXCIsIGEpLCBiLnVlLnNzdyhcImVlbHN0c1wiLCBcInVua1wiKSksIEEoZC5fc0JjbiB8fCB7fSkpO1xuICAgICAgICAgICAgRyA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEgoYSkge1xuICAgICAgICAgIHkucHVzaChhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEkoYSkge1xuICAgICAgICAgIG4ucHVzaChhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBEID0gMUUzLFxuICAgICAgICAgICAgTSA9IDQ5OSxcbiAgICAgICAgICAgIE4gPSA1MjQyODgsXG4gICAgICAgICAgICBzID0gZnVuY3Rpb24gcygpIHt9LFxuICAgICAgICAgICAgZCA9IGIudWUgfHwge30sXG4gICAgICAgICAgICBCID0gZC5sb2cgfHwgcyxcbiAgICAgICAgICAgIFAgPSBiLnVleCB8fCBzO1xuXG4gICAgICAgIChiLnVldCB8fCBzKShcImJiXCIsIFwidWVfc3VzaGlfdjFcIiwge1xuICAgICAgICAgIHdiOiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBKID0gYi51ZV9zdXJsIHx8IFwiaHR0cHM6Ly91bmFnaS1uYS5hbWF6b24uY29tLzEvZXZlbnRzL2NvbS5hbWF6b24uY3NtLm5leHVzY2xpZW50LmdhbW1hXCIsXG4gICAgICAgICAgICBRID0gW1wibWVzc2FnZUlkXCIsIFwidGltZXN0YW1wXCJdLFxuICAgICAgICAgICAgeiA9IFwiI1wiLFxuICAgICAgICAgICAgZSA9IFtdLFxuICAgICAgICAgICAgZiA9IHt9LFxuICAgICAgICAgICAgbCA9IHt9LFxuICAgICAgICAgICAgcSA9IDAsXG4gICAgICAgICAgICB3ID0gMCxcbiAgICAgICAgICAgIEwgPSAwLFxuICAgICAgICAgICAgciA9IDAsXG4gICAgICAgICAgICB5ID0gW10sXG4gICAgICAgICAgICBuID0gW10sXG4gICAgICAgICAgICBHID0gITEsXG4gICAgICAgICAgICB1LFxuICAgICAgICAgICAgdixcbiAgICAgICAgICAgIEUgPSB2b2lkIDAgPT09IGIudWVfaHBzaSA/IDFFMyA6IGIudWVfaHBzaSxcbiAgICAgICAgICAgIE8gPSB2b2lkIDAgPT09IGIudWVfbHBzaSA/IDFFNCA6IGIudWVfbHBzaSxcbiAgICAgICAgICAgIHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gYShhKSB7XG4gICAgICAgICAgICBmW2FdID0geiArIHcrKztcbiAgICAgICAgICAgIGxbZlthXV0gPSBhO1xuICAgICAgICAgICAgcmV0dXJuIGZbYV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYyhiKSB7XG4gICAgICAgICAgICBpZiAoIShiIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICAgIGlmIChiIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBnID0gW10sIGQgPSBiLmxlbmd0aCwgZSA9IDA7IGUgPCBkOyBlKyspIHtcbiAgICAgICAgICAgICAgICAgIGdbZV0gPSBjKGJbZV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBnID0ge307XG5cbiAgICAgICAgICAgICAgICBmb3IgKGQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgYi5oYXNPd25Qcm9wZXJ0eShkKSAmJiAoZ1tmW2RdID8gZltkXSA6IGEoZCldID0gLTEgPT09IFEuaW5kZXhPZihkKSA/IGMoYltkXSkgOiBiW2RdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09PSB0eXBlb2YgYiAmJiAoYi5sZW5ndGggPiAoeiArIHcpLmxlbmd0aCB8fCBiLmNoYXJBdCgwKSA9PT0geikgPyBmW2JdID8gZltiXSA6IGEoYikgOiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wcmVzc0V2ZW50OiBjLFxuICAgICAgICAgICAgYnVpbGRQYXlsb2FkOiBmdW5jdGlvbiBidWlsZFBheWxvYWQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB4KHtcbiAgICAgICAgICAgICAgICBjczoge1xuICAgICAgICAgICAgICAgICAgZGN0OiBsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBldmVudHM6IGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuXG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGQuZXZlbnQgJiYgZC5ldmVudC5pc1N0dWIpIHtcbiAgICAgICAgICAgIGlmIChiLnVlX3NidWltcCAmJiBiLnVlICYmIGIudWUuc3N3KSB7XG4gICAgICAgICAgICAgIHZhciBhID0gYi51ZS5zc3coXCJlZWxzdHNcIikudmFsO1xuXG4gICAgICAgICAgICAgIGlmIChhICYmIFwidW5rXCIgPT09IGEgJiYgKGEgPSBiLnVlLnNzdyhcImVlbGRhdGFcIikudmFsKSkge1xuICAgICAgICAgICAgICAgIHZhciBjO1xuXG4gICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IEpTT04ucGFyc2UoYSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChmKSB7fVxuXG4gICAgICAgICAgICAgICAgICBjID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjICYmIGMuZXZ0IGluc3RhbmNlb2YgQXJyYXkgJiYgYy5kY3QgaW5zdGFuY2VvZiBPYmplY3QgJiYgKGUgPSBjLmV2dCwgbCA9IGMuZGN0LCBlICYmIGwgJiYgKG0oKSwgYi51ZS5zc3coXCJlZWxkYXRhXCIsIFwie31cIiksIGIudWUuc3N3KFwiZWVsc3RzXCIsIFwic2NzXCIpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZC5ldmVudC5yZXBsYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgYVszXSA9IGFbM10gfHwge307XG4gICAgICAgICAgICAgIGFbM10ubiA9IDE7XG4gICAgICAgICAgICAgIEMuYXBwbHkodGhpcywgYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQub25TdXNoaVVubG9hZC5yZXBsYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgSChhWzBdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZC5vblN1c2hpRmx1c2gucmVwbGF5KGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIEkoYVswXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgZC5hdHRhY2goXCJiZWZvcmV1bmxvYWRcIiwgRik7XG4gICAgICAgIGQuYXR0YWNoKFwicGFnZWhpZGVcIiwgRik7XG4gICAgICAgIGQuX2NtcHMgPSB0O1xuICAgICAgICBkLmV2ZW50ID0gQztcblxuICAgICAgICBkLmV2ZW50LnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHIgPSAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIGQub25TdXNoaVVubG9hZCA9IEg7XG4gICAgICAgIGQub25TdXNoaUZsdXNoID0gSTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGsuUCAmJiBrLlAucmVnaXN0ZXIgJiYgay5QLnJlZ2lzdGVyKFwic3VzaGktY2xpZW50XCIsIHMpO1xuICAgICAgICB9IGNhdGNoIChSKSB7XG4gICAgICAgICAgYi51ZUxvZ0Vycm9yKFIsIHtcbiAgICAgICAgICAgIGxvZ0xldmVsOiBcIldBUk5cIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgUChcImxkXCIsIFwidWVfc3VzaGlfdjFcIiwge1xuICAgICAgICAgIHdiOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSwgXCJOeHMtSlMtQ2xpZW50XCIpKHVlX2NzbSwgd2luZG93KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvZGUgaW4gdGhpcyBmdW5jdGlvbiBpcyBwdWxsZWQgZGlyZWN0bHkgZnJvbTpcbiAgICAgKiBodHRwczovL2NvZGUuYW1hem9uLmNvbS9wYWNrYWdlcy9TdXNoaUphdmFTY3JpcHRDbGllbnQvYmxvYnMvbWFpbmxpbmUvLS0vamF2YXNjcmlwdC90cmFuc3BvcnRhdGlvbi1jbGllbnRzLmpzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc3BvcnRhdGlvbkNsaWVudENvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNwb3J0YXRpb25DbGllbnRDb2RlKHVlX2NzbSwgd2luZG93KSB7XG4gICAgICB1ZV9jc20udWUuZXhlYyhmdW5jdGlvbiAoYiwgYykge1xuICAgICAgICB2YXIgZSA9IGZ1bmN0aW9uIGUoKSB7fSxcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoYiwgZCkge1xuICAgICAgICAgICAgICBpZiAoZCAmJiBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgICAgICAgaWYgKGMuWERvbWFpblJlcXVlc3QpIGEgPSBuZXcgWERvbWFpblJlcXVlc3QoKSwgYS5vbmVycm9yID0gZSwgYS5vbnRpbWVvdXQgPSBlLCBhLm9ucHJvZ3Jlc3MgPSBlLCBhLm9ubG9hZCA9IGUsIGEudGltZW91dCA9IDA7ZWxzZSBpZiAoYy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSwgIShcIndpdGhDcmVkZW50aWFsc1wiIGluIGEpKSB0aHJvdyBcIlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBhID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmICghYSkgdGhyb3cgXCJcIjtcbiAgICAgICAgICAgICAgICBhLm9wZW4oXCJQT1NUXCIsIGIsICEwKTtcbiAgICAgICAgICAgICAgICBhLnNldFJlcXVlc3RIZWFkZXIgJiYgYS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwidGV4dC9wbGFpblwiKTtcbiAgICAgICAgICAgICAgICBhLnNlbmQoZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1N1cHBvcnRlZDogITBcbiAgICAgICAgICB9O1xuICAgICAgICB9KCksXG4gICAgICAgICAgICBnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiBzZW5kKGMsIGQpIHtcbiAgICAgICAgICAgICAgaWYgKGMgJiYgZCkgaWYgKG5hdmlnYXRvci5zZW5kQmVhY29uKGMsIGQpKSBiLnVlX3NidWltcCAmJiBiLnVlICYmIGIudWUuc3N3ICYmIGIudWUuc3N3KFwiZWVsc3RzXCIsIFwic2NzXCIpO2Vsc2UgdGhyb3cgXCJcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1N1cHBvcnRlZDogISFuYXZpZ2F0b3Iuc2VuZEJlYWNvbiAmJiAhKGMuY29yZG92YSAmJiBjLmNvcmRvdmEucGxhdGZvcm1JZCAmJiBcImlvc1wiID09IGMuY29yZG92YS5wbGF0Zm9ybUlkKVxuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcblxuICAgICAgICBiLnVlLl9hanggPSBmO1xuICAgICAgICBiLnVlLl9zQmNuID0gZztcbiAgICAgIH0sIFwiVHJhbnNwb3J0YXRpb24tY2xpZW50c1wiKSh1ZV9jc20sIHdpbmRvdyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdXNoaUNsaWVudDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3VzaGlDbGllbnQ7IiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZShcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHRvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKFwiLi90b1Byb3BlcnR5S2V5LmpzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZS5qc1wiKTtcbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgfVxuICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIik7XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHN1cGVyUHJvcEJhc2UgPSByZXF1aXJlKFwiLi9zdXBlclByb3BCYXNlLmpzXCIpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4vZGVmaW5lUHJvcGVydHkuanNcIik7XG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LnNldCkge1xuICAgIHNldCA9IFJlZmxlY3Quc2V0O1xuICB9IGVsc2Uge1xuICAgIHNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIHZhciBkZXNjO1xuICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoZGVzYykge1xuICAgICAgICBpZiAoIWRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZGVzYy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcik7XG59XG5mdW5jdGlvbiBfc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciwgaXNTdHJpY3QpIHtcbiAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG4gIGlmICghcyAmJiBpc1N0cmljdCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZhaWxlZCB0byBzZXQgcHJvcGVydHknKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zZXQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZi5qc1wiKTtcbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zdXBlclByb3BCYXNlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXMuanNcIik7XG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5LmpzXCIpO1xudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIik7XG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZC5qc1wiKTtcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b1ByaW1pdGl2ZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoXCIuL3RvUHJpbWl0aXZlLmpzXCIpO1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogU3RyaW5nKGkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b1Byb3BlcnR5S2V5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gKG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSwgX3R5cGVvZihvKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiKTtcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIlwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIGJ1aWxkUXVlcnlTdHJpbmcocixuLGEpe3ZhciBvPVtdO2Zvcih2YXIgdCBpbiByKSFmdW5jdGlvbih0KXt2YXIgZTtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocix0KSYmdm9pZCAwIT09clt0XSYmKGEmJkFycmF5LmlzQXJyYXkoclt0XSkmJnJbdF0ubGVuZ3RoP3JbdF0uZm9yRWFjaChmdW5jdGlvbihyKXtlPTAhPT1yP3J8fFwiXCI6MCxvLnB1c2goXCJcIi5jb25jYXQodCxcIj1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZSkudHJpbSgpKSkpfSk6KGU9bj9TdHJpbmcoclt0XSkudG9Mb3dlckNhc2UoKXx8XCJcIjowIT09clt0XT9yW3RdfHxcIlwiOjAsby5wdXNoKFwiXCIuY29uY2F0KHQsXCI9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGUpLnRyaW0oKSkpKSkpfSh0KTtyZXR1cm5cIj9cIi5jb25jYXQoby5qb2luKFwiJlwiKSl9ZnVuY3Rpb24gYXBwZW5kUGF0aChyLHQsZSl7dm9pZCAwPT09dCYmKHQ9XCJcIiksXCIvXCI9PT10W3QubGVuZ3RoLTFdJiYodD10LnNsaWNlKDAsLTEpKTt2YXIgbj1TdHJpbmcocikudHJpbSgpO3JldHVybiBlJiYobj1uLnRvTG93ZXJDYXNlKCkpLDA9PT1uLmluZGV4T2YoXCIvXCIpP3QrPW46dCs9XCIvXCIuY29uY2F0KG4pLHR9ZnVuY3Rpb24gYnVpbGRIYXNoKHIsdCl7dmFyIGU9XCIjXCIuY29uY2F0KFN0cmluZyhyKS50cmltKCkpO3JldHVybiB0P2UudG9Mb3dlckNhc2UoKTplfWZ1bmN0aW9uIGJ1aWxkVXJsKHIsdCl7dmFyIGU7cmV0dXJuIG51bGw9PT1yP2U9XCJcIjpcIm9iamVjdFwiPT10eXBlb2Ygcj8oZT1cIlwiLHQ9cik6ZT1yLG51bGwhPXQmJnQucGF0aCYmKGU9YXBwZW5kUGF0aCh0LnBhdGgsZSx0Lmxvd2VyQ2FzZSkpLG51bGwhPXQmJnQucXVlcnlQYXJhbXMmJihlKz1idWlsZFF1ZXJ5U3RyaW5nKHQucXVlcnlQYXJhbXMsdC5sb3dlckNhc2UsdC5kaXNhYmxlQ1NWKSksbnVsbCE9dCYmdC5oYXNoJiYoZSs9YnVpbGRIYXNoKHQuaGFzaCx0Lmxvd2VyQ2FzZSkpLGV9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZXhwb3J0cy5hcHBlbmRQYXRoPWFwcGVuZFBhdGgsZXhwb3J0cy5idWlsZEhhc2g9YnVpbGRIYXNoLGV4cG9ydHMuYnVpbGRRdWVyeVN0cmluZz1idWlsZFF1ZXJ5U3RyaW5nLGV4cG9ydHMuYnVpbGRVcmw9YnVpbGRVcmwsZXhwb3J0cy5kZWZhdWx0PWJ1aWxkVXJsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGQtdXJsLmpzLm1hcFxuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIiNhYS1jaGFsbGVuZ2Utd2hvbGUtcGFnZS1pZnJhbWUge1xcbiAgICBvdmVyZmxvdzpoaWRkZW47XFxuICAgIG9wYWNpdHk6MS4wO1xcbiAgICBwb3NpdGlvbjpmaXhlZDtcXG4gICAgdG9wOjBweDtcXG4gICAgYm90dG9tOjBweDtcXG4gICAgcmlnaHQ6MHB4O1xcbiAgICBib3JkZXI6bm9uZTtcXG4gICAgbWFyZ2luOjA7XFxuICAgIHBhZGRpbmc6MDtcXG4gICAgaGVpZ2h0OjEwMCU7XFxuICAgIHdpZHRoOjEwMCU7XFxuICAgIHotaW5kZXg6OTk5OTk5O1xcbn1cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIFJlc2l6ZU9ic2VydmVyXHJcbiAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLCB2YWxpZC1qc2RvYyAqL1xyXG52YXIgTWFwU2hpbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZGV4IGluIHByb3ZpZGVkIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XHJcbiAgICAgICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fX2VudHJpZXNfX1tpbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVsxXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX19baW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoZW50cmllcywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHsgY3R4ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fX2VudHJpZXNfXzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlbnRyeVsxXSwgZW50cnlbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2xhc3NfMTtcclxuICAgIH0oKSk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBEZXRlY3RzIHdoZXRoZXIgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIGFyZSBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC5cclxuICovXHJcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG5cbi8vIFJldHVybnMgZ2xvYmFsIG9iamVjdCBvZiBhIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbnZhciBnbG9iYWwkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG59KSgpO1xuXG4vKipcclxuICogQSBzaGltIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIGZhbGxzIGJhY2sgdG8gdGhlIHNldFRpbWVvdXQgaWZcclxuICogZmlyc3Qgb25lIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlcXVlc3RzJyBpZGVudGlmaWVyLlxyXG4gKi9cclxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byB1c2UgYSBib3VuZGVkIGZ1bmN0aW9uIGJlY2F1c2UgSUUgc29tZXRpbWVzIHRocm93c1xyXG4gICAgICAgIC8vIGFuIFwiSW52YWxpZCBjYWxsaW5nIG9iamVjdFwiIGVycm9yIGlmIHJBRiBpcyBpbnZva2VkIHdpdGhvdXQgdGhlIGdsb2JhbFxyXG4gICAgICAgIC8vIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soRGF0ZS5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcbn0pKCk7XG5cbi8vIERlZmluZXMgbWluaW11bSB0aW1lb3V0IGJlZm9yZSBhZGRpbmcgYSB0cmFpbGluZyBjYWxsLlxyXG52YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGVuc3VyZXMgdGhhdCBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlXHJcbiAqIGludm9rZWQgb25seSBvbmNlIGR1cmluZyB0aGUgc3BlY2lmaWVkIGRlbGF5IHBlcmlvZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBkZWxheSBwZXJpb2QuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGFmdGVyIHdoaWNoIHRvIGludm9rZSBjYWxsYmFjay5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gdGhyb3R0bGUgKGNhbGxiYWNrLCBkZWxheSkge1xyXG4gICAgdmFyIGxlYWRpbmdDYWxsID0gZmFsc2UsIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLCBsYXN0Q2FsbFRpbWUgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSBvcmlnaW5hbCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc2NoZWR1bGVzIG5ldyBpbnZvY2F0aW9uIGlmXHJcbiAgICAgKiB0aGUgXCJwcm94eVwiIHdhcyBjYWxsZWQgZHVyaW5nIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmcoKSB7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgcHJveHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS4gSXQgd2lsbCBmdXJ0aGVyIHBvc3Rwb25lXHJcbiAgICAgKiBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBkZWxlZ2F0aW5nIGl0IHRvIHRoZVxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEocmVzb2x2ZVBlbmRpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHByb3h5KCkge1xyXG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAvLyBSZWplY3QgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGNhbGxzLlxyXG4gICAgICAgICAgICBpZiAodGltZVN0YW1wIC0gbGFzdENhbGxUaW1lIDwgdHJhaWxpbmdUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgbmV3IGNhbGwgdG8gYmUgaW4gaW52b2tlZCB3aGVuIHRoZSBwZW5kaW5nIG9uZSBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxyXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBzbyB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHdlIG1pZ2h0IG1pc3Mgb25lIGlmIGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBoYXBwZW5zIGFtaWRzIHRoZSBwZW5kaW5nIGludm9jYXRpb24uXHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lU3RhbXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cblxuLy8gTWluaW11bSBkZWxheSBiZWZvcmUgaW52b2tpbmcgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXHJcbnZhciBSRUZSRVNIX0RFTEFZID0gMjA7XHJcbi8vIEEgbGlzdCBvZiBzdWJzdHJpbmdzIG9mIENTUyBwcm9wZXJ0aWVzIHVzZWQgdG8gZmluZCB0cmFuc2l0aW9uIGV2ZW50cyB0aGF0XHJcbi8vIG1pZ2h0IGFmZmVjdCBkaW1lbnNpb25zIG9mIG9ic2VydmVkIGVsZW1lbnRzLlxyXG52YXIgdHJhbnNpdGlvbktleXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnc2l6ZScsICd3ZWlnaHQnXTtcclxuLy8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXHJcbnZhciBtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xyXG4vKipcclxuICogU2luZ2xldG9uIGNvbnRyb2xsZXIgY2xhc3Mgd2hpY2ggaGFuZGxlcyB1cGRhdGVzIG9mIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBET00gbGlzdGVuZXJzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlbGxzIHRoYXQgY29udHJvbGxlciBoYXMgc3Vic2NyaWJlZCBmb3IgTXV0YXRpb24gRXZlbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZlclNQST59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNfID0gW107XHJcbiAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoID0gdGhyb3R0bGUodGhpcy5yZWZyZXNoLmJpbmQodGhpcyksIFJFRlJFU0hfREVMQVkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9ic2VydmVyIHRvIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIGlmICghfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKG9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgaWYgdGhleSBoYXZlbid0IGJlZW4gYWRkZWQgeWV0LlxyXG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSByZW1vdmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfO1xyXG4gICAgICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICAvLyBSZW1vdmUgb2JzZXJ2ZXIgaWYgaXQncyBwcmVzZW50IGluIHJlZ2lzdHJ5LlxyXG4gICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMgaWYgY29udHJvbGxlciBoYXMgbm8gY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLiBJdCB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpbnNvZmFyXHJcbiAgICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hhbmdlc0RldGVjdGVkID0gdGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7XHJcbiAgICAgICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XHJcbiAgICAgICAgLy8gYmUgZnV0dXJlIG9uZXMgY2F1c2VkIGJ5IENTUyB0cmFuc2l0aW9ucy5cclxuICAgICAgICBpZiAoY2hhbmdlc0RldGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgZXZlcnkgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdCBhbmQgbm90aWZpZXMgdGhlbSBvZiBxdWV1ZWRcclxuICAgICAqIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlciBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlT2JzZXJ2ZXJzXyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDb2xsZWN0IG9ic2VydmVycyB0aGF0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB2YXIgYWN0aXZlT2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfLmZpbHRlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmdhdGhlckFjdGl2ZSgpLCBvYnNlcnZlci5oYXNBY3RpdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEZWxpdmVyIG5vdGlmaWNhdGlvbnMgaW4gYSBzZXBhcmF0ZSBjeWNsZSBpbiBvcmRlciB0byBhdm9pZCBhbnlcclxuICAgICAgICAvLyBjb2xsaXNpb25zIGJldHdlZW4gb2JzZXJ2ZXJzLCBlLmcuIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mXHJcbiAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcclxuICAgICAgICAvLyBvZiB0aGVtIGNoYW5nZXMgY29udGVudCBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCB0YXJnZXQuIFNvbWV0aW1lc1xyXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBub3RpZmljYXRpb25zIGJlaW5nIGJsb2NrZWQgZm9yIHRoZSByZXN0IG9mIG9ic2VydmVycy5cclxuICAgICAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpOyB9KTtcclxuICAgICAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBhZGRlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxyXG4gICAgICAgIC8vIGRlbGF5ZWQgdHJhbnNpdGlvbnMuIFRoaXMgd2F5IGl0J3MgcG9zc2libGUgdG8gY2FwdHVyZSBhdCBsZWFzdCB0aGVcclxuICAgICAgICAvLyBmaW5hbCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8ub2JzZXJ2ZShkb2N1bWVudCwge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uc09ic2VydmVyXykge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIHRyYW5zaXRpb24gbWF5IGFmZmVjdCBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfnByb3BlcnR5TmFtZS5pbmRleE9mKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV87XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyByZWZlcmVuY2UgdG8gdGhlIGNvbnRyb2xsZXIncyBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuaW5zdGFuY2VfID0gbnVsbDtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgZm9yIHdoaWNoIHRvIGRlZmluZSBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG52YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gKGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgZ2xvYmFsIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKi9cclxudmFyIGdldFdpbmRvd09mID0gKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIE5vZGUsIHdoaWNoIG1lYW5zIHRoYXQgaXRcclxuICAgIC8vIGhhcyB0aGUgXCJvd25lckRvY3VtZW50XCIgcHJvcGVydHkgZnJvbSB3aGljaCB3ZSBjYW4gcmV0cmlldmUgYVxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxyXG4gICAgdmFyIG93bmVyR2xvYmFsID0gdGFyZ2V0ICYmIHRhcmdldC5vd25lckRvY3VtZW50ICYmIHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgLy8gUmV0dXJuIHRoZSBsb2NhbCBnbG9iYWwgb2JqZWN0IGlmIGl0J3Mgbm90IHBvc3NpYmxlIGV4dHJhY3Qgb25lIGZyb21cclxuICAgIC8vIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICByZXR1cm4gb3duZXJHbG9iYWwgfHwgZ2xvYmFsJDE7XHJcbn0pO1xuXG4vLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cclxudmFyIGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4vKipcclxuICogQ29udmVydHMgcHJvdmlkZWQgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XHJcbiAgICAgICAgcmV0dXJuIHNpemUgKyB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH0sIDApO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBwYWRkaW5ncyBzaXplcyBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHJldHVybnMge09iamVjdH0gUGFkZGluZ3MgYm94LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGFkZGluZ3Moc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuICAgIHZhciBwYWRkaW5ncyA9IHt9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBwb3NpdGlvbnNfMSA9IHBvc2l0aW9uczsgX2kgPCBwb3NpdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnNfMVtfaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XHJcbiAgICAgICAgcGFkZGluZ3NbcG9zaXRpb25dID0gdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFkZGluZ3M7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzXHJcbiAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIEhUTUxFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgLy8gQ2xpZW50IHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgY2FuJ3QgYmVcclxuICAgIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxyXG4gICAgdmFyIGNsaWVudFdpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xyXG4gICAgLy8gQnkgdGhpcyBjb25kaXRpb24gd2UgY2FuIGNhdGNoIGFsbCBub24tcmVwbGFjZWQgaW5saW5lLCBoaWRkZW4gYW5kXHJcbiAgICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXHJcbiAgICAvLyB0aGFuIDAuNSB3aWxsIGJlIGRpc2NhcmRlZCBhcyB3ZWxsLlxyXG4gICAgLy9cclxuICAgIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxyXG4gICAgLy8gdGhvc2UgY2FzZXMgYW5kIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYSBwcmVjaXNlIGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgLy8gZWZmZWN0aXZlIHRlc3QgZm9yIGhpZGRlbiBlbGVtZW50cy4gRS5nLiBldmVuIGpRdWVyeSdzICc6dmlzaWJsZScgZmlsdGVyXHJcbiAgICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXHJcbiAgICBpZiAoIWNsaWVudFdpZHRoICYmICFjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgdmFyIHN0eWxlcyA9IGdldFdpbmRvd09mKHRhcmdldCkuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzKTtcclxuICAgIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcclxuICAgIHZhciB2ZXJ0UGFkID0gcGFkZGluZ3MudG9wICsgcGFkZGluZ3MuYm90dG9tO1xyXG4gICAgLy8gQ29tcHV0ZWQgc3R5bGVzIG9mIHdpZHRoICYgaGVpZ2h0IGFyZSBiZWluZyB1c2VkIGJlY2F1c2UgdGhleSBhcmUgdGhlXHJcbiAgICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXHJcbiAgICAvLyBiZSBwb3NzaWJsZSB0byB1dGlsaXplIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaWYgb25seSBpdCdzIGRhdGEgd2Fzbid0XHJcbiAgICAvLyBhZmZlY3RlZCBieSBDU1MgdHJhbnNmb3JtYXRpb25zIGxldCBhbG9uZSBwYWRkaW5ncywgYm9yZGVycyBhbmQgc2Nyb2xsIGJhcnMuXHJcbiAgICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzLmhlaWdodCk7XHJcbiAgICAvLyBXaWR0aCAmIGhlaWdodCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHdoZW4gdGhlICdib3JkZXItYm94JyBib3hcclxuICAgIC8vIG1vZGVsIGlzIGFwcGxpZWQgKGV4Y2VwdCBmb3IgSUUpLlxyXG4gICAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xyXG4gICAgICAgIC8vIEZvbGxvd2luZyBjb25kaXRpb25zIGFyZSByZXF1aXJlZCB0byBoYW5kbGUgSW50ZXJuZXQgRXhwbG9yZXIgd2hpY2hcclxuICAgICAgICAvLyBkb2Vzbid0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgdG8gY29tcHV0ZWQgQ1NTIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXZSBjYW4gc2F5IHRoYXQgaWYgQ1NTIGRpbWVuc2lvbnMgKyBwYWRkaW5ncyBhcmUgZXF1YWwgdG8gdGhlIFwiY2xpZW50XCJcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoZW4gaXQncyBlaXRoZXIgSUUsIGFuZCB0aHVzIHdlIGRvbid0IG5lZWQgdG8gc3VidHJhY3RcclxuICAgICAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpICE9PSBjbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICdsZWZ0JywgJ3JpZ2h0JykgKyBob3JpelBhZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgIT09IGNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAndG9wJywgJ2JvdHRvbScpICsgdmVydFBhZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGb2xsb3dpbmcgc3RlcHMgY2FuJ3QgYmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQncyByb290IGVsZW1lbnQgYXMgaXRzXHJcbiAgICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXHJcbiAgICAvLyBCZXNpZGVzLCBpdCdzIGFzIHdlbGwgbm90IG5lY2Vzc2FyeSBhcyB0aGUgPGh0bWw+IGl0c2VsZiBuZWl0aGVyIGhhc1xyXG4gICAgLy8gcmVuZGVyZWQgc2Nyb2xsIGJhcnMgbm9yIGl0IGNhbiBiZSBjbGlwcGVkLlxyXG4gICAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgLy8gSW4gc29tZSBicm93c2VycyAob25seSBpbiBGaXJlZm94LCBhY3R1YWxseSkgQ1NTIHdpZHRoICYgaGVpZ2h0XHJcbiAgICAgICAgLy8gaW5jbHVkZSBzY3JvbGwgYmFycyBzaXplIHdoaWNoIGNhbiBiZSByZW1vdmVkIGF0IHRoaXMgc3RlcCBhcyBzY3JvbGxcclxuICAgICAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcclxuICAgICAgICAvLyBhbmQgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLCB0aG91Z2ggdGhhdCBpcyBub3QgYWx3YXlzIHRydWUgaW4gQ2hyb21lLlxyXG4gICAgICAgIHZhciB2ZXJ0U2Nyb2xsYmFyID0gTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAtIGNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgLy8gQ2hyb21lIGhhcyBhIHJhdGhlciB3ZWlyZCByb3VuZGluZyBvZiBcImNsaWVudFwiIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gRS5nLiBmb3IgYW4gZWxlbWVudCB3aXRoIGNvbnRlbnQgd2lkdGggb2YgMzE0LjJweCBpdCBzb21ldGltZXMgZ2l2ZXNcclxuICAgICAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcclxuICAgICAgICAvLyAzMTRweC4gQW5kIGl0IGRvZXNuJ3QgaGFwcGVuIGFsbCB0aGUgdGltZS4gU28ganVzdCBpZ25vcmUgdGhpcyBkZWx0YVxyXG4gICAgICAgIC8vIGFzIGEgbm9uLXJlbGV2YW50LlxyXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSB2ZXJ0U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBob3JpelNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG52YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gU29tZSBicm93c2VycywgbmFtZWx5IElFIGFuZCBFZGdlLCBkb24ndCBoYXZlIHRoZSBTVkdHcmFwaGljc0VsZW1lbnRcclxuICAgIC8vIGludGVyZmFjZS5cclxuICAgIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0dyYXBoaWNzRWxlbWVudDsgfTtcclxuICAgIH1cclxuICAgIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgLy8gU1ZHRWxlbWVudCBhbmQgdGhhdCBpdCBoYXMgdGhlIFwiZ2V0QkJveFwiIG1ldGhvZC5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmXHJcbiAgICAgICAgdHlwZW9mIHRhcmdldC5nZXRCQm94ID09PSAnZnVuY3Rpb24nKTsgfTtcclxufSkoKTtcclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYSBkb2N1bWVudCBlbGVtZW50ICg8aHRtbD4pLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcclxuICAgIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGFuIGFwcHJvcHJpYXRlIGNvbnRlbnQgcmVjdGFuZ2xlIGZvciBwcm92aWRlZCBodG1sIG9yIHN2ZyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICBpZiAoIWlzQnJvd3Nlcikge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyByZWN0YW5nbGUgd2l0aCBhbiBpbnRlcmZhY2Ugb2YgdGhlIERPTVJlY3RSZWFkT25seS5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RvbXJlY3RyZWFkb25seVxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIE9iamVjdCB3aXRoIHJlY3RhbmdsZSdzIHgveSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucy5cclxuICogQHJldHVybnMge0RPTVJlY3RSZWFkT25seX1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRPbmx5UmVjdChfYSkge1xyXG4gICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgLy8gSWYgRE9NUmVjdFJlYWRPbmx5IGlzIGF2YWlsYWJsZSB1c2UgaXQgYXMgYSBwcm90b3R5cGUgZm9yIHRoZSByZWN0YW5nbGUuXHJcbiAgICB2YXIgQ29uc3RyID0gdHlwZW9mIERPTVJlY3RSZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcgPyBET01SZWN0UmVhZE9ubHkgOiBPYmplY3Q7XHJcbiAgICB2YXIgcmVjdCA9IE9iamVjdC5jcmVhdGUoQ29uc3RyLnByb3RvdHlwZSk7XHJcbiAgICAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG4gICAgZGVmaW5lQ29uZmlndXJhYmxlKHJlY3QsIHtcclxuICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIHRvcDogeSxcclxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxyXG4gICAgICAgIGJvdHRvbTogaGVpZ2h0ICsgeSxcclxuICAgICAgICBsZWZ0OiB4XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZWN0O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIERPTVJlY3RJbml0IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucyBhbmQgdGhlIHgveSBjb29yZGluYXRlcy5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBSZWN0YW5nbGUncyB3aWR0aC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFJlY3RhbmdsZSdzIGhlaWdodC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVjdEluaXQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG59XG5cbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAqIHByb3ZpZGVkIERPTSBlbGVtZW50IGFuZCBmb3Iga2VlcGluZyB0cmFjayBvZiBpdCdzIGNoYW5nZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCB3aWR0aCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgaGVpZ2h0IG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0RPTVJlY3RJbml0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgY29udGVudCByZWN0YW5nbGUgYW5kIHRlbGxzIHdoZXRoZXIgaXQncyB3aWR0aCBvciBoZWlnaHQgcHJvcGVydGllc1xyXG4gICAgICogaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGJyb2FkY2FzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gZ2V0Q29udGVudFJlY3QodGhpcy50YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gcmVjdDtcclxuICAgICAgICByZXR1cm4gKHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHxcclxuICAgICAgICAgICAgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgJ2Jyb2FkY2FzdFdpZHRoJyBhbmQgJ2Jyb2FkY2FzdEhlaWdodCcgcHJvcGVydGllcyB3aXRoIGEgZGF0YVxyXG4gICAgICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH0gTGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnRSZWN0XztcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuICAgICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gRGF0YSBvZiB0aGUgZWxlbWVudCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcclxuICAgICAgICB2YXIgY29udGVudFJlY3QgPSBjcmVhdGVSZWFkT25seVJlY3QocmVjdEluaXQpO1xyXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlXHJcbiAgICAgICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBQcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBiZWluZyB1c2VkIGFzIHRoZXknZCByZXF1aXJlIHRvIGRlZmluZSBhXHJcbiAgICAgICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XHJcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGlzIHR5cGUgb2YgY29sbGVjdGlvbnMuXHJcbiAgICAgICAgZGVmaW5lQ29uZmlndXJhYmxlKHRoaXMsIHsgdGFyZ2V0OiB0YXJnZXQsIGNvbnRlbnRSZWN0OiBjb250ZW50UmVjdCB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZFxyXG4gICAgICogICAgICB3aGVuIG9uZSBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlcyBpdCdzIGNvbnRlbnQgZGltZW5zaW9ucy5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAgICogICAgICBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHVwZGF0ZXMgb2Ygb2JzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyfSBjYWxsYmFja0N0eCAtIFJlZmVyZW5jZSB0byB0aGUgcHVibGljXHJcbiAgICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgY2FsbGJhY2tDdHgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIHJlc2l6ZSBvYnNlcnZhdGlvbnMgdGhhdCBoYXZlIGRldGVjdGVkIGNoYW5nZXMgaW4gZGltZW5zaW9uc1xyXG4gICAgICAgICAqIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RyeSBvZiB0aGUgUmVzaXplT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge01hcDxFbGVtZW50LCBSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfID0gY29udHJvbGxlcjtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5hZGRPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAvLyBGb3JjZSB0aGUgdXBkYXRlIG9mIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIG5vdCBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0cyBvYnNlcnZhdGlvbiBpbnN0YW5jZXMgdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBvZiB3aGljaCBoYXMgY2hhbmdlZFxyXG4gICAgICogaXQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ucHVzaChvYnNlcnZhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgaW5pdGlhbCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgbGlzdCBvZiBSZXNpemVPYnNlcnZlckVudHJ5XHJcbiAgICAgKiBpbnN0YW5jZXMgY29sbGVjdGVkIGZyb20gYWN0aXZlIHJlc2l6ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBvYnNlcnZlciBkb2Vzbid0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYWxsYmFja0N0eF87XHJcbiAgICAgICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cclxuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5tYXAoZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvYnNlcnZhdGlvbi50YXJnZXQsIG9ic2VydmF0aW9uLmJyb2FkY2FzdFJlY3QoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18uY2FsbChjdHgsIGVudHJpZXMsIGN0eCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjb2xsZWN0aW9uIG9mIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciBvYnNlcnZlciBoYXMgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmhhc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU1BJO1xyXG59KCkpO1xuXG4vLyBSZWdpc3RyeSBvZiBpbnRlcm5hbCBvYnNlcnZlcnMuIElmIFdlYWtNYXAgaXMgbm90IGF2YWlsYWJsZSB1c2UgY3VycmVudCBzaGltXHJcbi8vIGZvciB0aGUgTWFwIGNvbGxlY3Rpb24gYXMgaXQgaGFzIGFsbCByZXF1aXJlZCBtZXRob2RzIGFuZCBiZWNhdXNlIFdlYWtNYXBcclxuLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXHJcbnZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcclxuLyoqXHJcbiAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuICogZXhwb3Npbmcgb25seSB0aG9zZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmluZWQgaW4gdGhlIHNwZWMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzaXplT2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xyXG4gICAgICAgIG9ic2VydmVycy5zZXQodGhpcywgb2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KCkpO1xyXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMgb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbltcclxuICAgICdvYnNlcnZlJyxcclxuICAgICd1bm9ic2VydmUnLFxyXG4gICAgJ2Rpc2Nvbm5lY3QnXHJcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZF0uYXBwbHkoX2EsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59KTtcblxudmFyIGluZGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIEV4cG9ydCBleGlzdGluZyBpbXBsZW1lbnRhdGlvbiBpZiBhdmFpbGFibGUuXHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW1xuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXG4gIF0pLmpvaW4oJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkO1xuIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG4iLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiIsIidcXHg3NVxceDczXFx4NjVcXHgyMFxceDczXFx4NzRcXHg3MlxceDY5XFx4NjNcXHg3NCc7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJ1xceDVmXFx4NWZcXHg2NVxceDczXFx4NGRcXHg2ZlxceDY0XFx4NzVcXHg2Y1xceDY1Jyx7dmFsdWU6dHJ1ZX0pO3ZhciBIb3N0bmFtZVJlc29sdmVyPWZ1bmN0aW9uKCl7dmFyIF9JbD1bJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2MVxceDY1JywnXFx4NzBcXHg2YycsJ1xceDc0XFx4NzInLCdcXHg2MVxceDY1XFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2OVxceDZlXFx4NzRcXHg2NVxceDY3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmRcXHgyZVxceDYxXFx4NzUnLCdcXHg3M1xceDYxXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDY1XFx4NjcnLCdcXHg3M1xceDY1JywnXFx4NjlcXHg2ZVxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjFcXHg3NCcsJ1xceDYxXFx4NjUnLCdcXHg2MlxceDcyXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4MmVcXHg3NVxceDZiJywnXFx4NjFcXHg3NVxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3M1xceDY3JywnXFx4NmVcXHg2YycsJ1xceDYyXFx4NmNcXHg2ZlxceDYyJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDczXFx4NjEnLCdcXHg2NVxceDczXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZFxceDJlXFx4NmRcXHg3OCcsJ1xceDZkXFx4NzhcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjNcXHg2MVxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2NFxceDY1XFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2NVxceDczJywnXFx4NjVcXHg3M1xceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2ZVxceDZjXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDcwXFx4NmNcXHgyZVxceDY5XFx4NmVcXHg3NFxceDY1XFx4NjdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzNcXHg2MVxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjZcXHg3MicsMjIzODYsJ1xceDY2XFx4NzInLCdcXHg2YVxceDcwXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc0XFx4NzJcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDY0XFx4NzVcXHg2MlxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3NVxceDZiXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc1XFx4NmJcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzBcXHg2Y1xceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjRcXHg3NVxceDYyXFx4MmVcXHg3OFxceDYzXFx4NmZcXHg3MlxceDcwXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmRcXHgyZVxceDc0XFx4NzInLCdcXHg2YVxceDcwJywnXFx4NjJcXHg2Y1xceDZmXFx4NjJcXHg0NVxceDZlXFx4NjNcXHg3MlxceDc5XFx4NzBcXHg3NCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmRcXHgyZVxceDYyXFx4NzInLCdcXHg2NFxceDY1JywnXFx4NjlcXHg2ZScsJ1xceDYyXFx4NzJcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjlcXHg3NFxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2MVxceDc0XFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2OVxceDc0JywnXFx4NjJcXHg3MicsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg3M1xceDY1JywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHgyZVxceDZhXFx4NzAnLCdcXHg2M1xceDYxJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NjEnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjVcXHg2NycsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg3M1xceDY3JywnXFx4NzVcXHg2YicsJ1xceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDY1XFx4NzUnLCdcXHg2MVxceDc1XFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDY2XFx4NzJcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjFcXHg2NVxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjRcXHg3NVxceDYyXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDYxXFx4NzUnLCdcXHg2NVxceDY3XFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2NFxceDc1XFx4NjJcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjlcXHg3NCcsJ1xceDZhXFx4NzBcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzNcXHg2NVxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjRcXHg3NVxceDYyXFx4MmVcXHg3OFxceDYzXFx4NmZcXHg3MlxceDcwXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDczXFx4NjVcXHgyZVxceDY5XFx4NmVcXHg3NFxceDY1XFx4NjdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NmRcXHg3OCcsJ1xceDY1XFx4NzMnLCdcXHg2NVxceDY3XFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2OVxceDZlXFx4NzRcXHg2NVxceDY3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2ZVxceDZjJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDY5XFx4NmUnLCdcXHg3NFxceDcyXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2OVxceDZlXFx4NzRcXHg2NVxceDY3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDczXFx4NjdcXHgyZVxceDY5XFx4NmVcXHg3NFxceDY1XFx4NjdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzVcXHg3MycsJ1xceDYzXFx4NjFcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NmRcXHg3OFxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2OVxceDZlXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg3MFxceDZjJywnXFx4NjRcXHg2NVxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjRcXHg2NScsJ1xceDY2XFx4NzJcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjFcXHg3NCcsJ1xceDYxXFx4NzRcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzNcXHg2MScsJ1xceDczXFx4NjdcXHgyZFxceDcwXFx4NzJcXHg2NVxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg3MFxceDY0XFx4NzhcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NmVcXHg2Y1xceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2OVxceDc0XFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCddO2Z1bmN0aW9uIEhvc3RuYW1lUmVzb2x2ZXIoKXt9SG9zdG5hbWVSZXNvbHZlci5nZXRTZXJ2aWNlSG9zdG5hbWVCeUNvbmZpZ3VyYXRpb249ZnVuY3Rpb24oY29uZmlndXJhdGlvbil7dmFyIF8xTGw9Wy40Njc1MzA3NzY3NTI2NTYsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2MlxceDZjXFx4NmZcXHg2MlxceDQ2XFx4NzdcXHg2M1xceDY5XFx4NmQnXTt2YXIgX1FPb1Ewb08wPWZ1bmN0aW9uKF9MTDExSUxsSSl7dmFyIF8kej1bMzE0NDgsMjgzMTAsJ1xceDZmXFx4NjJcXHg2NlxceDc1XFx4NzNcXHg2M1xceDYxXFx4NzRcXHg2NVxceDRjXFx4NjlcXHg3M1xceDc0JywnXFx4NzNcXHg3NFxceDYxXFx4NzRcXHg2NVxceDZkXFx4NjVcXHg2ZVxceDc0XFx4NDRcXHg2ZlxceDZkXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJywnXFx4NjRcXHg2ZlxceDYzXFx4NzVcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDRjXFx4NjlcXHg3M1xceDc0JywuNjIyNDAzNzE1MzU0MDM3OF07dmFyIF9MbDExTGlpbD1fJHpbM10sX09vME8wME9PPV8kels1XTt2YXIgX0lMMUlpbGwxPV8kelswXSxfaUlJSUwxbEw9XyR6WzRdO3ZhciBfb09PMFFRMFE9XyR6WzFdO3JldHVybiBfJHpbMl07fTtpZihjb25maWd1cmF0aW9uIGluIEhvc3RuYW1lUmVzb2x2ZXIuRE9NQUlOX1JFQUxNX0hPU1ROQU1FKXt2YXIgX1oyWlpzc3MkPV8xTGxbMl0sX2lJbDExaUxpPV8xTGxbMF07cmV0dXJuIEhvc3RuYW1lUmVzb2x2ZXIuRE9NQUlOX1JFQUxNX0hPU1ROQU1FW2NvbmZpZ3VyYXRpb25dO31lbHNle3JldHVybiBfMUxsWzFdO319O0hvc3RuYW1lUmVzb2x2ZXIuZ2V0U2VydmljZUhvc3RuYW1lQnlIb3N0bmFtZT1mdW5jdGlvbihob3N0bmFtZSl7dmFyIF9PME89WydcXHg2MlxceDZjXFx4NmZcXHg2MicsJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MicsJ1xceDcwXFx4NzJcXHg2ZlxceDY0JywnXFx4NmNcXHg2OVxceDczXFx4NzRcXHg0NVxceDZjJywuMzkwMzc0Njk1OTk2NzY5NTUsJ1xceDc0XFx4NjVcXHg3M1xceDc0JywuODMxNTU4MzgwNTE2NzAwMl07aWYoSG9zdG5hbWVSZXNvbHZlci5pc0RldmVsb3BtZW50KGhvc3RuYW1lKSl7dmFyIF8wT09vTzBPbz1fTzBPWzRdLF9vUVFPb28wMD1fTzBPWzZdLF9JbElsTGxpbD1fTzBPWzBdO3JldHVybiB0aGlzLmdldFNlcnZpY2VIb3N0QnlDb3VudHJ5Q29kZShfTzBPWzVdLHRoaXMuZ2V0Q291bnRyeUNvZGVQcmVmaXgoaG9zdG5hbWUpKTt9ZWxzZSBpZihIb3N0bmFtZVJlc29sdmVyLmlzUHJlUHJvZChob3N0bmFtZSkpe3ZhciBfMiRTMlp6WjI9X08wT1szXTtyZXR1cm4gdGhpcy5nZXRTZXJ2aWNlSG9zdEJ5Q291bnRyeUNvZGUoX08wT1sxXSx0aGlzLmdldENvdW50cnlDb2RlUHJlZml4KGhvc3RuYW1lKSk7fWVsc2V7dmFyIF9pMWlsbElMaT1mdW5jdGlvbihfejJzWlokUzIsX2kxaUlpaUxMLF9zU3p6JHNTWil7dmFyIF8xMUk9WydcXHg2YVxceDczXFx4NmZcXHg2ZVxceDQyXFx4NmZcXHg2NFxceDc5JywuODUyMDQwMjM1NTYxMDMzMywuNzMzODU0ODUwMDIzMzE2NCwuMDk1ODE0ODU1MTQ2NDcxNDgsJ1xceDZlXFx4NmZcXHg2NFxceDY1XFx4NDRcXHg2ZlxceDYzXFx4NzVcXHg2ZFxceDY1XFx4NmVcXHg3NCcsJ1xceDYxXFx4NGVcXHg2ZlxceDY0XFx4NjUnXTt2YXIgX1FPME9vb1FPPV8xMUlbM10sX2xMaTFJSUxpPV8xMUlbNF07dmFyIF9saUlsTExMbD1fMTFJWzVdLF8wUU9RT09Rbz1fMTFJWzJdLF9acyRzczIkMj1fMTFJWzBdO3JldHVybiBfMTFJWzFdO307dmFyIGNvdW50cnlDb2RlPUhvc3RuYW1lUmVzb2x2ZXIuZ2V0Q291bnRyeUNvZGVTdWZmaXgoaG9zdG5hbWUpO3JldHVybiB0aGlzLmdldFNlcnZpY2VIb3N0QnlDb3VudHJ5Q29kZShfTzBPWzJdLGNvdW50cnlDb2RlKTt9fTt2YXIgXzBRUU8wb28wPV9JbFsxNl0sX08wUU9Pb29RPV9JbFszMF0sX2wxMUlMTDFJPV9JbFszOV07SG9zdG5hbWVSZXNvbHZlci5nZXRTZXJ2aWNlSG9zdEJ5Q291bnRyeUNvZGU9ZnVuY3Rpb24oZG9tYWluLGNvdW50cnlDb2RlKXt2YXIgX2xpST1bJ1xceDJlJywnXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJ107cmV0dXJuIHRoaXMuZ2V0U2VydmljZUhvc3RuYW1lQnlDb25maWd1cmF0aW9uKGRvbWFpbitfbGlJWzBdK2NvdW50cnlDb2RlLnRvVXBwZXJDYXNlKCkrX2xpSVsxXSk7fTtIb3N0bmFtZVJlc29sdmVyLmlzRGV2ZWxvcG1lbnQ9ZnVuY3Rpb24oaG9zdG5hbWUpe3ZhciBfMiQ9WydcXHg2NFxceDY1XFx4NzZcXHgyZFxceDY0XFx4NzNcXHg2YicsJ1xceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDYzXFx4NmZcXHg2Y1xceDZjXFx4NjVcXHg2M1xceDc0XFx4NmZcXHg3MicsJ1xceDZjXFx4NmZcXHg2M1xceDYxXFx4NmNcXHg2OFxceDZmXFx4NzNcXHg3NCcsMzA4NzAsJ1xceDYyXFx4NDEnLCdcXHg2OVxceDZlXFx4NzRcXHg2NVxceDY3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCddO3ZhciBfSWlpTGkxaTE9XzIkWzZdLF9PME9RbzBvbz1fMiRbNV0sXzAwbzBPb09PPV8yJFszXTtyZXR1cm4gaG9zdG5hbWUuc3RhcnRzV2l0aChfMiRbMF0pJiZob3N0bmFtZS5lbmRzV2l0aChfMiRbMl0pfHxob3N0bmFtZS5zdGFydHNXaXRoKF8yJFs0XSl8fGhvc3RuYW1lLmVuZHNXaXRoKF8yJFs3XSl8fGhvc3RuYW1lLmVuZHNXaXRoKF8yJFsxXSk7fTtIb3N0bmFtZVJlc29sdmVyLmlzUHJlUHJvZD1mdW5jdGlvbihob3N0bmFtZSl7dmFyIF8xaT1bJ1xceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDcwXFx4NjRcXHg3OFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2NFxceDc1XFx4NjJcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjRcXHg3NVxceDYyXFx4MmVcXHg3OFxceDYzXFx4NmZcXHg3MlxceDcwXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzBcXHg3MlxceDY1XFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDcwXFx4NjRcXHg3OFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnXTtyZXR1cm4gaG9zdG5hbWUuZW5kc1dpdGgoXzFpWzRdKXx8aG9zdG5hbWUuZW5kc1dpdGgoXzFpWzBdKXx8aG9zdG5hbWUuZW5kc1dpdGgoXzFpWzFdKXx8aG9zdG5hbWUuZW5kc1dpdGgoXzFpWzJdKXx8aG9zdG5hbWUuZW5kc1dpdGgoXzFpWzNdKTt9O0hvc3RuYW1lUmVzb2x2ZXIuZ2V0Q291bnRyeUNvZGVQcmVmaXg9ZnVuY3Rpb24oaG9zdG5hbWUpe3ZhciBfT08wPVswLCdcXHgyZScsMSwnXFx4MmQnLCdcXHg3NVxceDczJywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHg0Y1xceDY5XFx4NzNcXHg3NFxceDQ4XFx4NjFcXHg3M1xceDY4J107dmFyIHNwbGl0cz1ob3N0bmFtZS5zcGxpdChfT08wWzNdKTtpZihzcGxpdHMubGVuZ3RoPl9PTzBbMl0pe3ZhciBwcmVmaXhfMT1zcGxpdHNbX09PMFswXV07dmFyIF8xTGxsaWwxST1fT08wWzVdO2lmKHRoaXMuQ09VTlRSWV9DT0RFUy5zb21lKGZ1bmN0aW9uKGUpe3ZhciBfaUk9W107dmFyIF9MTGxpaWwxTD1mdW5jdGlvbihfaTExTExJTGkpe3ZhciBfTDE9WydcXHg2ZlxceDYyXFx4NjZcXHg3NVxceDczXFx4NjNcXHg2MVxceDc0XFx4NjVcXHg0OVxceDY0JywuNTk2Mjg1MDIzNDkwMjY4OCwnXFx4NmZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1XFx4NDJcXHg2Y1xceDZmXFx4NjInLCdcXHg2ZVxceDZmXFx4NjRcXHg2NVxceDQyJywnXFx4NjVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjUnLCdcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHg0MlxceDZjXFx4NmZcXHg2MiddO3ZhciBfejJTelpTJFo9X0wxWzFdLF9PMFFRMDAwUT1fTDFbM10sX3N6MlNzWlpaPV9MMVs0XTt2YXIgX29RTzBRMG9PPV9MMVsyXSxfbElpTGxMaWk9X0wxWzVdO3JldHVybiBfTDFbMF07fTtyZXR1cm4gZT09PXByZWZpeF8xO30pKXt2YXIgX2lsSTExbGxsPWZ1bmN0aW9uKF8wb1FRUTAwTyxfeiQkJHNzelosX1oyJDJTJDIyKXt2YXIgXzJTcz1bLjUwNTA1MTYwMTQ0MzgyMjksLjI1NDcwMDQyOTY4MjQ5MDg1LDQ1Njk2LC41Mzc4MzkwODI3NDU0MDYzLCdcXHg2NlxceDc3XFx4NjNcXHg2OVxceDZkXFx4NDJcXHg2ZlxceDY0XFx4NzknLDMxMTExXTt2YXIgX1NzU3pzc1pTPV8yU3NbNV07dmFyIF96U3pTJHpzej1fMlNzWzRdLF9JMTExSUlMMT1fMlNzWzNdO3ZhciBfUU9RUW8wUU89XzJTc1swXSxfbzBPT1FPT1E9XzJTc1syXTtyZXR1cm4gXzJTc1sxXTt9O3JldHVybiBwcmVmaXhfMTt9fXNwbGl0cz1ob3N0bmFtZS5zcGxpdChfT08wWzFdKTtpZihzcGxpdHMubGVuZ3RoPl9PTzBbMl0pe3ZhciBwcmVmaXhfMj1zcGxpdHNbX09PMFswXV07aWYodGhpcy5DT1VOVFJZX0NPREVTLnNvbWUoZnVuY3Rpb24oZSl7dmFyIF8xbD1bXTtyZXR1cm4gZT09PXByZWZpeF8yO30pKXtyZXR1cm4gcHJlZml4XzI7fX1yZXR1cm4gX09PMFs0XTt9O0hvc3RuYW1lUmVzb2x2ZXIuZ2V0Q291bnRyeUNvZGVTdWZmaXg9ZnVuY3Rpb24oaG9zdG5hbWUpe3ZhciBfb1FvPVs2NjIyLCdcXHg3NVxceDczJywuNTg4MzIwODEzMDY1NTc2MiwxLCdcXHgyZSddO3ZhciBzcGxpdHM9aG9zdG5hbWUuc3BsaXQoX29Rb1s0XSk7aWYoc3BsaXRzLmxlbmd0aD5fb1FvWzNdKXt2YXIgc3VmZml4XzE9c3BsaXRzW3NwbGl0cy5sZW5ndGgtX29Rb1szXV07aWYodGhpcy5DT1VOVFJZX0NPREVTLnNvbWUoZnVuY3Rpb24oZSl7dmFyIF8xTEk9W107cmV0dXJuIGU9PT1zdWZmaXhfMTt9KSl7cmV0dXJuIHN1ZmZpeF8xO319dmFyIF9paUlpaUxMTD1fb1FvWzBdLF8kWlp6U3pTUz1fb1FvWzJdO3JldHVybiBfb1FvWzFdO307SG9zdG5hbWVSZXNvbHZlci5ET01BSU5fUkVBTE1fSE9TVE5BTUU9eydcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NGVcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzU1XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0ZVxceDQxXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMTldLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NGVcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzU2XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDU1XFx4NTNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs1NV0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NTVcXHg1M1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzE5XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDU1XFx4NTNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs1Nl0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0M1xceDQxXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMjJdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQzXFx4NDFcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs3NV0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0M1xceDQxXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNTFdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NGRcXHg1OFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzIxXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0ZFxceDU4XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNzZdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NGRcXHg1OFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzIwXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQxXFx4NTRcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs0NV0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDFcXHg1NFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzgzXSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDQxXFx4NTRcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs5XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDUzXFx4NDdcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs3M10sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NTNcXHg0N1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzg1XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDUzXFx4NDdcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs1M10sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0MVxceDU1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNThdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQxXFx4NTVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFsxM10sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0MVxceDU1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNF0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0NFxceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNzldLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ0XFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFsyM10sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0NFxceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbODBdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDVcXHg1NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzc5XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0NVxceDU1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMjNdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDVcXHg1NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzgwXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDUwXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFsyN10sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NTBcXHg0Y1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzM2XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDUwXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs3OF0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg1NFxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNzJdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDU0XFx4NTJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFszM10sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg1NFxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMzddLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDlcXHg1NFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzg3XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0OVxceDU0XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNDRdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDlcXHg1NFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzQ2XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQxXFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFszXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0MVxceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNjBdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDFcXHg0NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzBdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NGFcXHg1MFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzY0XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0YVxceDUwXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMzJdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NGFcXHg1MFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzQ5XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ2XFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs2NF0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDZcXHg0NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzMyXSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDQ2XFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs0OV0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0N1xceDQyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMzVdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ3XFx4NDJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFszNF0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0N1xceDQyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMTJdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NTVcXHg0YlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzM1XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg1NVxceDRiXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMzRdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NTVcXHg0YlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzEyXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDUzXFx4NDFcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs1XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg1M1xceDQxXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMjhdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NTNcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzE3XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ5XFx4NGVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs4XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0OVxceDRlXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNzddLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDlcXHg0ZVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzcxXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ1XFx4NDdcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs2OV0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDVcXHg0N1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzYyXSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDQ1XFx4NDdcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs1Ml0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0NlxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNTldLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ2XFx4NTJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs4MV0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0NlxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMjldLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDVcXHg1M1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzI1XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0NVxceDUzXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbMThdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDVcXHg1M1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzI0XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDRlXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs4Nl0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NGVcXHg0Y1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzI2XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDRlXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs3MF0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg1M1xceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNjZdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDUzXFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9JbFs2NV0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg1M1xceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNDhdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDJcXHg1MlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzExXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0MlxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfSWxbNDNdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDJcXHg1MlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X0lsWzQwXX07SG9zdG5hbWVSZXNvbHZlci5DT1VOVFJZX0NPREVTPVtfSWxbODJdLF9JbFsxNF0sX0lsWzYxXSxfSWxbNDFdLF9JbFsxXSxfSWxbMl0sX0lsWzYzXSxfSWxbNTBdLF9JbFsxMF0sX0lsWzY3XSxfSWxbMzhdLF9JbFs1NF0sX0lsWzU3XSxfSWxbODRdLF9JbFs3NF0sX0lsWzQyXSxfSWxbNl0sX0lsWzMxXSxfSWxbNjhdLF9JbFsxNV0sX0lsWzddLF9JbFs0N11dO3JldHVybiBIb3N0bmFtZVJlc29sdmVyO30oKTtleHBvcnRzLkhvc3RuYW1lUmVzb2x2ZXI9SG9zdG5hbWVSZXNvbHZlcjsiLCInXFx4NzVcXHg3M1xceDY1XFx4MjBcXHg3M1xceDc0XFx4NzJcXHg2OVxceDYzXFx4NzQnO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdcXHg1ZlxceDVmXFx4NjVcXHg3M1xceDRkXFx4NmZcXHg2NFxceDc1XFx4NmNcXHg2NScse3ZhbHVlOnRydWV9KTt2YXIgSG9zdG5hbWVSZXNvbHZlcl8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg0OFxceDZmXFx4NzNcXHg3NFxceDZlXFx4NjFcXHg2ZFxceDY1XFx4NTJcXHg2NVxceDczXFx4NmZcXHg2Y1xceDc2XFx4NjVcXHg3MicpO3ZhciBLYXRhbEVuZHBvaW50UmVzb2x2ZXI9ZnVuY3Rpb24oKXt2YXIgX2lMPVsnXFx4NjRcXHg2ZlxceDYzXFx4NzVcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDQyXFx4NmNcXHg2ZlxceDYyJywnXFx4NjFcXHg3MCcsJ1xceDY4XFx4NzRcXHg3NFxceDcwXFx4NzNcXHgzYVxceDJmXFx4MmZcXHg3OVxceDMzXFx4NmFcXHgzNVxceDY3XFx4MzlcXHg2NVxceDM2XFx4NzlcXHgzNFxceDJlXFx4NjVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjVcXHgyZFxceDYxXFx4NzBcXHg2OVxceDJlXFx4NzVcXHg3M1xceDJkXFx4NjVcXHg2MVxceDczXFx4NzRcXHgyZFxceDMxXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHg2MVxceDc3XFx4NzNcXHgyZVxceDYzXFx4NmZcXHg2ZFxceDJmXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZlxceDc2XFx4MzFcXHgyZlxceDZjXFx4NmZcXHg2NycsJ1xceDYyXFx4NDVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjUnLCdcXHg2OFxceDc0XFx4NzRcXHg3MFxceDczXFx4M2FcXHgyZlxceDJmXFx4NzZcXHgzM1xceDMyXFx4NjJcXHg2N1xceDY3XFx4NjJcXHg2ZFxceDZhXFx4NjFcXHgyZVxceDY1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1XFx4MmRcXHg2MVxceDcwXFx4NjlcXHgyZVxceDc1XFx4NzNcXHgyZFxceDc3XFx4NjVcXHg3M1xceDc0XFx4MmRcXHgzMlxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4NjFcXHg3N1xceDczXFx4MmVcXHg2M1xceDZmXFx4NmRcXHgyZlxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmZcXHg3NlxceDMxXFx4MmZcXHg2Y1xceDZmXFx4NjcnLCdcXHg2N1xceDYxXFx4NmRcXHg2ZFxceDYxJywnXFx4NjhcXHg3NFxceDc0XFx4NzBcXHg3M1xceDNhXFx4MmZcXHgyZlxceDZkXFx4NjJcXHg2NFxceDc2XFx4NjdcXHg2ZlxceDZhXFx4MzJcXHgzN1xceDY4XFx4MmVcXHg2NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NVxceDJkXFx4NjFcXHg3MFxceDY5XFx4MmVcXHg3NVxceDczXFx4MmRcXHg2NVxceDYxXFx4NzNcXHg3NFxceDJkXFx4MzFcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDYxXFx4NzdcXHg3M1xceDJlXFx4NjNcXHg2ZlxceDZkXFx4MmZcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJmXFx4NzZcXHgzMVxceDJmXFx4NmNcXHg2ZlxceDY3JywnXFx4NzBcXHg3MlxceDZmXFx4NjQnLCdcXHg2MlxceDY1XFx4NzRcXHg2MSddO2Z1bmN0aW9uIEthdGFsRW5kcG9pbnRSZXNvbHZlcigpe3ZhciBfeiRzU1okMlo9X2lMWzNdLF9Rb29vME9RUT1faUxbMF07fUthdGFsRW5kcG9pbnRSZXNvbHZlci5nZXRLYXRhbExvZ2dlckVuZHBvaW50PWZ1bmN0aW9uKCl7dmFyIF9pbGxJPVtdO3ZhciBfbDFsMTExaUw9ZnVuY3Rpb24oX3pTWjJTMnMyLF8xTDFpaWxMSSl7dmFyIF8kcz1bJ1xceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZScsNzMxNCwnXFx4NjJcXHg2Y1xceDZmXFx4NjInLCdcXHg2NVxceDZlXFx4NjNcXHg3MlxceDc5XFx4NzBcXHg3NFxceDQyJ107dmFyIF9MbEkxMWxJbD1fJHNbMl07dmFyIF9JMTFMaUxsbD1fJHNbMF0sX0lpTEkxSUxpPV8kc1szXTtyZXR1cm4gXyRzWzFdO307dmFyIHN0YWdlPXRoaXMuZ2V0U3RhZ2VCeUhvc3RuYW1lKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gdGhpcy5LQVRBTF9MT0dHRVJfRU5EUE9JTlRTX01BUFtzdGFnZV07fTtLYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0U3RhZ2VCeUhvc3RuYW1lPWZ1bmN0aW9uKGhvc3RuYW1lKXt2YXIgX1FRMD1bLjU2Mzc3NjUyNjczNjk2MV07dmFyIF9aMnMkWlNTJD1fUVEwWzBdO2lmKEhvc3RuYW1lUmVzb2x2ZXJfMS5Ib3N0bmFtZVJlc29sdmVyLmlzRGV2ZWxvcG1lbnQoaG9zdG5hbWUpKXtyZXR1cm4gdGhpcy5CRVRBX1NUQUdFO31lbHNlIGlmKEhvc3RuYW1lUmVzb2x2ZXJfMS5Ib3N0bmFtZVJlc29sdmVyLmlzUHJlUHJvZChob3N0bmFtZSkpe3ZhciBfbGlpMUxJbGw9ZnVuY3Rpb24oXyQkMlNTc3N6LF9zWnp6JFoyJCl7dmFyIF9MaWk9WydcXHg2ZlxceDYyXFx4NjZcXHg3NVxceDczXFx4NjNcXHg2MVxceDc0XFx4NjUnLC4yNTg3ODQyMTMwMTEzMjAyNiwnXFx4NjlcXHg2NFxceDQzXFx4NjFcXHg3MFxceDc0XFx4NjNcXHg2OFxceDYxXFx4NDVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjUnLDQ3MDgsMzUwMDgsJ1xceDY0XFx4NmZcXHg2ZFxceDQ1XFx4NmVcXHg2M1xceDcyXFx4NzlcXHg3MFxceDc0Jyw0OTY2OF07dmFyIF9zUyQkejIkJD1fTGlpWzVdLF8kenMkWiQkMj1fTGlpWzNdLF8wUW8wUTAwTz1fTGlpWzRdO3ZhciBfSUlsMWkxbDE9X0xpaVs2XSxfWnNTU3pTWlM9X0xpaVsxXSxfenpTelpaWiQ9X0xpaVsyXTtyZXR1cm4gX0xpaVswXTt9O3JldHVybiB0aGlzLkdBTU1BX1NUQUdFO31yZXR1cm4gdGhpcy5QUk9EX1NUQUdFO307S2F0YWxFbmRwb2ludFJlc29sdmVyLmdldFN0YWdlQnlIb3N0Q29uZmlnPWZ1bmN0aW9uKGhvc3RDb25maWcpe3ZhciBfWnMkPVsnXFx4MmUnLCdcXHg3NFxceDY1XFx4NzNcXHg3NCcsJ1xceDZlXFx4NzVcXHg2Y1xceDZjXFx4NDhcXHg2ZlxceDczXFx4NzRcXHg0M1xceDZmXFx4NmVcXHg2NlxceDY5XFx4NjcnLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzInLCdcXHg3MFxceDcyXFx4NmZcXHg2NCcsMF07dmFyIGNvbmZpZ3VyYXRpb249X1pzJFsyXTtpZihob3N0Q29uZmlnKXtjb25maWd1cmF0aW9uPWhvc3RDb25maWcuc3BsaXQoX1pzJFswXSlbX1pzJFs1XV07fXN3aXRjaChjb25maWd1cmF0aW9uKXtjYXNlIF9acyRbMV06cmV0dXJuIHRoaXMuQkVUQV9TVEFHRTtjYXNlIF9acyRbM106cmV0dXJuIHRoaXMuR0FNTUFfU1RBR0U7Y2FzZSBfWnMkWzRdOnJldHVybiB0aGlzLlBST0RfU1RBR0U7ZGVmYXVsdDpyZXR1cm4gdGhpcy5nZXRTdGFnZUJ5SG9zdG5hbWUod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCkpO319O0thdGFsRW5kcG9pbnRSZXNvbHZlci5nZXRQYWdlVHlwZU1ldHJpY05hbWU9ZnVuY3Rpb24oY2xpZW50RGF0YSl7dmFyIF9aJD1bJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2M1xceDZmXFx4NmVcXHg3NFxceDY1XFx4NzhcXHg3NCcsJ1xceDJlJywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDcyXFx4NjVcXHg2NlxceDJkXFx4NjlcXHg2NCddO3ZhciBfMWlMbDFpbEw9ZnVuY3Rpb24oX0lJaUxsMTFsKXt2YXIgX1Ewbz1bLjY3ODM4NDIxOTUwOTAxNDgsMzk5MDZdO3ZhciBfMlpaczIkMlo9X1Ewb1swXTtyZXR1cm4gX1Ewb1sxXTt9O2lmKGNsaWVudERhdGFbX1okWzJdXT09dGhpcy5BUF9DTElFTlRfSUQmJmNsaWVudERhdGFbX1okWzBdXSl7dHJ5e3ZhciBjbGllbnRDb250ZXh0PUpTT04ucGFyc2UoY2xpZW50RGF0YVtfWiRbMF1dKTtyZXR1cm4gY2xpZW50Q29udGV4dC5wYWdlVHlwZT9fWiRbMV0rY2xpZW50Q29udGV4dC5wYWdlVHlwZTp0aGlzLkVNUFRZX1NUUklORzt9Y2F0Y2goZXJyKXtyZXR1cm4gdGhpcy5FTVBUWV9TVFJJTkc7fX1yZXR1cm4gdGhpcy5FTVBUWV9TVFJJTkc7fTtLYXRhbEVuZHBvaW50UmVzb2x2ZXIuQkVUQV9TVEFHRT1faUxbOF07S2F0YWxFbmRwb2ludFJlc29sdmVyLkdBTU1BX1NUQUdFPV9pTFs1XTtLYXRhbEVuZHBvaW50UmVzb2x2ZXIuUFJPRF9TVEFHRT1faUxbN107dmFyIF8wMG9vUTBvUT1mdW5jdGlvbihfUVFPb1FRMFEpe3ZhciBfTGlpST1bNDU2MTIsNDk4OSwnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHg1M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzQnLC41MzQzNTgwMDU5MTM5MzYzLDQ0NjIwLCdcXHg2OFxceDYxXFx4NzNcXHg2OFxceDRhXFx4NzNcXHg2ZlxceDZlJywnXFx4NmZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1J107dmFyIF9TcyQyU3N6Wj1fTGlpSVs1XSxfSWxJTExpTGk9X0xpaUlbNF07dmFyIF8xSWwxbEkxST1fTGlpSVszXTt2YXIgX1pzc1NacyRzPV9MaWlJWzFdLF8wUVFvMFFvMD1fTGlpSVswXSxfc3NzMnMkMno9X0xpaUlbNl07cmV0dXJuIF9MaWlJWzJdO307S2F0YWxFbmRwb2ludFJlc29sdmVyLktBVEFMX0xPR0dFUl9FTkRQT0lOVFNfTUFQPXsnXFx4NjJcXHg2NVxceDc0XFx4NjEnOl9pTFs0XSwnXFx4NjdcXHg2MVxceDZkXFx4NmRcXHg2MSc6X2lMWzJdLCdcXHg3MFxceDcyXFx4NmZcXHg2NCc6X2lMWzZdfTtLYXRhbEVuZHBvaW50UmVzb2x2ZXIuRU1QVFlfU1RSSU5HPScnO0thdGFsRW5kcG9pbnRSZXNvbHZlci5BUF9DTElFTlRfSUQ9X2lMWzFdO3JldHVybiBLYXRhbEVuZHBvaW50UmVzb2x2ZXI7fSgpO2V4cG9ydHMuS2F0YWxFbmRwb2ludFJlc29sdmVyPUthdGFsRW5kcG9pbnRSZXNvbHZlcjsiLCInXFx4NzVcXHg3M1xceDY1XFx4MjBcXHg3M1xceDc0XFx4NzJcXHg2OVxceDYzXFx4NzQnO3ZhciBfX2ltcG9ydERlZmF1bHQ9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKG1vZCl7dmFyIF9paT1bXTtyZXR1cm4gbW9kJiZtb2QuX19lc01vZHVsZT9tb2Q6eydcXHg2NFxceDY1XFx4NjZcXHg2MVxceDc1XFx4NmNcXHg3NCc6bW9kfTt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdcXHg1ZlxceDVmXFx4NjVcXHg3M1xceDRkXFx4NmZcXHg2NFxceDc1XFx4NmNcXHg2NScse3ZhbHVlOnRydWV9KTt2YXIgYnVpbGRfdXJsX3RzXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoJ1xceDYyXFx4NzVcXHg2OVxceDZjXFx4NjRcXHgyZFxceDc1XFx4NzJcXHg2Y1xceDJkXFx4NzRcXHg3MycpKTtyZXF1aXJlKCdcXHgyZVxceDJmXFx4NjNcXHg3M1xceDczXFx4MmZcXHg2OVxceDY2XFx4NzJcXHg2MVxceDZkXFx4NjVcXHgyZVxceDYzXFx4NzNcXHg3MycpO3ZhciBBQ0lDU2Vzc2lvbkNvbnRleHRfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZlxceDQxXFx4NDNcXHg0OVxceDQzXFx4NTNcXHg2NVxceDczXFx4NzNcXHg2OVxceDZmXFx4NmVcXHg0M1xceDZmXFx4NmVcXHg3NFxceDY1XFx4NzhcXHg3NCcpO3ZhciBBQ0lDQ2xpZW50UmVxdWVzdF8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJmXFx4NDFcXHg0M1xceDQ5XFx4NDNcXHg0M1xceDZjXFx4NjlcXHg2NVxceDZlXFx4NzRcXHg1MlxceDY1XFx4NzFcXHg3NVxceDY1XFx4NzNcXHg3NCcpO3ZhciBBQW1hdGlvblJlc3VsdF8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJmXFx4NDFcXHg0MVxceDZkXFx4NjFcXHg3NFxceDY5XFx4NmZcXHg2ZVxceDUyXFx4NjVcXHg3M1xceDc1XFx4NmNcXHg3NCcpO3ZhciBBQ0lDVXNlclJlc3BvbnNlXzE9cmVxdWlyZSgnXFx4MmVcXHgyZlxceDY0XFx4NjFcXHg3NFxceDYxXFx4MmZcXHg0MVxceDQzXFx4NDlcXHg0M1xceDU1XFx4NzNcXHg2NVxceDcyXFx4NTJcXHg2NVxceDczXFx4NzBcXHg2ZlxceDZlXFx4NzNcXHg2NScpO3ZhciBIb3N0bmFtZVJlc29sdmVyXzE9cmVxdWlyZSgnXFx4MmVcXHgyZlxceDQ4XFx4NmZcXHg3M1xceDc0XFx4NmVcXHg2MVxceDZkXFx4NjVcXHg1MlxceDY1XFx4NzNcXHg2ZlxceDZjXFx4NzZcXHg2NVxceDcyJyk7dmFyIEFDSUNFcnJvcl8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJmXFx4NDFcXHg0M1xceDQ5XFx4NDNcXHg0NVxceDcyXFx4NzJcXHg2ZlxceDcyJyk7dmFyIGthdGFsX2xvZ2dlcl8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKCdcXHg0MFxceDYxXFx4NmRcXHg3YVxceDZlXFx4MmZcXHg2YlxceDYxXFx4NzRcXHg2MVxceDZjXFx4MmRcXHg2Y1xceDZmXFx4NjdcXHg2N1xceDY1XFx4NzInKSk7dmFyIEthdGFsRW5kcG9pbnRSZXNvbHZlcl8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg0YlxceDYxXFx4NzRcXHg2MVxceDZjXFx4NDVcXHg2ZVxceDY0XFx4NzBcXHg2ZlxceDY5XFx4NmVcXHg3NFxceDUyXFx4NjVcXHg3M1xceDZmXFx4NmNcXHg3NlxceDY1XFx4NzInKTt2YXIga2F0YWxfbWV0cmljc18xPXJlcXVpcmUoJ1xceDQwXFx4NjFcXHg2ZFxceDdhXFx4NmVcXHgyZlxceDZiXFx4NjFcXHg3NFxceDYxXFx4NmNcXHgyZFxceDZkXFx4NjVcXHg3NFxceDcyXFx4NjlcXHg2M1xceDczJyk7dmFyIGthdGFsX21ldHJpY3NfZHJpdmVyX3N1c2hpXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoJ1xceDQwXFx4NjFcXHg2ZFxceDdhXFx4NmVcXHgyZlxceDZiXFx4NjFcXHg3NFxceDYxXFx4NmNcXHgyZFxceDZkXFx4NjVcXHg3NFxceDcyXFx4NjlcXHg2M1xceDczXFx4MmRcXHg2NFxceDcyXFx4NjlcXHg3NlxceDY1XFx4NzJcXHgyZFxceDczXFx4NzVcXHg3M1xceDY4XFx4NjknKSk7dmFyIHJlc2l6ZV9vYnNlcnZlcl9wb2x5ZmlsbF8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKCdcXHg3MlxceDY1XFx4NzNcXHg2OVxceDdhXFx4NjVcXHgyZFxceDZmXFx4NjJcXHg3M1xceDY1XFx4NzJcXHg3NlxceDY1XFx4NzJcXHgyZFxceDcwXFx4NmZcXHg2Y1xceDc5XFx4NjZcXHg2OVxceDZjXFx4NmMnKSk7dmFyIEFDSUM9ZnVuY3Rpb24oKXt2YXIgXzBRPVt0cnVlLCdcXHg0MVxceDQzXFx4NDlcXHg0MycsJ1xceDYyXFx4NmNcXHg2ZlxceDYyJywnXFx4NTBcXHg0MVxceDUzXFx4NTMnLCdcXHg2MVxceDZkXFx4N2FcXHgyZFxceDYxXFx4NjFcXHg2ZFxceDYxXFx4NzRcXHg2OVxceDZmXFx4NmVcXHgyZFxceDcyXFx4NjVcXHg3M1xceDcwJywnXFx4NzNcXHg3NFxceDYxXFx4NzRcXHg2OVxceDYzXFx4NTNcXHg2NVxceDczXFx4NzNcXHg2OVxceDZmXFx4NmVcXHg1NFxceDZmXFx4NmJcXHg2NVxceDZlJywnXFx4NzNcXHg3NFxceDYxXFx4NzRcXHg2OVxceDYzXFx4NDNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4NDNcXHg2ZlxceDZlXFx4NzRcXHg2NVxceDc4XFx4NzQnLCdcXHgyZlxceDYxXFx4NjFcXHg3NVxceDc0XFx4MmZcXHg3NlxceDY1XFx4NzJcXHg2OVxceDY2XFx4NzlcXHgyZicsJ1xceDYyXFx4NmZcXHg2NFxceDc5XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJywnXFx4NmZcXHg2ZVxceDY1XFx4NzJcXHg3MlxceDZmXFx4NzInLCdcXHgzMScsJ1xceDY5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NScsbnVsbCwxNWUzLDNdO2Z1bmN0aW9uIEFDSUMoYWNpY0thdGFsTG9nZ2VyKXt0aGlzLmxvZ2dlcj17bG9nOmZ1bmN0aW9uKGFyZ3Mpe3ZhciBfczI9W107dmFyIF9PT29Rb09PTz1mdW5jdGlvbihfaUkxMUlMTDEsX09vT09PT1FvKXt2YXIgXzAwPVsuOTI0ODU1OTMzMDUzMjk0NCwuODM0NzUyMDg2NDY0NTcxLC42MzM5MzcxNjgyNTE4MzMxXTt2YXIgX28wb1Fvb09RPV8wMFsxXSxfJFMyU3Mkelo9XzAwWzJdO3JldHVybiBfMDBbMF07fTt9fTt0aGlzLnNlc3Npb25Db250ZXh0PW5ldyBBQ0lDU2Vzc2lvbkNvbnRleHRfMS5BQ0lDU2Vzc2lvbkNvbnRleHQoKTt0aGlzLl9vbmVycm9yPV8wUVsxMl07aWYoYWNpY0thdGFsTG9nZ2VyIT1fMFFbMTJdKXt2YXIgX0xMSUlpaTFJPWZ1bmN0aW9uKF9JbGlMTGlMbCxfMWkxSTFpSWkpe3ZhciBfUU89WydcXHg3M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzQnLDQ2MjQ5LDI2MjY3LC4xMjIwNTIzMzU4NjI0MDEyN107dmFyIF8kUzJ6U3paMj1fUU9bM10sX29vMDAwME9RPV9RT1syXTt2YXIgX1FPUU9vME9RPV9RT1swXTtyZXR1cm4gX1FPWzFdO307dGhpcy5hY2ljS2F0YWxMb2dnZXI9YWNpY0thdGFsTG9nZ2VyO31lbHNle3RoaXMuYWNpY0thdGFsTG9nZ2VyPXRoaXMuc2V0dXBLYXRhbExvZ2dlcigpO310aGlzLnNldHVwSWZyYW1lRXZlbnRMaXN0ZW5lcigpO31PYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQy5wcm90b3R5cGUsXzBRWzExXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF8xMT1bXTt2YXIgX0lpbGlsTGlJPWZ1bmN0aW9uKF9Tc3MyMiQkJCl7dmFyIF8xST1bJ1xceDY1XFx4NmVcXHg2M1xceDcyXFx4NzlcXHg3MFxceDc0JywxNjczMSwuMjI5NzQ2NTE1NzYxMzk2MjYsJ1xceDZmXFx4NjJcXHg2NlxceDc1XFx4NzNcXHg2M1xceDYxXFx4NzRcXHg2NVxceDQ1XFx4NmMnLC4zNjY3MjY3MzE3OTk3MTY1LC43MDE2ODE4ODI3NDMzNzQ2XTt2YXIgXzFsTGxsbElsPV8xSVs1XSxfaUlMaWxMMTE9XzFJWzNdLF9TJFMkMjJ6JD1fMUlbMV07dmFyIF96UyRzJFNaWj1fMUlbMF0sX0kxaUlpbGwxPV8xSVsyXSxfMG8wME9PUTA9XzFJWzRdO3JldHVybiBfMUlbMF07fTtyZXR1cm4gdGhpcy5faWZyYW1lO30sZW51bWVyYWJsZTpfMFFbMF0sY29uZmlndXJhYmxlOl8wUVswXX0pO0FDSUMucHJvdG90eXBlLnNldHVwQUNJQz1mdW5jdGlvbihjbGllbnRJbnB1dERhdGEpe3ZhciBfaWw9WydcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NzRcXHg2OVxceDZkXFx4NjVcXHg2ZlxceDc1XFx4NzQnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjhcXHg2ZlxceDczXFx4NzQnLGZhbHNlLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NmRcXHg2ZlxceDY0XFx4NjUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NzVcXHg3M1xceDY1XFx4MmRcXHg3MFxceDZmXFx4NzNcXHg3NFxceDJkXFx4NzJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzRcXHgyZFxceDZkXFx4NjVcXHg3NFxceDY4XFx4NmZcXHg2NCcsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2OVxceDY2XFx4NzJcXHg2MVxceDZkXFx4NjVcXHgyZFxceDY5XFx4NjQnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjhcXHg2ZlxceDczXFx4NzRcXHgyZFxceDYzXFx4NmZcXHg2ZVxceDY2XFx4NjlcXHg2NycsbnVsbCwnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY1XFx4NzJcXHg3MlxceDZmXFx4NzJcXHgyZFxceDYzXFx4NjFcXHg2Y1xceDZjXFx4NjJcXHg2MVxceDYzXFx4NmInXTt2YXIgc2VydmljZUhvc3Q9Y2xpZW50SW5wdXREYXRhW19pbFsxXV18fF9pbFs3XTt2YXIgY29uZmlndXJhdGlvbj1jbGllbnRJbnB1dERhdGFbX2lsWzZdXXx8X2lsWzddO3RoaXMuc2V0U2VydmljZUhvc3Qoc2VydmljZUhvc3QsY29uZmlndXJhdGlvbik7dGhpcy5fb25lcnJvcj1jbGllbnRJbnB1dERhdGFbX2lsWzhdXXx8X2lsWzddO3RoaXMuc2V0Q2xpZW50UmVxdWVzdChjbGllbnRJbnB1dERhdGEpO3RoaXMubW9kZT1jbGllbnRJbnB1dERhdGFbX2lsWzNdXXx8X2lsWzddO3RoaXMudGltZW91dD1jbGllbnRJbnB1dERhdGFbX2lsWzBdXXx8QUNJQy5ERUZBVUxUX1JFUVVFU1RfVElNRU9VVDt0aGlzLnVzZVJlcXVlc3RNZXRob2RQb3N0PWNsaWVudElucHV0RGF0YVtfaWxbNF1dfHxfaWxbMl07dGhpcy5lbmFibGVDdXN0b21pemVkSWZyYW1lPWNsaWVudElucHV0RGF0YVtfaWxbNV1dO2lmKHRoaXMuZW5hYmxlQ3VzdG9taXplZElmcmFtZSl7dGhpcy5faWZyYW1lPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNsaWVudElucHV0RGF0YVtfaWxbNV1dKTt9dGhpcy5zZXRLYXRhbE1ldHJpY3MoY2xpZW50SW5wdXREYXRhKTt0aGlzLnNlbmRBcm5vbGRIdHRwUmVxdWVzdCh0aGlzLmNyZWF0ZU5ld1Nlc3Npb25SZXF1ZXN0VVJMKCksdGhpcy50aW1lb3V0KTt9O0FDSUMucHJvdG90eXBlLnNldHVwQUNJQ2ZvckFzeW5jUmVwb3J0aW5nPWZ1bmN0aW9uKGNsaWVudElucHV0RGF0YSl7dmFyIF9JTD1bbnVsbCwnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY4XFx4NmZcXHg3M1xceDc0XFx4MmRcXHg2M1xceDZmXFx4NmVcXHg2NlxceDY5XFx4NjcnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDQ1XFx4NmMnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjhcXHg2ZlxceDczXFx4NzQnXTt2YXIgc2VydmljZUhvc3Q9Y2xpZW50SW5wdXREYXRhW19JTFszXV18fF9JTFswXTt2YXIgY29uZmlndXJhdGlvbj1jbGllbnRJbnB1dERhdGFbX0lMWzFdXXx8X0lMWzBdO3RoaXMuc2V0U2VydmljZUhvc3Qoc2VydmljZUhvc3QsY29uZmlndXJhdGlvbik7dGhpcy5zZXRDbGllbnRSZXF1ZXN0KGNsaWVudElucHV0RGF0YSk7aWYod2luZG93Lm5hdmlnYXRvciYmbmF2aWdhdG9yLnNlbmRCZWFjb24pe3ZhciBfUzIkcyRaU1M9X0lMWzJdO25hdmlnYXRvci5zZW5kQmVhY29uKHRoaXMuY3JlYXRlTmV3U2Vzc2lvblJlcXVlc3RVUkwoKSxKU09OLnN0cmluZ2lmeSh0aGlzLmNsaWVudFJlcXVlc3QpKTt9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQy5wcm90b3R5cGUsXzBRWzldLHtzZXQ6ZnVuY3Rpb24ob25FcnJvcil7dmFyIF9RMD1bNDI4MDEsODYyNl07dmFyIF96UzIyJFMkWj1fUTBbMF0sXyRac3NTWjJaPV9RMFsxXTt0aGlzLl9vbmVycm9yPW9uRXJyb3I7fSxlbnVtZXJhYmxlOl8wUVswXSxjb25maWd1cmFibGU6XzBRWzBdfSk7QUNJQy5wcm90b3R5cGUuc2V0U2VydmljZUhvc3Q9ZnVuY3Rpb24oc2VydmljZUhvc3QsY29uZmlndXJhdGlvbil7dmFyIF9vbz1bMzYwNTUsJ1xceDZlXFx4NmZcXHg2NFxceDY1XFx4NGFcXHg3M1xceDZmXFx4NmVcXHg0NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0JyxudWxsLDE1MzQ0LCdcXHg2OFxceDc0XFx4NzRcXHg3MFxceDczXFx4M2FcXHgyZlxceDJmJywuOTEyMjE0ODg3Nzk2ODc1NF07aWYoc2VydmljZUhvc3Q9PV9vb1syXSl7aWYoY29uZmlndXJhdGlvbiE9X29vWzJdKXtzZXJ2aWNlSG9zdD1Ib3N0bmFtZVJlc29sdmVyXzEuSG9zdG5hbWVSZXNvbHZlci5nZXRTZXJ2aWNlSG9zdG5hbWVCeUNvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7fWVsc2V7dmFyIF9RMG9vUU8wUT1fb29bNV0sX1MyMloyc1okPV9vb1sxXTtzZXJ2aWNlSG9zdD1Ib3N0bmFtZVJlc29sdmVyXzEuSG9zdG5hbWVSZXNvbHZlci5nZXRTZXJ2aWNlSG9zdG5hbWVCeUhvc3RuYW1lKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpKTt9fXZhciBfT29PT1FRME89X29vWzBdLF9sbGlMMWlMTD1fb29bM107dGhpcy5zZXJ2aWNlRW5kcG9pbnQ9X29vWzRdK3NlcnZpY2VIb3N0K0FDSUMuU0VSVklDRV9CQVNFX1BBVEg7fTtBQ0lDLnByb3RvdHlwZS5zZXR1cEthdGFsTG9nZ2VyPWZ1bmN0aW9uKCl7dmFyIF9vMD1bXTt2YXIgYWNpY0thdGFsTG9nZ2VyPW5ldyBrYXRhbF9sb2dnZXJfMS5kZWZhdWx0KHt1cmw6S2F0YWxFbmRwb2ludFJlc29sdmVyXzEuS2F0YWxFbmRwb2ludFJlc29sdmVyLmdldEthdGFsTG9nZ2VyRW5kcG9pbnQoKX0pO3JldHVybiBhY2ljS2F0YWxMb2dnZXI7fTtBQ0lDLnByb3RvdHlwZS5zZW5kRXJyb3JUb0thdGFsTG9nZ2VyPWZ1bmN0aW9uKGVycm9yTWVzc2FnZSxlcnJvckNvbnRleHQpe3ZhciBfWnM9WydcXHg3M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0NlxceDc3XFx4NjNcXHg2OVxceDZkJywnXFx4NjVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzRcXHg0MicsJ1xceDZlXFx4NmZcXHg2NFxceDY1XFx4NDhcXHg2MVxceDczXFx4NjgnLCdcXHg2MVxceDcwJ107aWYoZXJyb3JDb250ZXh0LkNJRD09PV9ac1szXSl7dmFyIF9JbDFMaUxJTD1mdW5jdGlvbihfUW8wb1FRMFEsXzFMTElMbGlMKXt2YXIgXzBRTz1bMTM1NDIsJ1xceDYzXFx4NjFcXHg3MFxceDc0XFx4NjNcXHg2OFxceDYxXFx4NDRcXHg2ZlxceDYzXFx4NzVcXHg2ZFxceDY1XFx4NmVcXHg3NCcsNDQxNzAsJ1xceDZjXFx4NjlcXHg3M1xceDc0XFx4NDJcXHg2ZlxceDY0XFx4NzknLCdcXHg2MlxceDQ0XFx4NmZcXHg2M1xceDc1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0M1xceDYxXFx4NzBcXHg3NFxceDYzXFx4NjhcXHg2MSddO3ZhciBfU3N6JFMkWlM9XzBRT1syXTt2YXIgX0lMSTFpMWxMPV8wUU9bMF0sX29vb29PUU9vPV8wUU9bNF0sXzBRUVEwME9RPV8wUU9bMV07cmV0dXJuIF8wUU9bM107fTtyZXR1cm47fXZhciBfczJTU3NaU3o9ZnVuY3Rpb24oX1oyenNzJHpzKXt2YXIgXzAwbz1bLjI2OTIwMDY5MjMzMjkzMDIsLjIzNDc2NTA3NDQwMzkzOCw4NzQ5LC4zMzQzODEyMTAzNjY5NzY1NCwuMzMzMDU1MzA5ODk4NTM1OCwuODEyMjczODM5Nzk3Njk5NCwnXFx4NjVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjUnLC4yNTQwMzY5MzMwNjY2NDksMjYwNzcsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4NDVcXHg2YyddO3ZhciBfUU8wT09RT089XzAwb1s3XSxfb1FRTzBvMG89XzAwb1s1XSxfSWlpTExJaTE9XzAwb1s5XTt2YXIgX2lJaWxsTDFJPV8wMG9bNl0sX3pTJFN6WlNTPV8wMG9bOF0sX2xpbElpaWlJPV8wMG9bMF07dmFyIF9vME8wT09Pbz1fMDBvWzFdLF9JTGlJMUlsaT1fMDBvWzJdLF9zc3N6ejIkJD1fMDBvWzNdO3JldHVybiBfMDBvWzRdO307dHJ5e3ZhciBfMjJzMnMkU3o9X1pzWzBdLF8wT09RMFEwTz1fWnNbMV0sX2kxMWkxbDFpPV9ac1syXTt0aGlzLmFjaWNLYXRhbExvZ2dlci5lcnJvcihlcnJvck1lc3NhZ2UsZXJyb3JDb250ZXh0KTt9Y2F0Y2goZSl7fX07QUNJQy5wcm90b3R5cGUuc2V0S2F0YWxNZXRyaWNzPWZ1bmN0aW9uKGNsaWVudElucHV0RGF0YSl7dmFyIF8wTz1bJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg3MlxceDY1XFx4NjZcXHgyZFxceDY5XFx4NjQnLCdcXHgyZScsJ1xceDU1XFx4NTNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjhcXHg2ZlxceDczXFx4NzRcXHgyZFxceDYzXFx4NmZcXHg2ZVxceDY2XFx4NjlcXHg2NyddO3ZhciBfdGhpcz10aGlzO3ZhciBtZXRyaWNzRXJyb3JIYW5kbGVyPWZ1bmN0aW9uKGVycil7dmFyIF9aej1bJ1xceDQ2XFx4NjFcXHg2OVxceDZjXFx4NjVcXHg2NFxceDIwXFx4NzRcXHg2ZlxceDIwXFx4NzBcXHg3NVxceDYyXFx4NmNcXHg2OVxceDczXFx4NjhcXHgyMFxceDc0XFx4NjhcXHg2NVxceDIwXFx4NmRcXHg2NVxceDc0XFx4NzJcXHg2OVxceDYzXFx4NzNcXHgyZScsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg3MlxceDY1XFx4NjZcXHgyZFxceDY5XFx4NjQnXTt2YXIgX3NzWjJzejJ6PWZ1bmN0aW9uKF8ycyRzWiR6MixfT1FvUTBPMFEpe3ZhciBfbGk9Wy44NDk1MDM0Mjk0NDMyMDkzLC4yOTQ4OTQ1NzgzNDQyNjUxMywxMTIwMV07dmFyIF9vb1Fvb08wUT1fbGlbMl0sX0xsbGxMTDFsPV9saVswXTtyZXR1cm4gX2xpWzFdO307X3RoaXMuc2VuZEVycm9yVG9LYXRhbExvZ2dlcihfWnpbMF0seydcXHg0NVxceDUyXFx4NTJcXHg0ZlxceDUyJzplcnIsJ1xceDQzXFx4NDlcXHg0NCc6Y2xpZW50SW5wdXREYXRhW19aelsxXV19KTt9O3ZhciBkb21haW49S2F0YWxFbmRwb2ludFJlc29sdmVyXzEuS2F0YWxFbmRwb2ludFJlc29sdmVyLmdldFN0YWdlQnlIb3N0Q29uZmlnKGNsaWVudElucHV0RGF0YVtfME9bM11dKTt2YXIgX1FRT1FRUVFPPWZ1bmN0aW9uKF9sMUwxMWwxSSxfMUlMSUlpbDEpe3ZhciBfMUw9Wy44Njg5ODk2NzMwOTA4NDAyLC41MjcyNzM3MDA2MDA3NTEzLDM5NjgyLC41ODUyNDU4NTcxMjAzNDk2LCdcXHg3M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0Y1xceDY5XFx4NzNcXHg3NCcsMjQxN107dmFyIF9Rb1FRUVFPMD1fMUxbNF0sXzIyJCQkWloyPV8xTFs1XSxfMiQyMnpTeno9XzFMWzFdO3ZhciBfaWlMSTExbEw9XzFMWzJdLF8kJDIyelpzJD1fMUxbM107cmV0dXJuIF8xTFswXTt9O3ZhciBtZXRyaWNzRHJpdmVyPW5ldyBrYXRhbF9tZXRyaWNzX2RyaXZlcl9zdXNoaV8xLmRlZmF1bHQuQnVpbGRlcigpLndpdGhEb21haW5SZWFsbShkb21haW4sXzBPWzJdKS53aXRoRXJyb3JIYW5kbGVyKG1ldHJpY3NFcnJvckhhbmRsZXIpLmJ1aWxkKCk7dmFyIGthdGFsTWV0cmljc1NlcnZpY2VOYW1lPWNsaWVudElucHV0RGF0YVtfME9bMF1dK0thdGFsRW5kcG9pbnRSZXNvbHZlcl8xLkthdGFsRW5kcG9pbnRSZXNvbHZlci5nZXRQYWdlVHlwZU1ldHJpY05hbWUoY2xpZW50SW5wdXREYXRhKStfME9bMV0rd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO3ZhciBpbml0aWFsTWV0cmljc0NvbnRleHQ9bmV3IGthdGFsX21ldHJpY3NfMS5Db250ZXh0LkJ1aWxkZXIoKS53aXRoU2l0ZShBQ0lDLktBVEFMX01FVFJJQ1NfU0VSVklDRV9OQU1FKS53aXRoU2VydmljZU5hbWUoa2F0YWxNZXRyaWNzU2VydmljZU5hbWUpLmJ1aWxkKCk7dGhpcy5hY2ljS2F0YWxNZXRyaWNzUHVibGlzaGVyPW5ldyBrYXRhbF9tZXRyaWNzXzEuUHVibGlzaGVyKG1ldHJpY3NEcml2ZXIsbWV0cmljc0Vycm9ySGFuZGxlcixpbml0aWFsTWV0cmljc0NvbnRleHQpO307QUNJQy5wcm90b3R5cGUuc2V0Q2xpZW50UmVxdWVzdD1mdW5jdGlvbihkYXRhKXt2YXIgXzBPMD1bJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2M1xceDZmXFx4NmVcXHg3NFxceDY1XFx4NzhcXHg3NCcsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2MlxceDc5XFx4NzBcXHg2MVxceDczXFx4NzNcXHgyZFxceDZkXFx4NjVcXHg2M1xceDY4XFx4NjFcXHg2ZVxceDY5XFx4NzNcXHg2ZCcsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2Y1xceDZmXFx4NjNcXHg2MVxceDZjXFx4NjUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjFcXHg2MVxceDJkXFx4NjVcXHg3OFxceDc0XFx4NjVcXHg3MlxceDZlXFx4NjFcXHg2Y1xceDJkXFx4NzRcXHg2ZlxceDZiXFx4NjVcXHg2ZScsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2MVxceDYxXFx4NmRcXHg2MVxceDc0XFx4NjlcXHg2ZlxceDZlXFx4MmRcXHg3NFxceDZmXFx4NmJcXHg2NVxceDZlJywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY1XFx4NzZcXHg2NVxceDZlXFx4NzRcXHgyZFxceDc0XFx4NzJcXHg2OVxceDY3XFx4NjdcXHg2NVxceDcyJywuOTM5NTQ1NjM1NTM5NzIxMSwnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDZkXFx4NmZcXHg2NFxceDY1JywnXFx4NDNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4MjBcXHg2M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiXFx4MjBcXHg2NlxceDc1XFx4NmVcXHg2M1xceDc0XFx4NjlcXHg2ZlxceDZlXFx4MjBcXHg2OVxceDczXFx4MjBcXHg2ZVxceDZmXFx4NzRcXHgyMFxceDcwXFx4NzJcXHg2ZlxceDc2XFx4NjlcXHg2NFxceDY1XFx4NjQnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjZcXHg2ZlxceDcyXFx4NjNcXHg2NVxceDJkXFx4NmFcXHg3M1xceDJkXFx4NjZcXHg2Y1xceDc1XFx4NzNcXHg2OCcsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2NVxceDc4XFx4NzRcXHg2NVxceDcyXFx4NmVcXHg2MVxceDZjXFx4MmRcXHg2OVxceDY0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYzXFx4NjFcXHg2Y1xceDZjXFx4NjJcXHg2MVxceDYzXFx4NmInLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4NGNcXHg2ZlxceDYxXFx4NjRcXHg0M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiJywuNTY4MDY3MzA3MTg5MzQ1OCwnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDJkXFx4NzRcXHg3OVxceDcwXFx4NjUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjRcXHg2OVxceDczXFx4NmRcXHg2OVxceDczXFx4NzNcXHg0M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiJywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY2XFx4NzdcXHg2M1xceDY5XFx4NmQnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjhcXHg2NVxceDYxXFx4NjRcXHg2NVxceDcyXFx4MmRcXHg2NlxceDZmXFx4NmZcXHg3NFxceDY1XFx4NzInLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NmRcXHg2ZlxceDY0XFx4NjFcXHg2YycsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg3MlxceDY1XFx4NjZcXHgyZFxceDY5XFx4NjQnLCdcXHg2ZVxceDZmXFx4NjRcXHg2NVxceDQ0XFx4NmZcXHg2ZCcsJ1xceDQzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDIwXFx4NzJcXHg2NVxceDY2XFx4NjVcXHg3MlxceDY1XFx4NmVcXHg2M1xceDY1XFx4MjBcXHg2OVxceDY0XFx4MjBcXHg2OVxceDczXFx4MjBcXHg2ZVxceDZmXFx4NzRcXHgyMFxceDcwXFx4NzJcXHg2ZlxceDc2XFx4NjlcXHg2NFxceDY1XFx4NjQnXTtpZighZGF0YVtfME8wWzE5XV0pe3Rocm93IG5ldyBFcnJvcihfME8wWzIxXSk7fWlmKCFkYXRhW18wTzBbMTFdXSl7dmFyIF96U3pTc3Mkej1fME8wWzZdLF9JSUxsSTFJMT1fME8wWzEzXSxfb29vT1FRUTA9XzBPMFsyMF07dGhyb3cgbmV3IEVycm9yKF8wTzBbOF0pO310aGlzLmNsaWVudFJlcXVlc3Q9bmV3IEFDSUNDbGllbnRSZXF1ZXN0XzEuQUNJQ0NsaWVudFJlcXVlc3QoZGF0YVtfME8wWzE5XV0sZGF0YVtfME8wWzExXV0sZGF0YVtfME8wWzE1XV0sZGF0YVtfME8wWzEyXV0sZGF0YVtfME8wWzBdXSxkYXRhW18wTzBbMl1dLGRhdGFbXzBPMFsxNl1dLGRhdGFbXzBPMFsxMF1dLGRhdGFbXzBPMFsxN11dLGRhdGFbXzBPMFsxXV0sZGF0YVtfME8wWzE4XV0sZGF0YVtfME8wWzE0XV0sZGF0YVtfME8wWzddXSxkYXRhW18wTzBbNV1dLGRhdGFbXzBPMFszXV0sZGF0YVtfME8wWzldXSxkYXRhW18wTzBbNF1dKTt9O0FDSUMucHJvdG90eXBlLnNldHVwSWZyYW1lRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbigpe3ZhciBfMno9WydcXHg3M1xceDY1XFx4NzRcXHg3NVxceDcwXFx4NDlcXHg2NlxceDcyXFx4NjFcXHg2ZFxceDY1XFx4NDVcXHg3NlxceDY1XFx4NmVcXHg3NFxceDRjXFx4NjlcXHg3M1xceDc0XFx4NjVcXHg2ZVxceDY1XFx4NzInLCdcXHg2ZFxceDY1XFx4NzNcXHg3M1xceDYxXFx4NjdcXHg2NSddO3ZhciBfdGhpcz10aGlzO3RoaXMubG9nZ2VyLmxvZyhfMnpbMF0pO3ZhciBfaUxpSUlJaTE9ZnVuY3Rpb24oXzFMaWkxaWlJKXt2YXIgX29RUT1bJ1xceDYyXFx4NDVcXHg2YycsJ1xceDZmXFx4NjJcXHg2NlxceDc1XFx4NzNcXHg2M1xceDYxXFx4NzRcXHg2NVxceDQ1XFx4NmNcXHg0MicsMTk0NjddO3ZhciBfWnokU3MyJFo9X29RUVsyXSxfMUlMaUlsbDE9X29RUVswXTtyZXR1cm4gX29RUVsxXTt9O3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKF8yelsxXSxmdW5jdGlvbihldmVudCl7dmFyIF8wbz1bXTtyZXR1cm4gX3RoaXMuaGFuZGxlSWZyYW1lTWVzc2FnZShldmVudCk7fSk7fTtBQ0lDLnByb3RvdHlwZS5oYW5kbGVJZnJhbWVNZXNzYWdlPWZ1bmN0aW9uKGV2ZW50KXt2YXIgX28wUT1bMTM5NDUsJ1xceDRjXFx4NmZcXHg2MVxceDY0XFx4MjBcXHg0MVxceDZjXFx4NzRcXHg2NVxceDcyXFx4NmVcXHg2MVxceDc0XFx4NjVcXHgyMFxceDQzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDIwXFx4NTdcXHg2OVxceDc0XFx4NjhcXHgyMFxceDQzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDIwXFx4NTRcXHg3OVxceDcwXFx4NjVcXHgzYVxceDIwJywnXFx4NjFcXHg2MVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MmRcXHg2NFxceDY5XFx4NzNcXHg2ZFxceDY5XFx4NzNcXHg3MycsJ1xceDQzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDIwXFx4NDNcXHg2ZlxceDZkXFx4NzBcXHg2Y1xceDY1XFx4NzRcXHg2NVxceDY0JywnXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg1M1xceDc1XFx4NzBcXHg3MFxceDcyXFx4NjVcXHg3M1xceDczXFx4NjVcXHg2NCcsMzczNjksMCwnXFx4NjFcXHg2MVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MmRcXHg3M1xceDY4XFx4NmZcXHg3N1xceDZlJywnXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg0NFxceDY5XFx4NzNcXHg2ZFxceDY5XFx4NzNcXHg3M1xceDY1XFx4NjQnLCdcXHg2MVxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDYzXFx4NmZcXHg2ZFxceDcwXFx4NmNcXHg2NVxceDc0XFx4NjUnLCdcXHg2MVxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDczXFx4NzVcXHg3MFxceDcwXFx4NzJcXHg2NVxceDczXFx4NzNcXHg2NVxceDY0JywnXFx4NjVcXHg3NlxceDY1XFx4NmVcXHg3NFxceDIwXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgzYVxceDIwJywnXFx4NjFcXHg2MVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MmRcXHg2Y1xceDZmXFx4NjFcXHg2NFxceDY1XFx4NjQnLCdcXHg2MVxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDcyXFx4NjVcXHg2ZFxceDZmXFx4NzZcXHg2NScsJ1xceDQzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDIwXFx4NGNcXHg2ZlxceDYxXFx4NjRcXHg2NVxceDY0JywnXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg1M1xceDY4XFx4NmZcXHg3N1xceDZlJywnXFx4NjFcXHg2MVxceDJkXFx4NmNcXHg2ZlxceDYxXFx4NjRcXHgyZFxceDYxXFx4NmNcXHg3NFxceDY1XFx4NzJcXHg2ZVxceDYxXFx4NzRcXHg2NVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1JywnXFx4NTJcXHg2NVxceDZkXFx4NmZcXHg3NlxceDY1XFx4MjBcXHg3N1xceDY4XFx4NmZcXHg2Y1xceDY1XFx4MmRcXHg3MFxceDYxXFx4NjdcXHg2NVxceDIwXFx4NjlcXHg2NlxceDcyXFx4NjFcXHg2ZFxceDY1XFx4MjBcXHg2MlxceDY1XFx4NjZcXHg2ZlxceDcyXFx4NjVcXHgyMFxceDY4XFx4NjFcXHg3M1xceDY4XFx4MjBcXHg2M1xceDY4XFx4NjFcXHg2ZVxceDY3XFx4NjVcXHgyMFxceDY2XFx4NmZcXHg3MlxceDIwXFx4NmRcXHg2ZlxceDY0XFx4NjVcXHg2Y1xceDIwXFx4NzZcXHg2OVxceDY1XFx4NzdcXHgyMFxceDY5XFx4NmVcXHgyMFxceDc1XFx4NzJcXHg2YycsLjY1NzUyNjQ3NDYzMzg3MzRdO2lmKGV2ZW50LmRhdGEpe3RoaXMubG9nZ2VyLmxvZyhfbzBRWzExXStldmVudC5kYXRhKTt2YXIganNvblBhcnNlZEV2ZW50PXZvaWQgX28wUVs2XTt0cnl7dmFyIF8wUVFRUU8wMD1fbzBRWzVdLF9PME9Rb09vUT1fbzBRWzBdLF8xaTFsSTFJST1fbzBRWzE4XTtqc29uUGFyc2VkRXZlbnQ9SlNPTi5wYXJzZShldmVudC5kYXRhKTt9Y2F0Y2goZXJyKXt0aGlzLmxvZ2dlci5sb2coZXJyLm1lc3NhZ2UpO3JldHVybjt9c3dpdGNoKGpzb25QYXJzZWRFdmVudC5ldmVudElkKXtjYXNlIF9vMFFbN106dGhpcy5sb2dnZXIubG9nKF9vMFFbMTVdKTticmVhaztjYXNlIF9vMFFbMTJdOnRoaXMubG9nZ2VyLmxvZyhfbzBRWzE0XSk7dGhpcy5yZXNpemVDdXN0b21pemVkSWZyYW1lKCk7dGhpcy5leGVjdXRlQ2hhbGxlbmdlTG9hZENhbGxiYWNrKGpzb25QYXJzZWRFdmVudC5wYXlsb2FkKTticmVhaztjYXNlIF9vMFFbMTZdOnRoaXMubG9nZ2VyLmxvZyhfbzBRWzFdK2pzb25QYXJzZWRFdmVudC5wYXlsb2FkLmNoYWxsZW5nZVR5cGUpO3RoaXMuY2xpZW50UmVxdWVzdC5jaGFsbGVuZ2VUeXBlVmFsdWU9anNvblBhcnNlZEV2ZW50LnBheWxvYWQuY2hhbGxlbmdlVHlwZTt0aGlzLnNlbmRBcm5vbGRIdHRwUmVxdWVzdCh0aGlzLmNyZWF0ZU5ld1Nlc3Npb25SZXF1ZXN0VVJMKCkpO2JyZWFrO2Nhc2UgX28wUVsxMF06dGhpcy5sb2dnZXIubG9nKF9vMFFbNF0pO3RoaXMuYWRkUmVzcG9uc2UoanNvblBhcnNlZEV2ZW50LnBheWxvYWQpO3RoaXMuc2VuZEFybm9sZEh0dHBSZXF1ZXN0KHRoaXMuY3JlYXRlVXNlckFuc3dlclJlcXVlc3RVUkwoKSk7YnJlYWs7Y2FzZSBfbzBRWzldOnRoaXMubG9nZ2VyLmxvZyhfbzBRWzNdKTt0aGlzLmFkZFJlc3BvbnNlKGpzb25QYXJzZWRFdmVudC5wYXlsb2FkKTt0aGlzLmxvZ2dlci5sb2codGhpcy5jdXJyZW50QUFtYXRpb25SZXN1bHQpO3RoaXMuc2VuZEFybm9sZEh0dHBSZXF1ZXN0KHRoaXMuY3JlYXRlVXNlckFuc3dlclJlcXVlc3RVUkwoKSk7YnJlYWs7Y2FzZSBfbzBRWzJdOnRoaXMubG9nZ2VyLmxvZyhfbzBRWzhdKTt0aGlzLmV4ZWN1dGVEaXNtaXNzQ2FsbGJhY2soKTticmVhaztjYXNlIF9vMFFbMTNdOnRoaXMubG9nZ2VyLmxvZyhfbzBRWzE3XSk7dGhpcy5yZW1vdmVXaG9sZVBhZ2VJZnJhbWUoKTticmVhazt9fX07QUNJQy5wcm90b3R5cGUucmVzaXplQ3VzdG9taXplZElmcmFtZT1mdW5jdGlvbigpe3ZhciBfeiQ9W107dmFyIF9Telp6Mnpacz1mdW5jdGlvbihfT09vT1FRT08pe3ZhciBfaWxpPVsnXFx4NmFcXHg3M1xceDZmXFx4NmVcXHg0OVxceDY0JywuNDgxODQxMTA4MDY3MDU3Nyw0MjcwMCw0ODc0MSwnXFx4NjRcXHg2ZlxceDZkXFx4NDVcXHg2Y1xceDUzXFx4NzRcXHg2MVxceDc0XFx4NjVcXHg2ZFxceDY1XFx4NmVcXHg3NCcsLjAwNjA0MjAzMjgxMzQ4NjI1MywnXFx4NjInXTt2YXIgXyRzczIyU3oyPV9pbGlbMV0sX08wb1EwMFFRPV9pbGlbMl07dmFyIF8yWiQyWlp6ej1faWxpWzRdO3ZhciBfaUxpSUlJTGk9X2lsaVs2XSxfbDFJaWxsMTE9X2lsaVszXSxfb1FRMFFvT1E9X2lsaVswXTtyZXR1cm4gX2lsaVs1XTt9O2lmKHRoaXMuZW5hYmxlQ3VzdG9taXplZElmcmFtZSl7aWYoIXRoaXMuY3VzdG9taXplZElmcmFtZVJlc2l6ZUxpc3RlbmVyKXt0aGlzLmN1c3RvbWl6ZWRJZnJhbWVSZXNpemVMaXN0ZW5lcj10aGlzLnNldHVwQ3VzdG9taXplZElmcmFtZVJlc2l6ZUxpc3RlbmVyKCk7fXZhciBfaUkxMWxpbDE9ZnVuY3Rpb24oX0wxTGxMSWwxKXt2YXIgX1MkPVsnXFx4NmVcXHg2ZlxceDY0XFx4NjVcXHg0MicsMTI5ODYsJ1xceDZmXFx4NjJcXHg2NlxceDc1XFx4NzNcXHg2M1xceDYxXFx4NzRcXHg2NScsNDc5ODRdO3ZhciBfMjIkMiQkU1o9X1MkWzJdO3ZhciBfbGlsTElMTDE9X1MkWzNdLF8yJHpTJHpzWj1fUyRbMV07cmV0dXJuIF9TJFswXTt9O3RoaXMuY3VzdG9taXplZElmcmFtZVJlc2l6ZUxpc3RlbmVyLm9ic2VydmUodGhpcy5faWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuYm9keS5maXJzdEVsZW1lbnRDaGlsZCk7fX07QUNJQy5wcm90b3R5cGUuc2V0dXBDdXN0b21pemVkSWZyYW1lUmVzaXplTGlzdGVuZXI9ZnVuY3Rpb24oKXt2YXIgX1FPUT1bXTt2YXIgaWZyYW1lPXRoaXMuX2lmcmFtZTtyZXR1cm4gbmV3IHJlc2l6ZV9vYnNlcnZlcl9wb2x5ZmlsbF8xLmRlZmF1bHQoZnVuY3Rpb24oKXt2YXIgX29PPVsnXFx4NzBcXHg3OCddO2lmcmFtZS5oZWlnaHQ9aWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuYm9keS5maXJzdEVsZW1lbnRDaGlsZC5zY3JvbGxIZWlnaHQrX29PWzBdO30pO307QUNJQy5wcm90b3R5cGUuYWRkUmVzcG9uc2U9ZnVuY3Rpb24odXNlclJlc3BvbnNlRGF0YSl7dmFyIF9Pbz1bJ1xceDYyXFx4NmZcXHg2NFxceDc5XFx4NDVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjUnLDkyNTJdO3ZhciB1c2VyUmVzcG9uc2U9bmV3IEFDSUNVc2VyUmVzcG9uc2VfMS5BQ0lDVXNlclJlc3BvbnNlKHRoaXMuY3VycmVudEFBbWF0aW9uUmVzdWx0LmFjdGlvblR5cGVWYWx1ZSxKU09OLnN0cmluZ2lmeSh1c2VyUmVzcG9uc2VEYXRhKSk7dGhpcy5jdXJyZW50VXNlclJlc3BvbnNlPXVzZXJSZXNwb25zZTt2YXIgXzAwbzBPUW9RPV9Pb1swXSxfMTFMTGxpMWk9X09vWzFdO3RoaXMuc2Vzc2lvbkNvbnRleHQuYWRkUmVzcG9uc2UodXNlclJlc3BvbnNlKTt9O0FDSUMucHJvdG90eXBlLmFkZFJlc3VsdD1mdW5jdGlvbihyZXN1bHRTdHJpbmcpe3ZhciBfUU8wPVsuMTE3OTg0Mjk4OTIxMTk5NDQsLjg1MDkzMTc1MjYzNDg1NzIsbnVsbF07aWYoIXJlc3VsdFN0cmluZyl7cmV0dXJuIF9RTzBbMl07fXZhciByZXN1bHRKc29uPUpTT04ucGFyc2UocmVzdWx0U3RyaW5nKTt2YXIgcmVzdWx0PW5ldyBBQW1hdGlvblJlc3VsdF8xLkFBbWF0aW9uUmVzdWx0KHJlc3VsdEpzb24uY2xpZW50U2lkZUNvbnRleHQscmVzdWx0SnNvbi5zZXNzaW9uVG9rZW4scmVzdWx0SnNvbi5hY3Rpb25UeXBlKTt2YXIgXyR6c3pTMlpzPV9RTzBbMF0sX0lMaUlJSWxpPV9RTzBbMV07dGhpcy5jdXJyZW50QUFtYXRpb25SZXN1bHQ9cmVzdWx0O3RoaXMuc2Vzc2lvbkNvbnRleHQuYWRkUmVzdWx0KHJlc3VsdCk7cmV0dXJuIHJlc3VsdDt9O0FDSUMucHJvdG90eXBlLmNyZWF0ZU5ld1Nlc3Npb25SZXF1ZXN0VVJMPWZ1bmN0aW9uKCl7dmFyIF9RUT1bJ1xceDQzXFx4NzJcXHg2NVxceDYxXFx4NzRcXHg2NVxceDRlXFx4NjVcXHg3N1xceDUzXFx4NjVcXHg3M1xceDczXFx4NjlcXHg2ZlxceDZlXFx4NTJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzRcXHg1NVxceDUyXFx4NGNcXHgzYVxceDIwJ107dmFyIHVybD1idWlsZF91cmxfdHNfMS5kZWZhdWx0KHRoaXMuc2VydmljZUVuZHBvaW50LHtwYXRoOnRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRSZWZlcmVuY2VJZFZhbHVlLHF1ZXJ5UGFyYW1zOntjb250ZXh0OnVuZGVmaW5lZCxvcHRpb25zOkpTT04uc3RyaW5naWZ5KHRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRPcHRpb25zKX19KTt0aGlzLmxvZ2dlci5sb2coX1FRWzBdK3VybCk7cmV0dXJuIHVybDt9O0FDSUMucHJvdG90eXBlLmNyZWF0ZVVzZXJBbnN3ZXJSZXF1ZXN0VVJMPWZ1bmN0aW9uKCl7dmFyIF9pbGw9WydcXHgyZicsJ1xceDQzXFx4NzJcXHg2NVxceDYxXFx4NzRcXHg2NVxceDU1XFx4NzNcXHg2NVxceDcyXFx4NDFcXHg2ZVxceDczXFx4NzdcXHg2NVxceDcyXFx4NTJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzRcXHg1NVxceDUyXFx4NGNcXHgzYVxceDIwJ107dmFyIHVybD1idWlsZF91cmxfdHNfMS5kZWZhdWx0KHRoaXMuc2VydmljZUVuZHBvaW50LHtwYXRoOnRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRSZWZlcmVuY2VJZFZhbHVlK19pbGxbMF0rdGhpcy5jdXJyZW50QUFtYXRpb25SZXN1bHQuc2Vzc2lvblRva2VuVmFsdWUscXVlcnlQYXJhbXM6e2NvbnRleHQ6dGhpcy5jdXJyZW50QUFtYXRpb25SZXN1bHQuY2xpZW50U2lkZUNvbnRleHRWYWx1ZSxvcHRpb25zOkpTT04uc3RyaW5naWZ5KHRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRPcHRpb25zKSxyZXNwb25zZTpKU09OLnN0cmluZ2lmeSh0aGlzLmN1cnJlbnRVc2VyUmVzcG9uc2UpfX0pO3RoaXMubG9nZ2VyLmxvZyhfaWxsWzFdK3VybCk7cmV0dXJuIHVybDt9O0FDSUMucHJvdG90eXBlLmxvYWRDaGFsbGVuZ2VWaWV3PWZ1bmN0aW9uKHZpZXcpe3ZhciBfaTFMPVsnXFx4NmNcXHg2ZlxceDYxXFx4NjQnLHRydWUsJ1xceDc1XFx4NmVcXHg2NFxceDY1XFx4NjZcXHg2OVxceDZlXFx4NjVcXHg2NCddO3ZhciBfdGhpcz10aGlzO2lmKHR5cGVvZiB0aGlzLl9pZnJhbWU9PT1faTFMWzJdJiYhdGhpcy5lbmFibGVDdXN0b21pemVkSWZyYW1lKXt0aGlzLl9pZnJhbWU9dGhpcy5jcmVhdGVJZnJhbWUoKTt0aGlzLndyaXRlVG9JZnJhbWUodmlldyk7fWVsc2V7dmFyIF9RTzAwUTBPMD1mdW5jdGlvbihfelpaMnpaJFope3ZhciBfUU9PPVs0MTQwNCwuNDg4MjkzOTU2OTgzMDQyNDUsJ1xceDZjXFx4NjlcXHg3M1xceDc0J107dmFyIF9zWlpaWlN6Wj1fUU9PWzFdO3ZhciBfenokMnMyJHM9X1FPT1syXTtyZXR1cm4gX1FPT1swXTt9O3RoaXMuX2lmcmFtZS5hZGRFdmVudExpc3RlbmVyKF9pMUxbMF0sZnVuY3Rpb24oKXt2YXIgXzFJbD1bXTt2YXIgXzFpaUxsbGxpPWZ1bmN0aW9uKF9vMG9RME9vbyxfc1MkWlN6c3ope3ZhciBfSUxMPVszNzk4NywnXFx4NmNcXHg2OVxceDczXFx4NzQnLC4yMDk4NjQwMDA2NzMzMDMyNCwnXFx4NjVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzRcXHg0NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0XFx4NDInLCdcXHg2MlxceDQxJ107dmFyIF96WnN6JFNaWj1fSUxMWzJdLF8xTDFsTExJTD1fSUxMWzNdO3ZhciBfb29vUTBPUU89X0lMTFs0XSxfeiQkelN6WiQ9X0lMTFswXTtyZXR1cm4gX0lMTFsxXTt9O190aGlzLndyaXRlVG9JZnJhbWUodmlldyk7fSx7b25jZTpfaTFMWzFdfSk7dGhpcy5yZWxvYWRJZnJhbWUoKTt9fTtBQ0lDLnByb3RvdHlwZS5yZWxvYWRJZnJhbWU9ZnVuY3Rpb24oKXt2YXIgXyQkPVtdO3RoaXMuX2lmcmFtZS5zcmM9Jyc7fTtBQ0lDLnByb3RvdHlwZS53cml0ZVRvSWZyYW1lPWZ1bmN0aW9uKHZpZXcpe3ZhciBfaWlMPVs2NzA3LC4yNDEyNjIxOTU4NDYzNzQxLCdcXHg3M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg1NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzRcXHg0MlxceDZjXFx4NmZcXHg2MiddO3ZhciBpZnJhbWVEb2N1bWVudD10aGlzLl9pZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDt2YXIgX1okU1NaWiRaPV9paUxbMl0sXzBPUU8wUVFvPV9paUxbMF0sX0xpMUlpSWlMPV9paUxbMV07aWZyYW1lRG9jdW1lbnQub3BlbigpO2lmcmFtZURvY3VtZW50LndyaXRlKHZpZXcpO2lmcmFtZURvY3VtZW50LmNsb3NlKCk7fTtBQ0lDLnByb3RvdHlwZS5yZW1vdmVXaG9sZVBhZ2VJZnJhbWU9ZnVuY3Rpb24oKXt2YXIgX2wxPVsnXFx4NTJcXHg2NVxceDZkXFx4NmZcXHg3NlxceDY5XFx4NmVcXHg2N1xceDIwXFx4NzdcXHg2OFxceDZmXFx4NmNcXHg2NVxceDJkXFx4NzBcXHg2MVxceDY3XFx4NjVcXHgyMFxceDY5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NVxceDIwXFx4NjZcXHg3MlxceDZmXFx4NmRcXHgyMFxceDcwXFx4NjFcXHg2N1xceDY1XFx4MjEnLCdcXHg3MlxceDY1XFx4NmRcXHg2ZlxceDc2XFx4NjVcXHg1N1xceDY4XFx4NmZcXHg2Y1xceDY1XFx4NTBcXHg2MVxceDY3XFx4NjVcXHg0OVxceDY2XFx4NzJcXHg2MVxceDZkXFx4NjUnLCdcXHg2MVxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDc3XFx4NjhcXHg2ZlxceDZjXFx4NjVcXHgyZFxceDcwXFx4NjFcXHg2N1xceDY1XFx4MmRcXHg2OVxceDY2XFx4NzJcXHg2MVxceDZkXFx4NjUnXTt0aGlzLmxvZ2dlci5sb2coX2wxWzFdKTt2YXIgaWZyYW1lPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKF9sMVsyXSk7aWYoaWZyYW1lKXt0aGlzLmxvZ2dlci5sb2coX2wxWzBdKTtpZnJhbWUucmVtb3ZlKCk7dGhpcy5faWZyYW1lPXVuZGVmaW5lZDt9fTtBQ0lDLnByb3RvdHlwZS5leGVjdXRlRGlzbWlzc0NhbGxiYWNrPWZ1bmN0aW9uKCl7dmFyIF8wMFE9WydcXHg2NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0XFx4NTNcXHg3NFxceDYxXFx4NzRcXHg2NVxceDZkXFx4NjVcXHg2ZVxceDc0XFx4NDVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjUnLCdcXHg2MVxceDQ1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1XFx4NDJcXHg2ZlxceDY0XFx4NzknLCdcXHg2OFxceDYxXFx4NzNcXHg2OFxceDQzXFx4NmZcXHg2Y1xceDZjXFx4NjVcXHg2M1xceDc0XFx4NmZcXHg3MiddO3ZhciBfWlp6Mlp6eiQ9XzAwUVsxXSxfSWxMSWxJaWw9XzAwUVsyXSxfTzBPUVFRT089XzAwUVswXTt0aGlzLnJlbW92ZVdob2xlUGFnZUlmcmFtZSgpO3RoaXMuY2xpZW50UmVxdWVzdC5kaXNtaXNzQ2FsbGJhY2tGdW5jdGlvbih7fSk7fTtBQ0lDLnByb3RvdHlwZS5leGVjdXRlQ2hhbGxlbmdlTG9hZENhbGxiYWNrPWZ1bmN0aW9uKGNoYWxsZW5nZUxvYWREYXRhKXt2YXIgX2lsbGw9W251bGxdO3ZhciBfME8wMFFPT1E9ZnVuY3Rpb24oX0xJTGxMTDFsLF9RT1FvT09vMCxfeiR6JHNzWiQpe3ZhciBfMlM9WzQ4ODY4LCdcXHg2NVxceDZlXFx4NjNcXHg3MlxceDc5XFx4NzBcXHg3NFxceDQ0XFx4NmZcXHg2M1xceDc1XFx4NmRcXHg2NVxceDZlXFx4NzQnLCdcXHg2M1xceDYxXFx4NzBcXHg3NFxceDYzXFx4NjhcXHg2MSddO3ZhciBfT1FPUW9vMG89XzJTWzJdO3ZhciBfTGxsbGlJaUk9XzJTWzBdO3JldHVybiBfMlNbMV07fTtpZihjaGFsbGVuZ2VMb2FkRGF0YT09X2lsbGxbMF0pe3RoaXMuY2xpZW50UmVxdWVzdC5jaGFsbGVuZ2VMb2FkQ2FsbGJhY2tGdW5jdGlvbih7aGVpZ2h0OicnLHdpZHRoOicnfSk7fWVsc2V7dGhpcy5jbGllbnRSZXF1ZXN0LmNoYWxsZW5nZUxvYWRDYWxsYmFja0Z1bmN0aW9uKHtoZWlnaHQ6Y2hhbGxlbmdlTG9hZERhdGEuZnJhbWVIZWlnaHQsd2lkdGg6Y2hhbGxlbmdlTG9hZERhdGEuZnJhbWVXaWR0aH0pO319O0FDSUMucHJvdG90eXBlLmV4ZWN1dGVBQ0lDQ2FsbGJhY2s9ZnVuY3Rpb24ocmVzcG9uc2Upe3ZhciBfTzA9WydcXHg2NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NVxceDQxXFx4NDNcXHg0OVxceDQzXFx4NDNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YlxceDIwXFx4NzJcXHg2NVxceDczXFx4NzBcXHg2ZlxceDZlXFx4NzNcXHg2NVxceDNhXFx4MjAnLC45NzYzMTIzMDE1Njk3Mzg4XTt0aGlzLmxvZ2dlci5sb2coX08wWzBdK3Jlc3BvbnNlKTt2YXIgX08wUW9vMFEwPWZ1bmN0aW9uKF9sSUlMaTExSSxfb28wT28wUVEpe3ZhciBfWjI9WydcXHg2M1xceDYxXFx4NzBcXHg3NFxceDYzXFx4NjhcXHg2MVxceDRjXFx4NjlcXHg3M1xceDc0Jyw0MDI0LCdcXHg2NVxceDZjJ107dmFyIF9PUU9RUU9RUT1fWjJbMV0sX0wxTExJTElpPV9aMlsyXTtyZXR1cm4gX1oyWzBdO307aWYocmVzcG9uc2UgaW5zdGFuY2VvZiBBQ0lDRXJyb3JfMS5BQ0lDRXJyb3Ipe3ZhciBfT1FPUU8wUVE9X08wWzFdO3RoaXMuY2xpZW50UmVxdWVzdC5jYWxsYmFja0Z1bmN0aW9uKG5ldyBBQW1hdGlvblJlc3VsdF8xLkFBbWF0aW9uUmVzdWx0KEFDSUMuU1RBVElDX0NMSUVOVF9DT05URVhULEFDSUMuU1RBVElDX1NFU1NJT05fVE9LRU4sQUNJQy5TVEFUSUNfQUNUSU9OX1RZUEUscmVzcG9uc2UpKTtyZXR1cm47fXRoaXMuY2xpZW50UmVxdWVzdC5jYWxsYmFja0Z1bmN0aW9uKHJlc3BvbnNlKTt9O0FDSUMucHJvdG90eXBlLmNyZWF0ZUlmcmFtZT1mdW5jdGlvbigpe3ZhciBfbzBRUT1bJ1xceDY5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NScsJ1xceDYxXFx4NjFcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDJkXFx4NzdcXHg2OFxceDZmXFx4NmNcXHg2NVxceDJkXFx4NzBcXHg2MVxceDY3XFx4NjVcXHgyZFxceDY5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NSddO3ZhciBpZnJtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoX28wUVFbMF0pO2lmcm0uaWQ9X28wUVFbMV07ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJtKTtyZXR1cm4gaWZybTt9O0FDSUMucHJvdG90eXBlLnNlbmRBcm5vbGRIdHRwUmVxdWVzdD1mdW5jdGlvbih1cmwsdGltZW91dCxyZXRyeVRpbWVzKXt2YXIgX2xMPVsnXFx4NDNcXHg2ZlxceDZlXFx4NzRcXHg2NVxceDZlXFx4NzRcXHgyZFxceDU0XFx4NzlcXHg3MFxceDY1JywnXFx4NjFcXHg3MFxceDcwXFx4NmNcXHg2OVxceDYzXFx4NjFcXHg3NFxceDY5XFx4NmZcXHg2ZVxceDJmXFx4NmFcXHg3M1xceDZmXFx4NmUnLCdcXHg2MVxceDZlXFx4NzRcXHg2OVxceDJkXFx4NjNcXHg3M1xceDcyXFx4NjZcXHg3NFxceDZmXFx4NmJcXHg2NVxceDZlXFx4MmRcXHg2MVxceDMyXFx4N2EnLCdcXHg2NVxceDZlXFx4NjNcXHg3MlxceDc5XFx4NzBcXHg3NCcsJ1xceDQ3XFx4NDVcXHg1NCcsJ1xceDYzXFx4NmZcXHg2ZVxceDc0XFx4NjVcXHg2ZVxceDc0JywnXFx4NmRcXHg2NVxceDc0XFx4NjFcXHg1YlxceDZlXFx4NjFcXHg2ZFxceDY1XFx4M2RcXHgyMlxceDYzXFx4NzNcXHg3MlxceDY2XFx4MmRcXHg3NFxceDZmXFx4NmJcXHg2NVxceDZlXFx4MjJcXHg1ZCcsLjgzMjQ3NDM1MzEwMjk4OTUsdHJ1ZSwnXFx4NmZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1XFx4NDRcXHg2ZlxceDZkJywwLCdcXHg1MFxceDRmXFx4NTNcXHg1NCcsJ1xceDJlXFx4NzJcXHg2NVxceDczXFx4NzBcXHg2ZlxceDZlXFx4NzNcXHg2NVxceDU0XFx4NjlcXHg2ZFxceDY1JywnXFx4NjNcXHg3M1xceDcyXFx4NjZcXHgyMFxceDc0XFx4NmZcXHg2YlxceDY1XFx4NmVcXHgzYVxceDIwJywnXFx4NzNcXHg2NVxceDZlXFx4NjRcXHg0MVxceDcyXFx4NmVcXHg2ZlxceDZjXFx4NjRcXHg0OFxceDc0XFx4NzRcXHg3MFxceDUyXFx4NjVcXHg3MVxceDc1XFx4NjVcXHg3M1xceDc0JywnXFx4NjRcXHg2ZlxceDYzXFx4NzVcXHg2ZFxceDY1XFx4NmVcXHg3NCcsJ1xceDYxXFx4NzAnXTt2YXIgX3RoaXM9dGhpcztpZih0aW1lb3V0PT09dm9pZCBfbExbMTBdKXt2YXIgX0lsTElsTDFJPWZ1bmN0aW9uKF9saWxJaUwxbCxfb1FvUW9vTzApe3ZhciBfME8wUT1bLjA0Mjg3MjIyMDcwMTQ3NTM0LDI2Mzg4LCdcXHg3NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzRcXHg0ZVxceDZmXFx4NjRcXHg2NScsMzUwODYsLjg1NDgzNzI4NzgyOTE2MDQsLjk1MzgwMzYxMTY0MDUzMl07dmFyIF9RT1EwT1FPTz1fME8wUVsxXSxfWnNTelNaWnM9XzBPMFFbM10sX3MyejJzU1oyPV8wTzBRWzRdO3ZhciBfelNTWjIyWno9XzBPMFFbMl0sX1pzeiR6enoyPV8wTzBRWzVdO3JldHVybiBfME8wUVswXTt9O3RpbWVvdXQ9QUNJQy5ERUZBVUxUX1JFUVVFU1RfVElNRU9VVDt9aWYocmV0cnlUaW1lcz09PXZvaWQgX2xMWzEwXSl7dmFyIF9pTGlMSWxpbD1mdW5jdGlvbihfT29Pb1Fvb1EsX29PT1FPb1FRLF8kU1NzczJaeil7dmFyIF9RUW89Wy41NDM4MjMyMDM3MjczNDMyLC40OTI3NDAyMTkwNjY3NDUzNywuNjQyMzM5ODE5NzkwNTM4MSwnXFx4NmVcXHg2ZlxceDY0XFx4NjUnLCdcXHg3M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0OFxceDYxXFx4NzNcXHg2OFxceDQ0XFx4NmZcXHg2M1xceDc1XFx4NmRcXHg2NVxceDZlXFx4NzQnLCdcXHg3NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzQnLC43MDgyNzkzMTg5OTAyOTgxLC44NTQ0MDI4ODM2MzI2NzA3XTt2YXIgXzAwb09vb1FPPV9RUW9bMl0sX29PMDBPb29vPV9RUW9bMF07dmFyIF8kcyQkelNzMj1fUVFvWzVdLF9TWlpaU3MyMj1fUVFvWzRdLF9RME9RUU9Pbz1fUVFvWzZdO3ZhciBfUTAwME9Rb289X1FRb1s3XSxfMWlJSUlMMUw9X1FRb1sxXSxfeloyc1p6JFM9X1FRb1szXTtyZXR1cm4gX1FRb1s1XTt9O3JldHJ5VGltZXM9QUNJQy5ERUZBVUxUX1JFVFJZX1RJTUVTO310aGlzLmxvZ2dlci5sb2coX2xMWzE0XSk7dmFyIHJlc3BvbnNlVGltZU1ldHJpY05hbWU9X2xMWzEyXTt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdCgpO2lmKHRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRSZWZlcmVuY2VJZFZhbHVlPT09X2xMWzE2XXx8dGhpcy51c2VSZXF1ZXN0TWV0aG9kUG9zdCl7dmFyIF96WlpTWjIycz1mdW5jdGlvbihfMDBPTzBRTzAsXyQkJCRTenoyLF9pMWlMSUxJbCl7dmFyIF8wT289WydcXHg2NVxceDZlXFx4NjNcXHg3MlxceDc5XFx4NzBcXHg3NFxceDRlXFx4NmZcXHg2NFxceDY1JywyNDg5MiwuNjE3ODk1ODM5NTkwMDU2OSwuNDQ1MjA3NzQyODI3NTkzOCwnXFx4NjNcXHg2ZlxceDZjXFx4NmNcXHg2NVxceDYzXFx4NzRcXHg2ZlxceDcyJywuODYxMjQzMDI5MTA2OTQ5NywnXFx4NjhcXHg2MVxceDczXFx4NjgnLDI3MDQsJ1xceDZmXFx4NjJcXHg2NlxceDc1XFx4NzNcXHg2M1xceDYxXFx4NzRcXHg2NSddO3ZhciBfc1p6WjJzUzI9XzBPb1s0XSxfaWlpTGkxMWk9XzBPb1syXSxfTzAwb29vT1E9XzBPb1s1XTt2YXIgX3NTMiQyJHpzPV8wT29bNl0sX29vb09vT08wPV8wT29bOF0sXzExaUxpbElJPV8wT29bN107dmFyIF9PUTBPT29RMD1fME9vWzFdLF9JaUlMaUlsMT1fME9vWzBdO3JldHVybiBfME9vWzNdO307eGhyLm9wZW4oX2xMWzExXSx1cmwsX2xMWzhdKTtyZXNwb25zZVRpbWVNZXRyaWNOYW1lPV9sTFsxMV0rcmVzcG9uc2VUaW1lTWV0cmljTmFtZTt9ZWxzZXt2YXIgX29RUTBPMDBRPV9sTFs5XTt4aHIub3BlbihfbExbNF0sdXJsLF9sTFs4XSk7cmVzcG9uc2VUaW1lTWV0cmljTmFtZT1fbExbNF0rcmVzcG9uc2VUaW1lTWV0cmljTmFtZTt9eGhyLnNldFJlcXVlc3RIZWFkZXIoX2xMWzBdLF9sTFsxXSk7aWYodGhpcy5faWZyYW1lKXt2YXIgXyQkMlMyJFNaPV9sTFs3XSxfTGkxTGxpTEw9X2xMWzNdLF9vbzAwUU9vbz1fbExbMTVdO3ZhciBjc3JmVG9rZW5UYWc9dGhpcy5faWZyYW1lLmNvbnRlbnREb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoX2xMWzZdKTtpZihjc3JmVG9rZW5UYWcpe3RoaXMuY3NyZlRva2VuPWNzcmZUb2tlblRhZy5nZXRBdHRyaWJ1dGUoX2xMWzVdKTt0aGlzLmxvZ2dlci5sb2coX2xMWzEzXSt0aGlzLmNzcmZUb2tlbik7dmFyIF9sbExsaUlsTD1mdW5jdGlvbihfb29vUTBRUVEsX29PMFFvb1FvLF8wUVEwb28wTyl7dmFyIF9Tej1bLjY3MDkxNTYwNjUxODQ3MTIsJ1xceDYzXFx4NjFcXHg3MFxceDc0XFx4NjNcXHg2OFxceDYxXFx4NDRcXHg2ZlxceDYzXFx4NzVcXHg2ZFxceDY1XFx4NmVcXHg3NCcsLjA4NTYxMzk2MDU1OTc2OTIyLC44NTc1OTM3NzAwMDU0MzU1LDE0MjU0LCdcXHg2NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NVxceDQ0XFx4NjFcXHg3NFxceDYxJyw4NDMwXTt2YXIgXzFpMUlMTElJPV9Tels0XSxfaWwxbDFsTEw9X1N6WzBdO3ZhciBfTDFJTGlsTEk9X1N6WzVdLF9MSWxJMTFJbD1fU3pbMl07dmFyIF96UyRaWnN6ej1fU3pbNl0sX29vUVFPT29RPV9TelsxXTtyZXR1cm4gX1N6WzNdO307eGhyLnNldFJlcXVlc3RIZWFkZXIoX2xMWzJdLHRoaXMuY3NyZlRva2VuKTt9fXhoci50aW1lb3V0PXRpbWVvdXQ7dmFyIHJlcXVlc3RTdGFydFRpbWU9bmV3IERhdGUoKS52YWx1ZU9mKCk7eGhyLnNlbmQoSlNPTi5zdHJpbmdpZnkoe2NvbnRleHQ6dGhpcy5nZXRjbGllbnRTaWRlQ29udGV4dCgpLG9wdGlvbnM6SlNPTi5zdHJpbmdpZnkodGhpcy5jbGllbnRSZXF1ZXN0LmNsaWVudE9wdGlvbnMpLHJlc3BvbnNlOkpTT04uc3RyaW5naWZ5KHRoaXMuY3VycmVudFVzZXJSZXNwb25zZSksZndjaW1CbG9iOnRoaXMuY2xpZW50UmVxdWVzdC5md2NpbUJsb2JWYWx1ZX0pKTt4aHIub25lcnJvcj1mdW5jdGlvbigpe3ZhciBfczJTPVsnXFx4NGVcXHg2NVxceDc0XFx4NzdcXHg2ZlxceDcyXFx4NmJcXHgyMFxceDQ1XFx4NzJcXHg3MlxceDZmXFx4NzJcXHgzYVxceDIwJywnXFx4MjBcXHg3MlxceDY1XFx4NzRcXHg3MlxceDY5XFx4NjVcXHg3M1xceDIwXFx4NzJcXHg2NVxceDZkXFx4NjFcXHg2OVxceDZlXFx4NjlcXHg2ZVxceDY3XFx4MmUnLDQwNTA0LDEsJ1xceDQ2XFx4NjFcXHg2OVxceDZjXFx4NjVcXHg2NFxceDIwXFx4NzRcXHg2ZlxceDIwXFx4NjNcXHg2ZlxceDZlXFx4NmVcXHg2NVxceDYzXFx4NzRcXHgyMFxceDc0XFx4NmZcXHgyMFxceDc0XFx4NjhcXHg2NVxceDIwXFx4NzNcXHg2NVxceDcyXFx4NzZcXHg2NVxceDcyXFx4MmUnLDBdO2lmKHJldHJ5VGltZXM9PV9zMlNbNV0pe190aGlzLnNlbmRFcnJvclRvS2F0YWxMb2dnZXIoX3MyU1s0XSx7J1xceDU1XFx4NTJcXHg0Yyc6dXJsLCdcXHg0M1xceDQ5XFx4NDQnOl90aGlzLmNsaWVudFJlcXVlc3QuY2xpZW50UmVmZXJlbmNlSWRWYWx1ZX0pO3ZhciBhY2ljRXJyb3I9bmV3IEFDSUNFcnJvcl8xLkFDSUNFcnJvcihBQ0lDRXJyb3JfMS5BQ0lDRXJyb3JOYW1lLk5FVFdPUktfRVJST1IpO3ZhciBfUW8wME9vbzA9ZnVuY3Rpb24oX2kxTEwxaWxpLF9zc3NaMjJTMil7dmFyIF9RUVE9Wy42MTczODQ4OTY4ODA3NzY1LDIzMTUxLDI1ODA3XTt2YXIgX1FRMFFPb09PPV9RUVFbMl0sXzBPMG8wb1FPPV9RUVFbMF07cmV0dXJuIF9RUVFbMV07fTtpZihfdGhpcy5fb25lcnJvcil7X3RoaXMuX29uZXJyb3IoYWNpY0Vycm9yKTt9ZWxzZXtfdGhpcy5leGVjdXRlQUNJQ0NhbGxiYWNrKGFjaWNFcnJvcik7fX1lbHNle190aGlzLnNlbmRFcnJvclRvS2F0YWxMb2dnZXIoX3MyU1swXStyZXRyeVRpbWVzK19zMlNbMV0seydcXHg1NVxceDUyXFx4NGMnOnVybCwnXFx4NDNcXHg0OVxceDQ0JzpfdGhpcy5jbGllbnRSZXF1ZXN0LmNsaWVudFJlZmVyZW5jZUlkVmFsdWV9KTt2YXIgX29vUTBPUVFvPV9zMlNbMl07X3RoaXMuc2VuZEFybm9sZEh0dHBSZXF1ZXN0KHVybCx1bmRlZmluZWQscmV0cnlUaW1lcy1fczJTWzNdKTt9fTt4aHIub250aW1lb3V0PWZ1bmN0aW9uKCl7dmFyIF9vUU89WydcXHg1NFxceDY5XFx4NmRcXHg2NVxceDZmXFx4NzVcXHg3NFxceDNhXFx4MjBcXHg3MlxceDY1XFx4NzFcXHg3NVxceDY1XFx4NzNcXHg3NFxceDIwXFx4NzRcXHg2ZlxceDZmXFx4NmJcXHgyMFxceDZjXFx4NmZcXHg2ZVxceDY3XFx4NjVcXHg3MlxceDIwXFx4NzRcXHg2OFxceDYxXFx4NmVcXHgyMFxceDY1XFx4NzhcXHg3MFxceDY1XFx4NjNcXHg3NFxceDY1XFx4NjRcXHgyZSddO190aGlzLnNlbmRFcnJvclRvS2F0YWxMb2dnZXIoX29RT1swXSx7J1xceDU1XFx4NTJcXHg0Yyc6dXJsLCdcXHg0M1xceDQ5XFx4NDQnOl90aGlzLmNsaWVudFJlcXVlc3QuY2xpZW50UmVmZXJlbmNlSWRWYWx1ZX0pO3ZhciBhY2ljRXJyb3I9bmV3IEFDSUNFcnJvcl8xLkFDSUNFcnJvcihBQ0lDRXJyb3JfMS5BQ0lDRXJyb3JOYW1lLlRJTUVPVVQpO2lmKF90aGlzLl9vbmVycm9yKXtfdGhpcy5fb25lcnJvcihhY2ljRXJyb3IpO31lbHNle190aGlzLmV4ZWN1dGVBQ0lDQ2FsbGJhY2soYWNpY0Vycm9yKTt9fTt4aHIub25sb2FkPWZ1bmN0aW9uKCl7dmFyIF8wb1E9WydcXHg3NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzRcXHg0YVxceDczXFx4NmZcXHg2ZScsJ1xceDczXFx4NjVcXHg2ZVxceDY0XFx4NDFcXHg3MlxceDZlXFx4NmZcXHg2Y1xceDY0XFx4NDhcXHg3NFxceDc0XFx4NzBcXHg1MlxceDY1XFx4NzFcXHg3NVxceDY1XFx4NzNcXHg3NCddO3ZhciBfWiRTMnpTWjI9XzBvUVswXTt2YXIgcmVxdWVzdEVuZFRpbWU9bmV3IERhdGUoKS52YWx1ZU9mKCk7X3RoaXMuYWNpY0thdGFsTWV0cmljc1B1Ymxpc2hlci5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChfMG9RWzFdKS5wdWJsaXNoVGltZXJNb25pdG9yKHJlc3BvbnNlVGltZU1ldHJpY05hbWUscmVxdWVzdEVuZFRpbWUtcmVxdWVzdFN0YXJ0VGltZSk7X3RoaXMucHJvY2Vzc0Fybm9sZEh0dHBSZXNwb25zZSh4aHIpO307fTtBQ0lDLnByb3RvdHlwZS5nZXRjbGllbnRTaWRlQ29udGV4dD1mdW5jdGlvbigpe3ZhciBfSUxJPVsuNjE3NzYzMjEzNDYwNTc4MixudWxsLCdcXHg2MVxceDRlXFx4NmZcXHg2NFxceDY1XFx4NDRcXHg2ZlxceDZkJywuNzk1OTE5MTk0NTA5NTMxMl07dmFyIF9MaUxpSUwxbD1fSUxJWzNdO2lmKHRoaXMuY3VycmVudEFBbWF0aW9uUmVzdWx0KXt2YXIgXzIyU1pTWjJaPV9JTElbMl0sX2lsaTFpSWwxPV9JTElbMF07cmV0dXJuIHRoaXMuY3VycmVudEFBbWF0aW9uUmVzdWx0LmNsaWVudFNpZGVDb250ZXh0VmFsdWU7fXJldHVybiBfSUxJWzFdO307QUNJQy5wcm90b3R5cGUucHJvY2Vzc0Fybm9sZEh0dHBSZXNwb25zZT1mdW5jdGlvbih4aHIpe3ZhciBfMDAwPVsuNDM5NDY3OTE4NzkyMDc5MzYsMjAwLC44ODkyMjc3NjgyNDgzODgyLCdcXHg0OFxceDU0XFx4NTRcXHg1MFxceDIwXFx4NDVcXHg3MlxceDcyXFx4NmZcXHg3MlxceDIwJywuMzkzMzIzNjMwMDIyNzczMTUsJ1xceDYzXFx4NjFcXHg3MFxceDc0XFx4NjNcXHg2OFxceDYxJywuODUwNzg3NTc4MDEwOTg4OCwuNzcxNzU2NDAwMDExMTM0MSwzOTUxNywnXFx4NzBcXHg3MlxceDZmXFx4NjNcXHg2NVxceDczXFx4NzNcXHg0MVxceDcyXFx4NmVcXHg2ZlxceDZjXFx4NjRcXHg0OFxceDc0XFx4NzRcXHg3MFxceDUyXFx4NjVcXHg3M1xceDcwXFx4NmZcXHg2ZVxceDczXFx4NjUnLDExMDgwLDQwMCwnXFx4NTJcXHg2NVxceDczXFx4NzBcXHg2ZlxceDZlXFx4NzNcXHg2NVxceDQ4XFx4NjVcXHg2MVxceDY0XFx4NjVcXHg3MlxceDIwXFx4NjlcXHg3M1xceDIwXFx4NmVcXHg3NVxceDZjXFx4NmNcXHgyZScsJ1xceDJlJyw0ODYxNCwnXFx4NjRcXHg2ZlxceDZkXFx4NGNcXHg2OVxceDczXFx4NzQnXTt0aGlzLmxvZ2dlci5sb2coXzAwMFs5XSk7dmFyIHN0YXR1cz14aHIuc3RhdHVzO3ZhciBfU3NTMnMyeno9XzAwMFsxNV0sXyRTc1MycyRaPV8wMDBbNV07dGhpcy5sb2dnZXIubG9nKHN0YXR1cyk7aWYoc3RhdHVzIT1fMDAwWzFdKXt0aGlzLnNlbmRFcnJvclRvS2F0YWxMb2dnZXIoXzAwMFszXStzdGF0dXMrXzAwMFsxM10seydcXHg1M1xceDc0XFx4NjFcXHg3NFxceDc1XFx4NzMnOnhoci5zdGF0dXNUZXh0LCdcXHg0M1xceDQ5XFx4NDQnOnRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRSZWZlcmVuY2VJZFZhbHVlLCdcXHg1MlxceDY1XFx4NzNcXHg3MFxceDZmXFx4NmVcXHg3M1xceDY1XFx4NTVcXHg1MlxceDRjJzp4aHIucmVzcG9uc2VVUkx9KTt2YXIgX2xJaUlJbGlMPWZ1bmN0aW9uKF9vT29vT1EwTyxfb08wMDBPT1Epe3ZhciBfT089Wy42MDEyNDU2NDM0NDA5OTUsLjgxNDQ4MzM5Mzc0MTk0NDIsJ1xceDY4XFx4NjFcXHg3M1xceDY4XFx4NDVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzQnLCdcXHg2MlxceDUzXFx4NzRcXHg2MVxceDc0XFx4NjVcXHg2ZFxceDY1XFx4NmVcXHg3NCcsJ1xceDY5XFx4NjQnLC43NTQ2Mjg1OTUzNTE1Nzc3LC4xNzAwODcwMDM0NzE4MTczOCwzNDA4NV07dmFyIF9TUyQyJFNzJD1fT09bNF0sX09RbzBRMDBvPV9PT1s2XTt2YXIgXyQkJHokJDIyPV9PT1szXSxfJFN6MlpzcyQ9X09PWzVdLF9pbEwxMUlMbD1fT09bMl07dmFyIF9TcyRzelNzej1fT09bN10sX0lJbEwxMUxsPV9PT1swXTtyZXR1cm4gX09PWzFdO307aWYoc3RhdHVzPT1fMDAwWzExXSl7dmFyIF9paTFsSWlJTD1mdW5jdGlvbihfSUxsaUkxTDEsXyR6MnpaWnNaKXt2YXIgX28wTz1bLjA4MjY3MzY4MTgyMzU0NTQsMTE3MjUsLjExOTQzNzYzODYyOTIzNDYyLCdcXHg2ZVxceDZmXFx4NjRcXHg2NVxceDQyXFx4NmZcXHg2NFxceDc5XFx4NDhcXHg2MVxceDczXFx4NjgnLCdcXHg2ZVxceDZmXFx4NjRcXHg2NVxceDQ1XFx4NmVcXHg2M1xceDcyXFx4NzlcXHg3MFxceDc0Jyw0NTc0XTt2YXIgX1NTUyRac3oyPV9vME9bM10sX1NTWjJzczIkPV9vME9bMl0sX3okJFokWnoyPV9vME9bNV07dmFyIF9TMjJTU1NzMj1fbzBPWzRdLF8yejIyUyRzWj1fbzBPWzFdO3JldHVybiBfbzBPWzBdO307dGhpcy5leGVjdXRlQUNJQ0NhbGxiYWNrKG5ldyBBQ0lDRXJyb3JfMS5BQ0lDRXJyb3IoQUNJQ0Vycm9yXzEuQUNJQ0Vycm9yTmFtZS5CQURfUkVRVUVTVF9FUlJPUikpO31lbHNle3ZhciBfUVFvMG9vUU89XzAwMFswXSxfbExJSWlMTGk9XzAwMFs3XSxfb29PUW9PbzA9XzAwMFs2XTt0aGlzLmV4ZWN1dGVBQ0lDQ2FsbGJhY2sobmV3IEFDSUNFcnJvcl8xLkFDSUNFcnJvcihBQ0lDRXJyb3JfMS5BQ0lDRXJyb3JOYW1lLkhUVFBfRVJST1IpKTt9fWVsc2V7dmFyIF9sbEwxbGxpbD1fMDAwWzRdO3ZhciBhYW1hdGlvblJlc3VsdD10aGlzLmFkZFJlc3VsdCh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoQUNJQy5BQU1BVElPTl9TRVJWSUNFX1JFU1BPTlNFX0hFQURFUikpO3RoaXMubG9nZ2VyLmxvZyhhYW1hdGlvblJlc3VsdCk7aWYoIWFhbWF0aW9uUmVzdWx0KXt0aGlzLnNlbmRFcnJvclRvS2F0YWxMb2dnZXIoXzAwMFsxMl0seydcXHg0M1xceDQ5XFx4NDQnOnRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRSZWZlcmVuY2VJZFZhbHVlLCdcXHg1MlxceDY1XFx4NzNcXHg3MFxceDZmXFx4NmVcXHg3M1xceDY1XFx4NTVcXHg1MlxceDRjJzp4aHIucmVzcG9uc2VVUkwsJ1xceDUyXFx4NjVcXHg3M1xceDcwXFx4NmZcXHg2ZVxceDczXFx4NjVcXHg1NFxceDY1XFx4NzhcXHg3NCc6ISF4aHIucmVzcG9uc2VUZXh0LCdcXHg1MlxceDY1XFx4NzNcXHg3MFxceDZmXFx4NmVcXHg3M1xceDY1XFx4NDhcXHg2NVxceDYxXFx4NjRcXHg2NVxceDcyJzp4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoQUNJQy5BQU1BVElPTl9TRVJWSUNFX1JFU1BPTlNFX0hFQURFUil9KTt0aGlzLmV4ZWN1dGVBQ0lDQ2FsbGJhY2sobmV3IEFDSUNFcnJvcl8xLkFDSUNFcnJvcihBQ0lDRXJyb3JfMS5BQ0lDRXJyb3JOYW1lLkVNUFRZX1JFU1BPTlNFKSk7fWVsc2UgaWYoYWFtYXRpb25SZXN1bHQuYWN0aW9uVHlwZVZhbHVlPT1BQ0lDLkFBTUFUSU9OX1BBU1NfQUNUSU9OX1RZUEUpe3RoaXMuZXhlY3V0ZUFDSUNDYWxsYmFjayhhYW1hdGlvblJlc3VsdCk7fWVsc2UgaWYodGhpcy5tb2RlJiZBQ0lDLkRFVEVDVElPTl9PTkxZX01PREVMPT09dGhpcy5tb2RlKXt2YXIgXzFMbGlMSWwxPV8wMDBbMTBdLF9ac1okUzJaej1fMDAwWzE0XTt0aGlzLmV4ZWN1dGVBQ0lDQ2FsbGJhY2soYWFtYXRpb25SZXN1bHQpO31lbHNle3ZhciB2aWV3PXhoci5yZXNwb25zZVRleHQ7dmFyIF9JaWkxaWkxaT1fMDAwWzhdLF9vb1FvT1FvUT1fMDAwWzJdO3RoaXMubG9hZENoYWxsZW5nZVZpZXcodmlldyk7fX19O0FDSUMuREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQ9XzBRWzEzXTtBQ0lDLkRFRkFVTFRfUkVUUllfVElNRVM9XzBRWzE0XTtBQ0lDLkFBTUFUSU9OX1NFUlZJQ0VfUkVTUE9OU0VfSEVBREVSPV8wUVs0XTtBQ0lDLkFBTUFUSU9OX1BBU1NfQUNUSU9OX1RZUEU9XzBRWzNdO0FDSUMuU0VSVklDRV9CQVNFX1BBVEg9XzBRWzddO0FDSUMuU1RBVElDX0NMSUVOVF9DT05URVhUPV8wUVs2XTtBQ0lDLlNUQVRJQ19TRVNTSU9OX1RPS0VOPV8wUVs1XTtBQ0lDLlNUQVRJQ19BQ1RJT05fVFlQRT1fMFFbM107dmFyIF9MTGxpaWlJST1fMFFbMl0sX1Nzc3NaMlNTPV8wUVs4XTtBQ0lDLkRFVEVDVElPTl9PTkxZX01PREVMPV8wUVsxMF07QUNJQy5LQVRBTF9NRVRSSUNTX1NFUlZJQ0VfTkFNRT1fMFFbMV07cmV0dXJuIEFDSUM7fSgpO2V4cG9ydHMuQUNJQz1BQ0lDOyIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pZnJhbWUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCInXFx4NzVcXHg3M1xceDY1XFx4MjBcXHg3M1xceDc0XFx4NzJcXHg2OVxceDYzXFx4NzQnO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdcXHg1ZlxceDVmXFx4NjVcXHg3M1xceDRkXFx4NmZcXHg2NFxceDc1XFx4NmNcXHg2NScse3ZhbHVlOnRydWV9KTt2YXIgQUFtYXRpb25SZXN1bHQ9ZnVuY3Rpb24oKXt2YXIgX0xJTD1bJ1xceDYxXFx4NjNcXHg2OVxceDYzXFx4NDVcXHg3MlxceDcyXFx4NmZcXHg3MlxceDU2XFx4NjFcXHg2Y1xceDc1XFx4NjUnLCdcXHg2MVxceDYzXFx4NzRcXHg2OVxceDZmXFx4NmVcXHg1NFxceDc5XFx4NzBcXHg2NVxceDU2XFx4NjFcXHg2Y1xceDc1XFx4NjUnLCdcXHg3M1xceDY1XFx4NzNcXHg3M1xceDY5XFx4NmZcXHg2ZVxceDU0XFx4NmZcXHg2YlxceDY1XFx4NmVcXHg1NlxceDYxXFx4NmNcXHg3NVxceDY1JywnXFx4NjNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4NTNcXHg2OVxceDY0XFx4NjVcXHg0M1xceDZmXFx4NmVcXHg3NFxceDY1XFx4NzhcXHg3NFxceDU2XFx4NjFcXHg2Y1xceDc1XFx4NjUnLG51bGwsdHJ1ZV07ZnVuY3Rpb24gQUFtYXRpb25SZXN1bHQoY2xpZW50U2lkZUNvbnRleHQsc2Vzc2lvblRva2VuLGFjdGlvblR5cGUsYWNpY0Vycm9yKXt0aGlzLmNsaWVudFNpZGVDb250ZXh0PWNsaWVudFNpZGVDb250ZXh0O3ZhciBfb1FPT29PMG89ZnVuY3Rpb24oXzJaJFp6czIkLF9saUlMSUkxSSl7dmFyIF9RT289WzQ4OTQ0LC4yODM0NzY4ODU1MzYxMjUxNiwnXFx4NjVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzRcXHg0NFxceDYxXFx4NzRcXHg2MVxceDUzXFx4NzRcXHg2MVxceDc0XFx4NjVcXHg2ZFxceDY1XFx4NmVcXHg3NCddO3ZhciBfSUlJTExMTDE9X1FPb1syXSxfeiRTc1pzc1o9X1FPb1swXTtyZXR1cm4gX1FPb1sxXTt9O3RoaXMuc2Vzc2lvblRva2VuPXNlc3Npb25Ub2tlbjt0aGlzLmFjdGlvblR5cGU9YWN0aW9uVHlwZTt0aGlzLmFjaWNFcnJvcj1hY2ljRXJyb3J8fF9MSUxbNF07fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShBQW1hdGlvblJlc3VsdC5wcm90b3R5cGUsX0xJTFszXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9RUU89W107cmV0dXJuIHRoaXMuY2xpZW50U2lkZUNvbnRleHQ7fSxlbnVtZXJhYmxlOl9MSUxbNV0sY29uZmlndXJhYmxlOl9MSUxbNV19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUFtYXRpb25SZXN1bHQucHJvdG90eXBlLF9MSUxbMl0se2dldDpmdW5jdGlvbigpe3ZhciBfUU9vbz1bLjE2MDgzMDczODM4MTkxMTY0LC44OTEwOTc3NzI1Mzc4MTMzLC45ODQwMjIzNjcxNTI4MTNdO3ZhciBfeiRzc3pTc1M9X1FPb29bMl0sX3pTJCR6elpTPV9RT29vWzBdLF9aU1N6UyR6Uz1fUU9vb1sxXTtyZXR1cm4gdGhpcy5zZXNzaW9uVG9rZW47fSxlbnVtZXJhYmxlOl9MSUxbNV0sY29uZmlndXJhYmxlOl9MSUxbNV19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUFtYXRpb25SZXN1bHQucHJvdG90eXBlLF9MSUxbMV0se2dldDpmdW5jdGlvbigpe3ZhciBfT09RPVtdO3JldHVybiB0aGlzLmFjdGlvblR5cGU7fSxlbnVtZXJhYmxlOl9MSUxbNV0sY29uZmlndXJhYmxlOl9MSUxbNV19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUFtYXRpb25SZXN1bHQucHJvdG90eXBlLF9MSUxbMF0se2dldDpmdW5jdGlvbigpe3ZhciBfb1FPMD1bNDk5MjZdO3ZhciBfSTFMbElMSWk9X29RTzBbMF07cmV0dXJuIHRoaXMuYWNpY0Vycm9yO30sZW51bWVyYWJsZTpfTElMWzVdLGNvbmZpZ3VyYWJsZTpfTElMWzVdfSk7cmV0dXJuIEFBbWF0aW9uUmVzdWx0O30oKTtleHBvcnRzLkFBbWF0aW9uUmVzdWx0PUFBbWF0aW9uUmVzdWx0OyIsIidcXHg3NVxceDczXFx4NjVcXHgyMFxceDczXFx4NzRcXHg3MlxceDY5XFx4NjNcXHg3NCc7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJ1xceDVmXFx4NWZcXHg2NVxceDczXFx4NGRcXHg2ZlxceDY0XFx4NzVcXHg2Y1xceDY1Jyx7dmFsdWU6dHJ1ZX0pO3ZhciBBQ0lDQ2xpZW50UmVxdWVzdD1mdW5jdGlvbigpe3ZhciBfT29PPVsnXFx4NjNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4NTJcXHg2NVxceDY2XFx4NjVcXHg3MlxceDY1XFx4NmVcXHg2M1xceDY1XFx4NDlcXHg2NFxceDU2XFx4NjFcXHg2Y1xceDc1XFx4NjUnLCdcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHg1NFxceDc5XFx4NzBcXHg2NVxceDU2XFx4NjFcXHg2Y1xceDc1XFx4NjUnLG51bGwsJ1xceDYzXFx4NjFcXHg2Y1xceDZjXFx4NjJcXHg2MVxceDYzXFx4NmJcXHg0NlxceDc1XFx4NmVcXHg2M1xceDc0XFx4NjlcXHg2ZlxceDZlJywnXFx4NjRcXHg2OVxceDczXFx4NmRcXHg2OVxceDczXFx4NzNcXHg0M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiXFx4NDZcXHg3NVxceDZlXFx4NjNcXHg3NFxceDY5XFx4NmZcXHg2ZScsJ1xceDYzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDRmXFx4NzBcXHg3NFxceDY5XFx4NmZcXHg2ZVxceDczJyxmYWxzZSwnXFx4NjZcXHg3N1xceDYzXFx4NjlcXHg2ZFxceDQyXFx4NmNcXHg2ZlxceDYyXFx4NTZcXHg2MVxceDZjXFx4NzVcXHg2NScsJ1xceDc1XFx4NzNcXHg2NVxceDcyXFx4NGNcXHg2MVxceDZlXFx4NjdcXHg3NVxceDYxXFx4NjdcXHg2NScsJ1xceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDRjXFx4NmZcXHg2MVxceDY0XFx4NDNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YlxceDQ2XFx4NzVcXHg2ZVxceDYzXFx4NzRcXHg2OVxceDZmXFx4NmUnLHRydWVdO2Z1bmN0aW9uIEFDSUNDbGllbnRSZXF1ZXN0KGNsaWVudFJlZmVyZW5jZUlkLGNhbGxiYWNrLGRpc21pc3NDYWxsYmFjayxjaGFsbGVuZ2VMb2FkQ2FsbGJhY2ssY2xpZW50RGF0YSxsb2NhbGUsZndjaW1CbG9iLGV4dGVybmFsSWQsZW5hYmxlSGVhZGVyRm9vdGVyLGVuYWJsZUJ5cGFzc01lY2hhbmlzbSxlbmFibGVNb2RhbFZpZXcsY2hhbGxlbmdlVHlwZSxtb2RlLGV2ZW50VHJpZ2dlcixhYUV4dGVybmFsVG9rZW4sZm9yY2VKc0ZsdXNoLGFhbWF0aW9uVG9rZW4pe3RoaXMuY2xpZW50UmVmZXJlbmNlSWQ9Y2xpZW50UmVmZXJlbmNlSWQ7dGhpcy5jYWxsYmFjaz1jYWxsYmFjazt0aGlzLmRpc21pc3NDYWxsYmFjaz1kaXNtaXNzQ2FsbGJhY2t8fHRoaXMuZGVmYXVsdERpc21pc3NDYWxsYmFjazt0aGlzLmNoYWxsZW5nZUxvYWRDYWxsYmFjaz1jaGFsbGVuZ2VMb2FkQ2FsbGJhY2t8fHRoaXMuZGVmYXVsdENoYWxsZW5nZUxvYWRDYWxsYmFjazt0aGlzLmNsaWVudERhdGE9Y2xpZW50RGF0YXx8X09vT1syXTt0aGlzLmV4dGVybmFsSWQ9ZXh0ZXJuYWxJZHx8X09vT1syXTt0aGlzLmxvY2FsZT1sb2NhbGV8fG5hdmlnYXRvci5sYW5ndWFnZXx8d2luZG93Lm5hdmlnYXRvcltfT29PWzhdXTt0aGlzLmZ3Y2ltQmxvYj1md2NpbUJsb2J8fF9Pb09bMl07dGhpcy5lbmFibGVIZWFkZXJGb290ZXI9ZW5hYmxlSGVhZGVyRm9vdGVyPT1fT29PWzZdP2VuYWJsZUhlYWRlckZvb3RlcjpfT29PWzEwXTt0aGlzLmVuYWJsZUJ5cGFzc01lY2hhbmlzbT1lbmFibGVCeXBhc3NNZWNoYW5pc209PV9Pb09bMTBdP2VuYWJsZUJ5cGFzc01lY2hhbmlzbTpfT29PWzZdO3RoaXMuZW5hYmxlTW9kYWxWaWV3PWVuYWJsZU1vZGFsVmlldz09X09vT1sxMF0/ZW5hYmxlTW9kYWxWaWV3Ol9Pb09bNl07dGhpcy5jaGFsbGVuZ2VUeXBlPWNoYWxsZW5nZVR5cGV8fF9Pb09bMl07dGhpcy5tb2RlPW1vZGV8fF9Pb09bMl07dGhpcy5ldmVudFRyaWdnZXI9ZXZlbnRUcmlnZ2VyfHxfT29PWzJdO3RoaXMuYWFFeHRlcm5hbFRva2VuPWFhRXh0ZXJuYWxUb2tlbnx8X09vT1syXTt0aGlzLmZvcmNlSnNGbHVzaD1fT29PWzEwXTt0aGlzLmFhbWF0aW9uVG9rZW49YWFtYXRpb25Ub2tlbnx8X09vT1syXTt9QUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLmRlZmF1bHREaXNtaXNzQ2FsbGJhY2s9ZnVuY3Rpb24oKXt2YXIgX1N6Wj1bJ1xceDQ0XFx4NjlcXHg3M1xceDZkXFx4NjlcXHg3M1xceDczXFx4MjBcXHg2M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiXFx4MjBcXHg2ZVxceDZmXFx4NzRcXHgyMFxceDczXFx4NzBcXHg2NVxceDYzXFx4NjlcXHg2NlxceDY5XFx4NjVcXHg2NCcsbnVsbF07Y29uc29sZS5sb2coX1N6WlswXSk7cmV0dXJuIF9TelpbMV07fTtBQ0lDQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZGVmYXVsdENoYWxsZW5nZUxvYWRDYWxsYmFjaz1mdW5jdGlvbigpe3ZhciBfUW89WydcXHg0M1xceDZjXFx4NjlcXHg2NVxceDZlXFx4NzRcXHgyMFxceDYzXFx4NjFcXHg2Y1xceDZjXFx4NjJcXHg2MVxceDYzXFx4NmJcXHgyMFxceDZlXFx4NmZcXHg3NFxceDIwXFx4NzNcXHg3MFxceDY1XFx4NjNcXHg2OVxceDY2XFx4NjlcXHg2NVxceDY0XFx4MjBcXHg2NlxceDZmXFx4NzJcXHgyMFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDIwXFx4NzBcXHg2MVxceDY3XFx4NjUnLG51bGxdO2NvbnNvbGUubG9nKF9Rb1swXSk7dmFyIF8wME8wTzBRMD1mdW5jdGlvbihfaTFsbGwxSTEsX3N6MjJac3N6KXt2YXIgX1paPVsnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHg0NlxceDc3XFx4NjNcXHg2OVxceDZkJywnXFx4NjRcXHg2ZlxceDZkJywnXFx4NmVcXHg2ZlxceDY0XFx4NjVcXHg0ZVxceDZmXFx4NjRcXHg2NScsLjIxOTQ2MDg3OTA0NjIwNjcsNDI1MzYsMjc2NzYsMjY2MTAsMTEyMTQsJ1xceDYyJywnXFx4NjhcXHg2MVxceDczXFx4NjhcXHg0MlxceDZmXFx4NjRcXHg3OVxceDQ1XFx4NmVcXHg2M1xceDcyXFx4NzlcXHg3MFxceDc0J107dmFyIF9PT29vb1FPUT1fWlpbN10sX3oyUyQkejJTPV9aWls1XSxfTGlMaUxsaTE9X1paWzZdO3ZhciBfUTAwUU8wTzA9X1paWzFdLF9PTzBvMG9RTz1fWlpbOF0sX2xMaUlJMUxMPV9aWlsyXTt2YXIgXzFpMUlsSUxMPV9aWls0XSxfTzBRb1FvMG89X1paWzNdLF8xaTFMTGlpMT1fWlpbOV07cmV0dXJuIF9aWlswXTt9O3JldHVybiBfUW9bMV07fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLF9Pb09bMF0se2dldDpmdW5jdGlvbigpe3ZhciBfMTFpPVsnXFx4NmNcXHg2OVxceDczXFx4NzQnLCdcXHg2OFxceDYxXFx4NzNcXHg2OFxceDUzXFx4NzRcXHg2MVxceDc0XFx4NjVcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDQ1XFx4NmMnXTt2YXIgX3MyMloyc3MyPV8xMWlbMF0sX2lsSUxJSWlpPV8xMWlbMV07cmV0dXJuIHRoaXMuY2xpZW50UmVmZXJlbmNlSWQ7fSxlbnVtZXJhYmxlOl9Pb09bMTBdLGNvbmZpZ3VyYWJsZTpfT29PWzEwXX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShBQ0lDQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUsX09vT1s3XSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9vb1E9WzE1NDU3XTt2YXIgX2wxbElMMUxsPV9vb1FbMF07cmV0dXJuIHRoaXMuZndjaW1CbG9iO30sZW51bWVyYWJsZTpfT29PWzEwXSxjb25maWd1cmFibGU6X09vT1sxMF19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLF9Pb09bM10se2dldDpmdW5jdGlvbigpe3ZhciBfUTBvMD1bXTtyZXR1cm4gdGhpcy5jYWxsYmFjazt9LGVudW1lcmFibGU6X09vT1sxMF0sY29uZmlndXJhYmxlOl9Pb09bMTBdfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEFDSUNDbGllbnRSZXF1ZXN0LnByb3RvdHlwZSxfT29PWzRdLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgX1okcz1bXTt2YXIgXzFJMUxMMWlpPWZ1bmN0aW9uKF8xSWxpaTFMaSl7dmFyIF9vMG89WzU5NjAsMTg1OTFdO3ZhciBfb09PTzBvbzA9X28wb1swXTtyZXR1cm4gX28wb1sxXTt9O3JldHVybiB0aGlzLmRpc21pc3NDYWxsYmFjazt9LGVudW1lcmFibGU6X09vT1sxMF0sY29uZmlndXJhYmxlOl9Pb09bMTBdfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEFDSUNDbGllbnRSZXF1ZXN0LnByb3RvdHlwZSxfT29PWzldLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgX3oyPVtdO3ZhciBfJFMyejJaJFM9ZnVuY3Rpb24oX29PT08wUW8wLF9JTExMSWxJTCl7dmFyIF8yWj1bMzExMCwuNTEyMjI0MTc4ODc0NzY3OSwuNTgzNzAyNDM1ODIyMDI0LCdcXHg2ZlxceDYyXFx4NjZcXHg3NVxceDczXFx4NjNcXHg2MVxceDc0XFx4NjUnXTt2YXIgX1Ewb1FPMG9PPV8yWlsxXTt2YXIgX09vb1FPUW9PPV8yWlsyXSxfbExJbGlpbGk9XzJaWzNdO3JldHVybiBfMlpbMF07fTtyZXR1cm4gdGhpcy5jaGFsbGVuZ2VMb2FkQ2FsbGJhY2s7fSxlbnVtZXJhYmxlOl9Pb09bMTBdLGNvbmZpZ3VyYWJsZTpfT29PWzEwXX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShBQ0lDQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUsX09vT1s1XSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF8yWiQ9W107cmV0dXJue2NsaWVudERhdGE6dGhpcy5jbGllbnREYXRhLGNoYWxsZW5nZVR5cGU6dGhpcy5jaGFsbGVuZ2VUeXBlLGxvY2FsZTp0aGlzLmxvY2FsZSxleHRlcm5hbElkOnRoaXMuZXh0ZXJuYWxJZCxlbmFibGVIZWFkZXJGb290ZXI6dGhpcy5lbmFibGVIZWFkZXJGb290ZXIsZW5hYmxlQnlwYXNzTWVjaGFuaXNtOnRoaXMuZW5hYmxlQnlwYXNzTWVjaGFuaXNtLGVuYWJsZU1vZGFsVmlldzp0aGlzLmVuYWJsZU1vZGFsVmlldyxldmVudFRyaWdnZXI6dGhpcy5ldmVudFRyaWdnZXIsYWFFeHRlcm5hbFRva2VuOnRoaXMuYWFFeHRlcm5hbFRva2VuLGZvcmNlSnNGbHVzaDp0aGlzLmZvcmNlSnNGbHVzaCxhYW1hdGlvblRva2VuOnRoaXMuYWFtYXRpb25Ub2tlbn07fSxlbnVtZXJhYmxlOl9Pb09bMTBdLGNvbmZpZ3VyYWJsZTpfT29PWzEwXX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShBQ0lDQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUsX09vT1sxXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9Tcz1bXTtyZXR1cm4gdGhpcy5jaGFsbGVuZ2VUeXBlO30sc2V0OmZ1bmN0aW9uKGNoYWxsZW5nZVR5cGUpe3ZhciBfMDBPPVtdO3RoaXMuY2hhbGxlbmdlVHlwZT1jaGFsbGVuZ2VUeXBlO30sZW51bWVyYWJsZTpfT29PWzEwXSxjb25maWd1cmFibGU6X09vT1sxMF19KTtyZXR1cm4gQUNJQ0NsaWVudFJlcXVlc3Q7fSgpO2V4cG9ydHMuQUNJQ0NsaWVudFJlcXVlc3Q9QUNJQ0NsaWVudFJlcXVlc3Q7IiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIEFDSUNFcnJvck5hbWU7KGZ1bmN0aW9uKEFDSUNFcnJvck5hbWUpe3ZhciBfSTE9WydcXHg0ZVxceDQ1XFx4NTRcXHg1N1xceDRmXFx4NTJcXHg0YlxceDVmXFx4NDVcXHg1MlxceDUyXFx4NGZcXHg1MicsJ1xceDQyXFx4NjFcXHg2NFxceDUyXFx4NjVcXHg3MVxceDc1XFx4NjVcXHg3M1xceDc0XFx4NDVcXHg3MlxceDcyXFx4NmZcXHg3MicsJ1xceDQ1XFx4NGRcXHg1MFxceDU0XFx4NTlcXHg1ZlxceDUyXFx4NDVcXHg1M1xceDUwXFx4NGZcXHg0ZVxceDUzXFx4NDUnLCdcXHg0MlxceDQxXFx4NDRcXHg1ZlxceDUyXFx4NDVcXHg1MVxceDU1XFx4NDVcXHg1M1xceDU0XFx4NWZcXHg0NVxceDUyXFx4NTJcXHg0ZlxceDUyJywnXFx4NDVcXHg2ZFxceDcwXFx4NzRcXHg3OVxceDUyXFx4NjVcXHg3M1xceDcwXFx4NmZcXHg2ZVxceDczXFx4NjUnLCdcXHg0OFxceDU0XFx4NTRcXHg1MFxceDVmXFx4NDVcXHg1MlxceDUyXFx4NGZcXHg1MicsJ1xceDRlXFx4NjVcXHg3NFxceDc3XFx4NmZcXHg3MlxceDZiXFx4NDVcXHg3MlxceDcyXFx4NmZcXHg3MicsJ1xceDU0XFx4NjlcXHg2ZFxceDY1XFx4NmZcXHg3NVxceDc0JywnXFx4NDhcXHg1NFxceDU0XFx4NTBcXHg0NVxceDcyXFx4NzJcXHg2ZlxceDcyJywnXFx4NTRcXHg0OVxceDRkXFx4NDVcXHg0ZlxceDU1XFx4NTQnXTtBQ0lDRXJyb3JOYW1lW19JMVs5XV09X0kxWzddO0FDSUNFcnJvck5hbWVbX0kxWzBdXT1fSTFbNl07QUNJQ0Vycm9yTmFtZVtfSTFbMl1dPV9JMVs0XTtBQ0lDRXJyb3JOYW1lW19JMVs1XV09X0kxWzhdO0FDSUNFcnJvck5hbWVbX0kxWzNdXT1fSTFbMV07fShBQ0lDRXJyb3JOYW1lPWV4cG9ydHMuQUNJQ0Vycm9yTmFtZXx8KGV4cG9ydHMuQUNJQ0Vycm9yTmFtZT17fSkpKTt2YXIgQUNJQ0Vycm9yPWZ1bmN0aW9uKCl7dmFyIF8kWj1bJ1xceDY1XFx4NzJcXHg3MlxceDZmXFx4NzJcXHg0ZVxceDYxXFx4NmRcXHg2NVxceDU2XFx4NjFcXHg2Y1xceDc1XFx4NjUnLHRydWVdO2Z1bmN0aW9uIEFDSUNFcnJvcihuYW1lKXt0aGlzLmVycm9yTmFtZT1uYW1lO31PYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQ0Vycm9yLnByb3RvdHlwZSxfJFpbMF0se2dldDpmdW5jdGlvbigpe3ZhciBfUTBvMG89WzQ3MDQ5LCdcXHg2MlxceDZmXFx4NjRcXHg3OVxceDQ2XFx4NzdcXHg2M1xceDY5XFx4NmRcXHg0M1xceDZmXFx4NmNcXHg2Y1xceDY1XFx4NjNcXHg3NFxceDZmXFx4NzInLC4zMjc1NzA5ODA5MTM3Mjk5NF07dmFyIF9PT1EwMDBvUT1fUTBvMG9bMl0sX0lsTGkxMWkxPV9RMG8wb1swXSxfUU9RMG9vMG89X1EwbzBvWzFdO3JldHVybiB0aGlzLmVycm9yTmFtZTt9LGVudW1lcmFibGU6XyRaWzFdLGNvbmZpZ3VyYWJsZTpfJFpbMV19KTtyZXR1cm4gQUNJQ0Vycm9yO30oKTtleHBvcnRzLkFDSUNFcnJvcj1BQ0lDRXJyb3I7IiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIEFDSUNTZXNzaW9uQ29udGV4dD1mdW5jdGlvbigpe3ZhciBfcyQ9WydcXHg2MScsMzA3NDFdO2Z1bmN0aW9uIEFDSUNTZXNzaW9uQ29udGV4dCgpe3RoaXMuYWFtYXRpb25SZXN1bHRzPVtdO3RoaXMudXNlclJlc3BvbnNlcz1bXTt9QUNJQ1Nlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hZGRSZXNwb25zZT1mdW5jdGlvbihyZXNwb25zZSl7dmFyIF8wb289W107dGhpcy51c2VyUmVzcG9uc2VzLnB1c2gocmVzcG9uc2UpO307QUNJQ1Nlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hZGRSZXN1bHQ9ZnVuY3Rpb24ocmVzdWx0KXt2YXIgXzJzPVtdO3RoaXMuYWFtYXRpb25SZXN1bHRzLnB1c2gocmVzdWx0KTt9O3ZhciBfUVFvUVEwMFE9X3MkWzBdLF9zWjJTWjJzJD1fcyRbMV07cmV0dXJuIEFDSUNTZXNzaW9uQ29udGV4dDt9KCk7ZXhwb3J0cy5BQ0lDU2Vzc2lvbkNvbnRleHQ9QUNJQ1Nlc3Npb25Db250ZXh0OyIsIidcXHg3NVxceDczXFx4NjVcXHgyMFxceDczXFx4NzRcXHg3MlxceDY5XFx4NjNcXHg3NCc7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJ1xceDVmXFx4NWZcXHg2NVxceDczXFx4NGRcXHg2ZlxceDY0XFx4NzVcXHg2Y1xceDY1Jyx7dmFsdWU6dHJ1ZX0pO3ZhciBBQ0lDVXNlclJlc3BvbnNlPWZ1bmN0aW9uKCl7dmFyIF9MST1bXTtmdW5jdGlvbiBBQ0lDVXNlclJlc3BvbnNlKGNoYWxsZW5nZVR5cGUsZGF0YSl7dGhpcy5jaGFsbGVuZ2VUeXBlPWNoYWxsZW5nZVR5cGU7dGhpcy5kYXRhPWRhdGE7fXJldHVybiBBQ0lDVXNlclJlc3BvbnNlO30oKTtleHBvcnRzLkFDSUNVc2VyUmVzcG9uc2U9QUNJQ1VzZXJSZXNwb25zZTsiLCInXFx4NzVcXHg3M1xceDY1XFx4MjBcXHg3M1xceDc0XFx4NzJcXHg2OVxceDYzXFx4NzQnO3ZhciBfX2ltcG9ydERlZmF1bHQ9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKG1vZCl7dmFyIF9MbD1bXTtyZXR1cm4gbW9kJiZtb2QuX19lc01vZHVsZT9tb2Q6eydcXHg2NFxceDY1XFx4NjZcXHg2MVxceDc1XFx4NmNcXHg3NCc6bW9kfTt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdcXHg1ZlxceDVmXFx4NjVcXHg3M1xceDRkXFx4NmZcXHg2NFxceDc1XFx4NmNcXHg2NScse3ZhbHVlOnRydWV9KTt2YXIgYWNpY18xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg2MVxceDYzXFx4NjlcXHg2MycpO3ZhciBrYXRhbF9sb2dnZXJfMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZSgnXFx4NDBcXHg2MVxceDZkXFx4N2FcXHg2ZVxceDJmXFx4NmJcXHg2MVxceDc0XFx4NjFcXHg2Y1xceDJkXFx4NmNcXHg2ZlxceDY3XFx4NjdcXHg2NVxceDcyJykpO3ZhciBLYXRhbEVuZHBvaW50UmVzb2x2ZXJfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NGJcXHg2MVxceDc0XFx4NjFcXHg2Y1xceDQ1XFx4NmVcXHg2NFxceDcwXFx4NmZcXHg2OVxceDZlXFx4NzRcXHg1MlxceDY1XFx4NzNcXHg2ZlxceDZjXFx4NzZcXHg2NVxceDcyJyk7aWYoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCl7Y29uc29sZS5sb2coJ1xceDQxXFx4NjRcXHg2NFxceDY5XFx4NmVcXHg2N1xceDIwXFx4NzBcXHg2ZlxceDZjXFx4NzlcXHg2NlxceDY5XFx4NmNcXHg2Y1xceDIwXFx4NjZcXHg2ZlxceDcyXFx4MjBcXHg3M1xceDc0XFx4NjFcXHg3MlxceDc0XFx4NzNcXHg1N1xceDY5XFx4NzRcXHg2OCcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCdcXHg3M1xceDc0XFx4NjFcXHg3MlxceDc0XFx4NzNcXHg1N1xceDY5XFx4NzRcXHg2OCcse3ZhbHVlOmZ1bmN0aW9uKHNlYXJjaCxyYXdQb3Mpe3ZhciBfaTE9WzBdO3ZhciBwb3M9cmF3UG9zPl9pMVswXT9yYXdQb3N8X2kxWzBdOl9pMVswXTtyZXR1cm4gdGhpcy5zdWJzdHJpbmcocG9zLHBvcytzZWFyY2gubGVuZ3RoKT09PXNlYXJjaDt9fSk7fWlmKCFTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKXt2YXIgX1FvMDBPUVFvPWZ1bmN0aW9uKF8yWjJ6c1Naeil7dmFyIF8kUz1bJ1xceDYzXFx4NjFcXHg3MFxceDc0XFx4NjNcXHg2OFxceDYxXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJywuMDU2MzIwNTg1OTU0MzIzNjU0LCdcXHg2OVxceDY0JywnXFx4NmZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1XFx4NGFcXHg3M1xceDZmXFx4NmUnLC45MTQ0OTU4OTAyNjc4MjA5LCdcXHg2NFxceDZmXFx4NmRcXHg0ZVxceDZmXFx4NjRcXHg2NScsJ1xceDYyXFx4NmZcXHg2NFxceDc5J107dmFyIF9MSUlMSTFJbD1fJFNbMl07dmFyIF9zJDIkWiQyJD1fJFNbMF0sX3paenMyenoyPV8kU1s0XSxfT1FPT1FRMG89XyRTWzFdO3ZhciBfT29vb1FPTzA9XyRTWzZdLF8kc3MkMjJacz1fJFNbM107cmV0dXJuIF8kU1s1XTt9O2NvbnNvbGUubG9nKCdcXHg0MVxceDY0XFx4NjRcXHg2OVxceDZlXFx4NjdcXHgyMFxceDcwXFx4NmZcXHg2Y1xceDc5XFx4NjZcXHg2OVxceDZjXFx4NmNcXHgyMFxceDY2XFx4NmZcXHg3MlxceDIwXFx4NjVcXHg2ZVxceDY0XFx4NzNcXHg1N1xceDY5XFx4NzRcXHg2OCcpO1N0cmluZy5wcm90b3R5cGUuZW5kc1dpdGg9ZnVuY3Rpb24oc2VhcmNoLHRoaXNfbGVuKXt2YXIgX0xpPVsnXFx4NjlcXHg2NFxceDQ5XFx4NjQnXTt2YXIgX1paWnNzUzIkPV9MaVswXTtpZih0aGlzX2xlbj09PXVuZGVmaW5lZHx8dGhpc19sZW4+dGhpcy5sZW5ndGgpe3ZhciBfUVFRT1FRMDA9ZnVuY3Rpb24oX0wxbDFJMUxMLF8wTzBvUW9RTyl7dmFyIF9vUT1bJ1xceDYzXFx4NjFcXHg3MFxceDc0XFx4NjNcXHg2OFxceDYxJywnXFx4NjJcXHg2ZlxceDY0XFx4NzknLC45NzQzMDk1NzMyOTgyNjAxLCdcXHg2NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0XFx4NDhcXHg2MVxceDczXFx4NjgnLCdcXHg2NVxceDZjJywyNzY5NSwuMzgyMTMwMjUyMjAyMjQ1MTddO3ZhciBfSTFMbDFsbDE9X29RWzVdLF9vUVFRbzBRUT1fb1FbMF07dmFyIF9vMDBRMFEwMD1fb1FbM10sX2xJaUlpMUlsPV9vUVs0XTt2YXIgX3oyc3NaeiR6PV9vUVs2XSxfT1FvMDBPMFE9X29RWzJdO3JldHVybiBfb1FbMV07fTt0aGlzX2xlbj10aGlzLmxlbmd0aDt9cmV0dXJuIHRoaXMuc3Vic3RyaW5nKHRoaXNfbGVuLXNlYXJjaC5sZW5ndGgsdGhpc19sZW4pPT09c2VhcmNoO307fXZhciBhY2ljS2F0YWxMb2dnZXI9bmV3IGthdGFsX2xvZ2dlcl8xLmRlZmF1bHQoe3VybDpLYXRhbEVuZHBvaW50UmVzb2x2ZXJfMS5LYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0S2F0YWxMb2dnZXJFbmRwb2ludCgpfSk7dmFyIGFjaWM9bmV3IGFjaWNfMS5BQ0lDKGFjaWNLYXRhbExvZ2dlcik7d2luZG93LmFjaWM9YWNpYzsiLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9
/////////////////////////
// END FILE js/acic.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/register-acic.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
if (P && P.AUI_BUILD_DATE) {
    P.when('A', 'ready').register('acic-component', function(A) {
        return;
    });
}
/////////////////////////
// END FILE js/register-acic.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/map-ios-bridge.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

if (P && P.AUI_BUILD_DATE) {
    P.when('A', 'mobile-auth-platform').register('acic-map-ios-bridge', function(A, mapBridge) {
        // MAP iOS fix supported version: https://w.amazon.com/bin/view/IdentityServices/Mobile/iOS/Documentation/JS_Bridge__Onboarding_Guide_for_Infinite_Spinner
        var mapSupportVersion = Object.freeze({
            major: 6,
            minor: 12,
            patch: 4
        });

        var ErrorNames = Object.freeze({
            AA_DISMISS_SPINNER_API_ERROR: "AADismissSpinnerApiError",
            AA_INCOMPATIBLE_IOS_APP_VERSION: "AAIncompatibleIOSAppVersion"
        });

        function dismissSpinner(errorCallback) {
            // JS bridge will only be available on app webView.
            if (mapBridge.isJSBridgeAvailable()) {
                mapBridge.getCurrentAppInfo(function(currentAppInfo) {
                    if (currentAppInfo && currentAppInfo.platform === "iOS"
                        && isMAPVersionNewerThanSupportVersion(currentAppInfo.mapVersion)) {
                        dismissIOSAppSpinner(errorCallback);
                    } else if (currentAppInfo && currentAppInfo.platform === "iOS") {
                        // Should not render AA challenges for incompatible ios app, will set up sev2 monitor for this error.
                        errorCallback(ErrorNames.AA_INCOMPATIBLE_IOS_APP_VERSION, {"MapVersion": currentAppInfo.mapVersion});
                    }
                });
            }
        }

        function dismissIOSAppSpinner(errorCallback) {
            setInterval(function () {
                mapBridge.dismissSpinnerView(function(data) {
                    if (data.error) {
                        errorCallback(ErrorNames.AA_DISMISS_SPINNER_API_ERROR, data.error);
                    }
                });
            }, 3000);
        }

        function isMAPVersionNewerThanSupportVersion(currentVersion) {
            if (!currentVersion) {
                return false;
            }
            // IOS version: major.minor.patch
            var semanticVersion = currentVersion.split('.');
            var major = parseInt(semanticVersion[0] || "0");
            var minor = parseInt(semanticVersion[1] || "0");
            var patch = parseInt(semanticVersion[2] || "0");

            if (major !== mapSupportVersion.major) {
                return major > mapSupportVersion.major;
            } else if (minor !== mapSupportVersion.minor) {
                return minor > mapSupportVersion.minor;
            }
            return patch >= mapSupportVersion.patch;
        }

        return {
            dismissSpinner: dismissSpinner,
            isMAPVersionNewerThanSupportVersion: isMAPVersionNewerThanSupportVersion
        }
    });
}
/////////////////////////
// END FILE js/map-ios-bridge.js
/////////////////////////

// END ASSET ACICAssets - 1.0
}));
////////////////////////////////////////////